module mass_flux_mod

!=======================================================================
!  Mass Flux parameterization that could be used in EDMF (Eddy-Diffusivity/Mass-Flux) approach
!
!  Create by Yi-Hsuan Chen & Chuck Seman, 2020.
!
!  History:
!    2020/05/26  ver 1.0
!    2020/05/27  ver 1.1  Add send_data codes in mass_flux and mass_flux_tendencies subroutines
!                         Also, add an input argument, time, to these two subroutines
!    ......               Miss tracks
!    2020/07/10  ver 3.0  dry version of mass-flux scheme
!    2020/08/22  ver 4.0  dry version of mass-flux scheme, with difference numerical option
!    2020/09/26  ver 5.0  Full dry EDMF version (ED can be handled by mass_flux)
!                         correct the bad loop of mass_flux_tendencies (this in is i,j loop)
!    2020/09/28  ver 5.1  Replace Poisson program
!    2020/10/10  ver 5.2  Add fixed entrainment rate option
!=======================================================================

use           mpp_mod, only: input_nml_file

use           fms_mod, only: file_exist, open_namelist_file,       &
                             error_mesg, FATAL, close_file, note,  &
                             check_nml_error, mpp_pe, mpp_root_pe, &
                             write_version_number, stdlog, stdout, &
                             mpp_chksum

use     constants_mod, only: rdgas, rvgas, kappa, grav, &
                             cp_air, dens_h2o, hlv, hlf

use  diag_manager_mod, only: register_diag_field, send_data

use  time_manager_mod, only: time_type

use  sat_vapor_pres_mod,    only: compute_qs

use random_numbers_mod,    only:  randomNumberStream,   &
                                  getRandomNumbers

use random_number_streams_mod, only: random_number_streams_init, &
                                     get_random_number_streams, &
                                     random_number_streams_end
 
!---------------------------------------------------------------------

implicit none
private

!---------------------------------------------------------------------

public :: mass_flux_driver, mass_flux_init, mass_flux, &
          save_massflux_tendencies, mass_flux_end

!---------------------------------------------------------------------

!---------------------------------------------------------------------

character(len=128) :: version = '$Id$'
character(len=128) :: tagname = '$Name$'
logical            :: module_is_initialized = .false.
 
!---------------------------------------------------------------------
!  derived type definition for mf_tendency_type variable
!---------------------------------------------------------------------

public :: mf_tendency_type

type mf_tendency_type
     real, dimension(:,:,:), allocatable :: utnd
     real, dimension(:,:,:), allocatable :: vtnd
     real, dimension(:,:,:), allocatable :: ttnd
     real, dimension(:,:,:), allocatable :: qtnd
     real, dimension(:,:,:), allocatable :: thvtnd
     real, dimension(:,:,:), allocatable :: qttnd
end type mf_tendency_type

! routines to allocate and deallocate Tend_mf (currently not used)

private :: MF_alloc, MF_dealloc

!---------------------------------------------------------------------
! --- Constants
!---------------------------------------------------------------------

real, parameter :: p00    = 1000.0e2
real, parameter :: p00inv = 1./p00
real, parameter :: d622   = rdgas/rvgas
real, parameter :: d378   = 1.-d622
real, parameter :: d608   = d378/d622

!integer, parameter:: dp=kind(0.d0)                   ! double precision
!integer, parameter:: sp=kind(0.)                     ! single precision

!---------------------------------------------------------------------
! --- Namelist
!---------------------------------------------------------------------

integer :: up_num = 10                ! number of updrafts

logical :: do_mf_micro = .false.      ! enable/disable microphysics computation in updrafts. 
                                      ! True: do moist processes. False: no moist processes, i.e. all updrafts are assumed to be dry

!--- MF options ---
character*20 :: option_MF_numerics = "explicit"
!character*20 :: option_MF_numerics = "implicit"
!character*20 :: option_MF_numerics = "none"

!--- ED options ---
logical :: do_ED_in_mass_flux = .false.   ! do ED in mass_flux

!character*20 :: option_ED_numerics = "explicit"
!character*20 :: option_ED_numerics = "implicit"
character*20 :: option_ED_numerics = "none"

!--- surface flux option ---
!logical :: do_include_surf_flux = .true.
logical :: do_include_surf_flux = .false.

character*20 :: option_surface_flux = "star"     ! use surface flux diagnosed from u_star, q_star, b_star
!character*20 :: option_surface_flux = "updated"

real, parameter :: shflx_updated = 13.06  ! W/m2    ! temperoray 
real, parameter :: qflx_updated = 1.e-8  ! kg/m2/s

! compute phi_bar at half levels to calculate flux (now only available for the explicit solver)
!   default: centered-difference, i.e. phi_bar(k-1/2) = 0.5( phi_bar(k-1)+phi_bar(k) )
!   upwind : upwind-difference  , i.e. phi_bar(k-1/2) = phi_bar(k)
character*20 :: option_MF_env_half = "upwind_env"
!character*20 :: option_MF_env_half = "upwind_updraft"   
!character*20 :: option_MF_env_half = "centered-diff"   

!--- set the levels where updrafts are put
!      half (default): updrafts are put at model half levels
!      full          : updrafts are put at model full levels. 
!                      Note that the tendencies are calculated at half levels. If returning tendencies to the parent model,
!                      the tendencies should be put back to model full levels 
!character*20, parameter :: option_updraft_level = "full" ! put updrafts at full levels   
character*20 :: option_updraft_level = "half" ! default put updrafts at half levels   

!--- fileter of moist mass flux
!      "none": no filter
!      "if_moist_allmf_off": if moist updraft is present, set ALL mass flux to zero, i.e. no mass flux
!      "if_moist_allmoist_off": if moist updraft is present, exclude the contributions from moist updrafts
character*40 :: filter_massflux = "none" 
!character*40 :: filter_massflux = "if_moist_allmf_off"       ! if moist updraft is present, set ALL mass flux effect to zero
!character*40 :: filter_massflux = "if_moist_allmoist_off"   ! if moist updraft is present, exclude moist updraft contribution

!--- choose which tendencies are returned to the host model
!      default: return u,v,t,q tendencies
!      t_q    : only return t and q tendencies 
!      t      : only return t tendencies 
character*20 :: choose_return = "u_v_t_q"
!character*20 :: choose_return = "t_q"
!character*20 :: choose_return = "t"

real :: z_pbl_min = 100.              ! set minimum PBL height in order to avoid unrealistic lower BCs of updrafts
real :: w_star_min = 0.1              ! set minimum w* in order to avoid unrealistic lower BCs of updrafts
real :: ent0 = 0.2                    ! epsilon_0, Eq (14), Suselj (2019b)
real :: ent_length = 30.              ! L_epsilon, Eq (30), Suselj (2019b). Set to a constant at this moment
real :: z0_over_z_pbl = 0.1           ! z_0/z_pbl, Eq (A19-21), Suselj (2019a)
real :: pwmin = 1.                    ! pwmin*w_sigma is the smallest surface vertical velocity for updraft ensembles
real :: pwmax = 3.                    ! pwmax*w_sigma is the largest  surface vertical velocity for updraft ensembles
real :: aw = 1.                       ! a_w, Eq (12), Suselj (2019b)  
real :: bw = 1.5                      ! b_w, Eq (12), Suselj (2019b)
real :: w_max = 2.                    ! maximum of updraft velcovity (m/s)
real :: qt_excess_max = 1.e-3         ! maximum of moisture excess at updraft base (kg/kg) 
real :: thv_excess_max = 0.5          ! maximum of virtual potential temperature excess at updraft base (K)
real :: ent_fixed = 5.e-3             ! fixed entrainment rate (1/m) when do_stoch_entrain = .false.

logical :: do_printouts = .false.         ! OUTDATED. write out some fields into the fms.log
logical :: do_writeout_profile = .false.  ! write out some fields into the fms.log
logical :: do_stop_run = .false.          ! stop the simulation if some problematic things happen, e.g. 2000 K/day heating rate

logical :: do_check_trc_rlzbility = .true. ! check tracer realizability
logical :: do_stoch_entrain       = .true. ! do stochastic entrainmentm otherwise the entrainment rate is fixed by ent_fixed
character*20 :: option_stoch_entrain = "Poisson"
!character*20 :: option_stoch_entrain = "random_Poisson"

logical :: use_tau_mf = .true.            ! .true. use current u,v,t,q in the mass_flux program
                                          ! else   use updated u,v,t,q, i.e. u,v,t,q plus the tendencies times dt

!--- temp tests 
real :: rh_flag111 = 0.    ! a test simulation that put some moisture at the atmospheric lowest level
                           ! and see how much cloud water is condensed in the updraft.
                           ! The purpose of this test is to understand how frequent moist updrafts are.
!character*20, public, parameter :: rh_flag111_layer = "column"
!character*20 :: rh_flag111_layer = "lowest_atm"
character*20 :: rh_flag111_layer = ""

namelist / mass_flux_nml / up_num, do_mf_micro, &
                           z_pbl_min, w_star_min, &
                           ent0, ent_length, z0_over_z_pbl, &
                           pwmin, pwmax, aw, bw, &
                           filter_massflux, choose_return, &
                           w_max, qt_excess_max, thv_excess_max, &
                           option_MF_env_half, &
                           use_tau_mf,   &
                           do_stoch_entrain, option_stoch_entrain, ent_fixed, &
                           option_MF_numerics, option_ED_numerics, option_surface_flux, do_include_surf_flux, do_ED_in_mass_flux, &      
                           do_writeout_profile, do_printouts, do_stop_run, do_check_trc_rlzbility
         
!---------------------------------------------------------------------
!--- Diagnostic fields       
!---------------------------------------------------------------------

character(len=10) :: mod_name = 'mass_flux'
real              :: missing_value = -999.

integer :: & 
           id_uu, id_vv, id_tt, id_qq, &
           id_up_a, id_up_w, id_up_aw, id_up_awu, id_up_awv, id_up_awthv, id_up_awqt,  &
           id_udt_mf, id_vdt_mf, id_tdt_mf, id_qdt_mf, id_thvdt_mf, id_thlidt_mf, id_qtdt_mf, id_up_massflux, id_w1_thli1_mf, &
           id_ent_min, id_ent_max, id_ent_mean, &
           id_up_qt, id_up_qc, id_moist_massflux, id_is_massflux, id_tend_ratio

!---------------------------------------------------------------------

  contains

!#######################################################################

subroutine mass_flux_init(lonb, latb, axes, time, id, jd, kd)

!-----------------------------------------------------------------------
!  (Intent in)
!-----------------------------------------------------------------------
!   latb, lonb  - latitudes and longitudes at grid box corners
!   axes, time  - variables needed for netcdf diagnostics
!   id, jd, kd  - size of the first 3 dimensions

 integer,              intent(in) :: id, jd, kd, axes(4)
 type(time_type),      intent(in) :: time
 real, dimension(:,:), intent(in) :: lonb, latb

!-----------------------------------------------------------------------
!  (Intent local)
!-----------------------------------------------------------------------
 integer, dimension(3) :: full = (/1,2,3/), half = (/1,2,4/)
 integer :: unit, io, ierr, logunit

!=======================================================================

  if ( module_is_initialized ) return

!-----------------------------------------------------------------------
! --- Read namelist
!-----------------------------------------------------------------------

#ifdef INTERNAL_FILE_NML
   read (input_nml_file, nml=mass_flux_nml, iostat=io)
   ierr = check_nml_error(io,'mass_flux_nml')
#else   
  if( file_exist( 'input.nml' ) ) then
! -------------------------------------
   unit = open_namelist_file( )
   ierr = 1
   do while( ierr .ne. 0 )
   READ ( unit,  nml = mass_flux_nml, iostat = io, end = 10 ) 
   ierr = check_nml_error (io, 'mass_flux_nml')
   end do
10 continue
   call close_file( unit )
! -------------------------------------
  end if
#endif

!-----------------------------------------------------------------------
! --- Check namelist
!-----------------------------------------------------------------------

if (do_ED_in_mass_flux) then
  if ( trim(option_ED_numerics) /= 'explicit' .and. &
       trim(option_ED_numerics) /= 'implicit' )       then 
    call error_mesg( ' mass_flux',     &
                     ' when do_ED_in_mass_flux is .true., option_ED_numerics must be "explicit" or "implicit" in the mass_flux_nml',&
                     FATAL )
  endif
  if (.not.do_include_surf_flux) then
    call error_mesg( ' mass_flux',     &
                     ' when do_ED_in_mass_flux is .true., do_include_surf_flux must be .true. in the mass_flux_nml',&
                     FATAL )
  endif

  !if (do_include_surf_flux) then
  !  call error_mesg( ' mass_flux',     &
  !                   ' when do_ED_in_mass_flux is .true., do_include_surf_flux must be .false. in the mass_flux_nml',&
  !                   FATAL )
  !endif

endif

!  if ( trim(option_solver) /= 'explicit' .and. &
!       trim(option_solver) /= 'implicit' )       then 
!    call error_mesg( ' mass_flux',     &
!                     ' option_solver must be "explicit" or "implicit" in the mass_flux_nml',&
!                     FATAL )
!  end if

!-----------------------------------------------------------------------
! --- Output version
!-----------------------------------------------------------------------

  if ( mpp_pe() == mpp_root_pe() ) then
       call write_version_number(version, tagname)
       logunit = stdlog()
       WRITE( logunit, nml = mass_flux_nml ) 
  endif

!-----------------------------------------------------------------------
!--- Register diagnostic fields       
!-----------------------------------------------------------------------

  id_tend_ratio = register_diag_field (mod_name, 'MF_tend_ratio', axes(1:2), Time, &
                 'tend ratio due to tracer realizibility', 'none' , &
                 missing_value=missing_value )

  id_is_massflux = register_diag_field (mod_name, 'is_massflux', axes(1:2), Time, &
                 'is mass flux (0: no, 1: yes)', 'none' , &
                 missing_value=missing_value )

  id_moist_massflux = register_diag_field (mod_name, 'is_moist_massflux', axes(1:2), Time, &
                 'is moist flux (0: no, 1: yes)', 'none' , &
                 missing_value=missing_value )

  id_uu = register_diag_field (mod_name, 'uu', axes(full), Time, &
                 'zonal wind', 'm/s' , &
                 missing_value=missing_value )

  id_vv = register_diag_field (mod_name, 'vv', axes(full), Time, &
                 'meridional wind', 'm/s' , &
                 missing_value=missing_value )

  id_tt = register_diag_field (mod_name, 'tt', axes(full), Time, &
                 'temperature', 'K' , &
                 missing_value=missing_value )

  id_qq = register_diag_field (mod_name, 'qq', axes(full), Time, &
                 'speficic humidity', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_a  = register_diag_field (mod_name, 'up_a', axes(half), Time, &
                 'updraft fractional area', 'fraction' , &
                 missing_value=missing_value )

  id_up_w = register_diag_field (mod_name, 'up_w', axes(half), Time, &
                 'averaged updraft velocity', 'm/s' , &
                 missing_value=missing_value )

  id_up_qc = register_diag_field (mod_name, 'up_qc', axes(half), Time, &
                 'updraft averaged in-cloud cloud water content', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_qt = register_diag_field (mod_name, 'up_qt', axes(half), Time, &
                 'updraft averaged in-cloud total water content', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_aw = register_diag_field (mod_name, 'up_aw', axes(half), Time, &
                 'updraft area*w', 'm/s' , &
                 missing_value=missing_value )
 
  id_up_massflux = register_diag_field (mod_name, 'up_massflux', axes(half), Time, &
                 'updraft mass flux', 'kg/m2/s' , &
                 missing_value=missing_value )

  id_up_awu = register_diag_field (mod_name, 'up_awu', axes(half), Time, &
                 'updraft area*w*u', 'm2/s2' , &
                 missing_value=missing_value )

  id_up_awv = register_diag_field (mod_name, 'up_awv', axes(half), Time, &
                 'updraft area*w*v', 'm2/s2' , &
                 missing_value=missing_value )

  id_up_awthv = register_diag_field (mod_name, 'up_awthv', axes(half), Time, &
                 'updraft area*w*theta_v', 'K m/s' , &
                 missing_value=missing_value )

  id_up_awqt = register_diag_field (mod_name, 'up_awqt', axes(half), Time, &
                 'updraft area*w*qt', 'kg/kg m/s' , &
                 missing_value=missing_value )

  id_udt_mf = register_diag_field (mod_name, 'udt_mf', axes(full), Time, &
                 'u tendency from mass flux', 'm/s2' , &
                 missing_value=missing_value )

  id_vdt_mf = register_diag_field (mod_name, 'vdt_mf', axes(full), Time, &
                 'v tendency from mass flux', 'm/s2' , &
                 missing_value=missing_value )

  id_tdt_mf = register_diag_field (mod_name, 'tdt_mf', axes(full), Time, &
                 't tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_qdt_mf = register_diag_field (mod_name, 'qdt_mf', axes(full), Time, &
                 'q tendency from mass flux', 'kg/kg/s' , &
                 missing_value=missing_value )

  id_thvdt_mf = register_diag_field (mod_name, 'thvdt_mf', axes(full), Time, &
                 'thv tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_thlidt_mf = register_diag_field (mod_name, 'thlidt_mf', axes(full), Time, &
                 'thli tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_qtdt_mf = register_diag_field (mod_name, 'qtdt_mf', axes(full), Time, &
                 'qt tendency from mass flux', 'kg/kg/s' , &
                 missing_value=missing_value )

  id_w1_thli1_mf = register_diag_field (mod_name, 'w1_thli1_mf', axes(half), Time, &
                 'subgrid mixing theta_li, w1_thli1', 'K m/s' , &
                 missing_value=missing_value )

  id_ent_min = register_diag_field (mod_name, 'MF_ent_min', axes(full), Time, &
                 'MF entrainment minimum', '1/km' , &
                 missing_value=missing_value )

  id_ent_max = register_diag_field (mod_name, 'MF_ent_max', axes(full), Time, &
                 'MF entrainment maximum', '1/km' , &
                 missing_value=missing_value )

  id_ent_mean = register_diag_field (mod_name, 'MF_ent_mean', axes(full), Time, &
                 'MF entrainment mean', '1/km' , &
                 missing_value=missing_value )

!-----------------------------------------------------------------------
!--- Done with initialization
!-----------------------------------------------------------------------

  module_is_initialized = .true.

!-----------------------------------------------------------------------

end subroutine mass_flux_init

!#######################################################################

subroutine MF_alloc ( id, jd, kd, Tend_mf )

 integer, intent(in) :: id, jd, kd

 type(mf_tendency_type), intent(inout) :: Tend_mf

!-----------------------------------------------------------------------
! --- allocate and initialize Tend_mf mass flux tendencies
!-----------------------------------------------------------------------

  allocate (Tend_mf%utnd  (id,jd,kd)) ; Tend_mf%utnd   = 0.
  allocate (Tend_mf%vtnd  (id,jd,kd)) ; Tend_mf%vtnd   = 0.
  allocate (Tend_mf%ttnd  (id,jd,kd)) ; Tend_mf%ttnd   = 0.
  allocate (Tend_mf%qtnd  (id,jd,kd)) ; Tend_mf%qtnd   = 0.
  allocate (Tend_mf%thvtnd(id,jd,kd)) ; Tend_mf%thvtnd = 0.
  allocate (Tend_mf%qttnd (id,jd,kd)) ; Tend_mf%qttnd  = 0.

!-----------------------------------------------------------------------

end subroutine MF_alloc

!#######################################################################

subroutine mass_flux_end

!-----------------------------------------------------------------------

  if (.not.module_is_initialized) return

  module_is_initialized = .false.

!-----------------------------------------------------------------------

  end subroutine mass_flux_end

!#######################################################################

subroutine MF_dealloc ( Tend_mf )

 type(mf_tendency_type), intent(inout) :: Tend_mf

!-----------------------------------------------------------------------
! deallocate Tend_mf mass flux tendencies
!-----------------------------------------------------------------------

  if (allocated(Tend_mf%utnd))   deallocate (Tend_mf%utnd  )
  if (allocated(Tend_mf%vtnd))   deallocate (Tend_mf%vtnd  )
  if (allocated(Tend_mf%ttnd))   deallocate (Tend_mf%ttnd  )
  if (allocated(Tend_mf%qtnd))   deallocate (Tend_mf%qtnd  )
  if (allocated(Tend_mf%thvtnd)) deallocate (Tend_mf%thvtnd)
  if (allocated(Tend_mf%qttnd))  deallocate (Tend_mf%qttnd )

end subroutine MF_dealloc

!#######################################################################

subroutine save_massflux_tendencies ( udt_mf, vdt_mf, tdt_mf, qdt_mf, & 
                                      thvdt_mf, qtdt_mf, &
                                      Tend_mf )

!---------------------------------------------------------------------
!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!   thvdt_mf - virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!   qtdt_mf  - total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!---------------------------------------------------------------------

  real, intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
      udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, qtdt_mf

!---------------------------------------------------------------------
!   Tend_mf  - mass flux tendencies derived type variable
!---------------------------------------------------------------------

  type(mf_tendency_type), intent(out) :: Tend_mf

!---------------------------------------------------------------------
!  Local
!---------------------------------------------------------------------

  integer :: i,j,k
  integer :: ix,jx,kx

!---------------------------------------------------------------

    Tend_mf%utnd  (:,:,:) =   udt_mf(:,:,:)
    Tend_mf%vtnd  (:,:,:) =   vdt_mf(:,:,:)
    Tend_mf%ttnd  (:,:,:) =   tdt_mf(:,:,:)
    Tend_mf%qtnd  (:,:,:) =   qdt_mf(:,:,:)
    Tend_mf%thvtnd(:,:,:) = thvdt_mf(:,:,:)
    Tend_mf%qttnd (:,:,:) =  qtdt_mf(:,:,:)

!--- set dimensions

  ix  = size( udt_mf, 1 )
  jx  = size( udt_mf, 2 )
  kx  = size( udt_mf, 3 )

!--- assign tendencies to Tend_mf derived type variable

!  do i=1,ix
!  do j=1,jx
!  do k=1,kx
!    Tend_mf%utnd  (i,j,k) =   udt_mf(i,j,k)
!    Tend_mf%vtnd  (i,j,k) =   vdt_mf(i,j,k)
!    Tend_mf%ttnd  (i,j,k) =   tdt_mf(i,j,k)
!    Tend_mf%qtnd  (i,j,k) =   qdt_mf(i,j,k)
!    Tend_mf%thvtnd(i,j,k) = thvdt_mf(i,j,k)
!    Tend_mf%qttnd (i,j,k) =  qtdt_mf(i,j,k)
!  enddo
!  enddo
!  enddo

end subroutine save_massflux_tendencies


!###########################################
! subroutine mass_flux_driver
!
!   The interface of mass_flux program
!###########################################
!subroutine mass_flux_driver ( is, ie, js, je, dt, Time_next,            &
!                              do_mass_flux_diagnostic, &
!                              p_half, p_full, z_half, z_full,   & 
!                              u_star, b_star, q_star, z_pbl,    &
!                              uu, vv, tt, qq,                   &
!                              udt, vdt, tdt, qdt )

subroutine mass_flux_driver ( is, ie, js, je, dt, Time_next,           &
                              do_mass_flux_diagnostic, do_EDMF_in_mass_flux,    &
                              p_half, p_full, z_half, z_full,          &
                              u_star, b_star, q_star, z_pbl,           &
                              uu_in, vv_in, tt_in, qq_in,              &
                              udt, vdt, tdt, qdt, &
                              diff_t, diff_m, diff_t_to_vdiff, diff_m_to_vdiff )

!---------------------------------------------------------------------
! Arguments (Intent in)  
!   Descriptions of these variables are in subroutine mass_flux
!---------------------------------------------------------------------

  integer, intent(in)                   :: is, ie, js, je
  real,    intent(in)                   :: dt
  type(time_type), intent(in)           :: Time_next
  logical, intent(in)                   :: do_mass_flux_diagnostic
  real,    intent(in), dimension(:,:,:) :: p_full, z_full
  real,    intent(in), dimension(:,:,:) :: p_half, z_half
  real,    intent(in), dimension(:,:,:) :: uu_in, vv_in, tt_in, qq_in
  real,    intent(in), dimension(:,:)   :: z_pbl, u_star, b_star, q_star

  !real,    intent(in), optional, dimension(:,:,:) :: diff_t, diff_m
  real,    intent(in)   , optional, dimension(:,:,:) :: diff_t, diff_m
  real,    intent(out)  , optional, dimension(:,:,:) :: diff_t_to_vdiff, diff_m_to_vdiff

!---------------------------------------------------------------------
! Arguments (Intent out)
!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!
!   The tendencies from the mass flux program will be added up to the existing ones.
!---------------------------------------------------------------------

  real,    intent(inout), dimension(:,:,:) :: udt, vdt, tdt, qdt
  logical, intent(out)                     :: do_EDMF_in_mass_flux

!---------------------------------------------------------------------
!  Local
!   Descriptions of these variables are in subroutine mass_flux
!---------------------------------------------------------------------

  real   , dimension(size(tt_in,1),size(tt_in,2),size(tt_in,3))    :: &
           uu, vv, tt, qq,                                   &                ! state variables used in the mass flux program
           udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf       ! tendencies terms
  
  real   , dimension(size(tt_in,1),size(tt_in,2),size(tt_in,3)+1)  ::   &
           sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,        &   ! subgrid mixing terms
           sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux
  
  real, dimension(size(tt_in,1),size(tt_in,2))   :: is_mass_flux        ! indicate whether there are updrafts

  integer :: i,j,k
  real    :: tt1, tt2

!----------------------------------

  if (use_tau_mf) then   ! use current u,v,t,q
    uu(:,:,:) = uu_in(:,:,:)
    vv(:,:,:) = vv_in(:,:,:)
    tt(:,:,:) = tt_in(:,:,:)
    qq(:,:,:) = qq_in(:,:,:)

  else   ! use updated u,v,t,q
    uu(:,:,:) = uu_in(:,:,:) + udt(:,:,:)*dt
    vv(:,:,:) = vv_in(:,:,:) + vdt(:,:,:)*dt
    tt(:,:,:) = tt_in(:,:,:) + tdt(:,:,:)*dt
    qq(:,:,:) = qq_in(:,:,:) + qdt(:,:,:)*dt
  endif

  !--- initialize diff_t_to_vdiff and diff_m_to_vdiff
  if (present(diff_t_to_vdiff)) diff_t_to_vdiff(:,:,:) = diff_t(:,:,:)
  if (present(diff_m_to_vdiff)) diff_m_to_vdiff(:,:,:) = diff_m(:,:,:)

  !--- if doing ED in the mass_flux program, to avoid double counting ED in vert_diff
  !    set diff_t & diff_m to zeros
  if (do_ED_in_mass_flux) then
    do_EDMF_in_mass_flux = .true.

    if (.not.present(diff_t) .or. .not.present(diff_m)) &
       call error_mesg(' mass_flux_mod',  &
                       ' when do_ED_in_mass_flux is .true., diff_t and diff_m must be present in mass_flux program', &
                       FATAL )     

    if (.not.present(diff_t_to_vdiff) .or. .not.present(diff_m_to_vdiff)) &
       call error_mesg(' mass_flux_mod',  &
                       ' when do_ED_in_mass_flux is .true., diff_t_to_vdiff and diff_m_to_vdiff must be present in mass_flux program', &
                       FATAL )     

    if (present(diff_t_to_vdiff)) diff_t_to_vdiff = 0.
    if (present(diff_m_to_vdiff)) diff_m_to_vdiff = 0.
  endif

  !--- compute mass flux and corresponding tendency terms
  call mass_flux ( is, ie, js, je, dt, Time_next,                        &
                   p_half, p_full, z_half, z_full,                       & 
                   u_star, b_star, q_star, z_pbl,                        &
                   uu, vv, tt, qq,                                       &
                   is_mass_flux,                                         &
                   sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                   sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                   udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf, &
                   diff_t = diff_t, diff_m = diff_m)

  !--- added mass_flux tendencies to the existing tendencies
  if (.not.do_mass_flux_diagnostic) then
    if (choose_return.eq."t") then
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)

    else if (choose_return.eq."t_q") then
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)
      qdt(:,:,:) = qdt(:,:,:) + qdt_mf(:,:,:)
    else
      udt(:,:,:) = udt(:,:,:) + udt_mf(:,:,:)
      vdt(:,:,:) = vdt(:,:,:) + vdt_mf(:,:,:)
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)
      qdt(:,:,:) = qdt(:,:,:) + qdt_mf(:,:,:)
    end if
  end if

  !--- put tendency terms into Tend_mf
  !call save_massflux_tendencies ( udt_mf, vdt_mf, tdt_mf, qdt_mf, &
  !                                thvdt_mf, qtdt_mf, &
  !                                Tend_mf )

3000 format (A15,2X,F8.2)
3001 format (A15,2X,33(F10.3,2X,','))
3002 format (A15,2X,33(E12.4,2X,','))
3003 format (A15,2X,E12.4)

end subroutine mass_flux_driver

!###########################################
! subroutine mass_flux
!
! To-do (as of 06/21/2020)
!   1. Use ice-liquid water potential temperature, instead of virtual temperature
!
! Purpose:
!   (1) Compute updraft properties based on the grid-scale input variables, such as uu,vv,tt,qq, etc.
!   (2) Compute subgrid mixing from all updrafts, i.e. <w'phi'>
!   (3) Compute the tendencey terms by the subgrid mixing
!
! Numerical discretation. Note that when the vertical indexing is reversed when calculating updraft properties and tendencies from the implicit solver, in order to be consistent with Suselj et al. (2019b, JAS). 
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_*
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
! History:
!   2020/05/14  Add outputs of sum_up_a and avg_up_w
!               Add z_pbl_min and w_star1_min
!   2020/05/17  Make the vertical indexing of sum_up_* consistent with CM4 indexing
!   2020/06/04  Add sum_up_mass output argument
!   2020/06/07  Add check part
!   2020/06/21  Move mass_flux_tendencies program here, to simplify the calling structure
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
! References:
!   Suselj et al. (2014, WAF): 
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS): 
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1 
!###########################################

subroutine mass_flux ( is, ie, js, je, dt, Time_next,                        &
                       p_half, p_full, z_half, z_full,                       & 
                       u_star, b_star, q_star, z_pbl,                        &
                       uu, vv, tt, qq,                                       &
                       is_mass_flux,                                         &
                       sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                       sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                       udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf, &
                       diff_t, diff_m)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    is,ie,js,je -  indices marking the slab of model working on
!    dt          -  Time step               (sec)
!    Time_next   -  variable needed for netcdf output diagnostics
!    p_half      -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!    p_full      -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!    z_half      -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!    z_full      -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!    uu          -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!    vv          -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!    tt          -  temperature             (K)     , dimension (nlon, nlat, nlay)
!    qq          -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)  ,see note 1 below
!    z_pbl       -  boundary layer depth    (m)     , dimension (nlon, nlat)        ,see note 2 below
!    u_star      -  friction velocity       (m/s)   , dimension (nlon, nlat)        ,see note 2 below
!    b_star      -  buoyancy scale          (m/s^2) , dimension (nlon, nlat)        ,see note 2 below
!    q_star      -  moisture scale          (kg/kg) , dimension (nlon, nlat)        ,see note 2 below
!
!    diff_t      -  vertical diffusion coefficient for temperature (m2/s), dimension (nlon, nlat, nlay), see note 1 below
!    diff_m      -  vertical diffusion coefficient for momemtum    (m2/s), dimension (nlon, nlat, nlay), see note 1 below
!
! Set in namelist -  
!    up_num        - number of updrafts    (an integer)
!    do_mf_micro   - enable/disable microphysics computation in updrafts. 
!                      True: do moist processes. False: no moist processes, i.e. all updrafts are assumed to be dry
!    option_solver - option for solving the tendency terms. Detail description is in subroutine mass_flux_tendencies
!                      "explicit" uses an explicit scheme.     
!                      "implicit" uses an semi-implicit scheme
!
! Note:
!    1. z_pbl, diff_t,and diff_m are from a PBL scheme, e.g. my25, tke_turb, etc
!       Note that diff_t,and diff_m are not used in the mass flux program because vert_diff program handles these.
!
!    2. u_star and b_star are from monin_obukhov program, src/atmos_param/monin_obukhov/monin_obukhov_kernel.F90
!       q_star            is  from surface flux  program, src/FMScoupler/surface_flux.F90    
!
!            The magnitude of the wind stress is 
!                 density*(u_star**2)
!            The buoyancy flux, (g/theta_v) * <w'theta_v'>|surface, is
!                 u_star*b_star
!            The evaporation rate), kg vapor/m^2/s, is
!                 density*u_star*q_star
!                 So, u_star*q_star is surface moisture flux, <w'q'>, unit: (m/s * kg vapor/kg air)
!---------------------------------------------------------------------

  integer, intent(in)                   :: is, ie, js, je
  real,    intent(in)                   :: dt
  type(time_type), intent(in)           :: Time_next             
  real,    intent(in), dimension(:,:,:) :: p_full, z_full  
  real,    intent(in), dimension(:,:,:) :: p_half, z_half  
  real,    intent(in), dimension(:,:,:) :: uu, vv, tt, qq  
  real,    intent(in), dimension(:,:)   :: z_pbl, u_star, b_star, q_star

  real,    intent(in), optional, dimension(:,:,:) :: diff_t, diff_m

!---------------------------------------------------------------------
! Arguments (Intent out)
!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!                                                        dimension (nlon,nlat)
!    sum_up_a        - sum of the fractional area of individual updraft
!                        i.e. area   (unit: none),           dimension (nlon, nlat, nlay+1)
!    sum_up_aw       - sum of the product of fractional area and vertical velocity for individual updraft
!                        i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_awu      - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!                        i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awv      - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!                        i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awthv    - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!    sum_up_awthli   - sum of the product of fractional area, vertical velocity, and ice-liquid water potential temp for individual updraft
!                        i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!    sum_up_awqt     - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!                        i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!    avg_up_w        - averaged vertical velocity of updrafts, sum_up_aw/sum_up_a
!                        i.e. w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_massflux - sum of the updraft mass flux, i.e. rho * sum_up_aw
!                        i.e. a*w   (unit: kg/m2/s),           dimension (nlon, nlat, nlay+1)
!
!    udt_mf    -  zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!    vdt_mf    -  meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!    tdt_mf    -  temperature tendency                                (K/s)    , i.e. dt/dt
!    qdt_mf    -  specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!    thvdt_mf  -  virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!    thlidt_mf -  ice-liquid water potential temperature tendency     (K/s)    , i.e. dtheta_v/dt
!    qtdt_mf   -  total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!
! Note:
!   1. All updraft variables , sum_up_*, are at half level, i.e. the number of levels is nlay+1
!   2. All tendency variables, *dt_mf  , are at full level, i.e. the number of levels is nlay 
!---------------------------------------------------------------------

  real, intent(out), dimension(:,:)      :: &  ! dimension (nlon, nlat)
        is_mass_flux

  real, intent(out), dimension(:,:,:)       :: &  ! dimension (nlon, nlat, nlay+1)
        sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,     &
        sum_up_awthv, sum_up_awthli, sum_up_awqt,                       &
        avg_up_w, sum_up_massflux

  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
      thvdt_mf, thlidt_mf, qtdt_mf

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- variable for each updraft
  real, dimension(up_num, size(tt,1),size(tt,2),size(tt,3)+1)       :: &  ! dimension (up_num, nlon, nlat, nlay+1)
        each_up_a, each_up_aw,                                         &
        each_up_u, each_up_v, each_up_thv, each_up_thli, each_up_qt, each_up_qc,      &
        each_up_awu, each_up_awv, each_up_awthv,each_up_awthli, each_up_awqt,         &
        each_up_w, each_up_massflux

  !--- grid-mean variables for work
  real, dimension(size(tt,3)) ::      &  ! dimension (nlay)
        uu_rev, vv_rev, thv_rev,      &  ! reverse indexing so that these variables are counted from surface upward
        qt_rev, dz_rev,               &  !   i.e. k=1 is the lowermost level                       
        pfull_rev, thli_rev,          &
        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp

  real, dimension(size(tt,1),size(tt,2),size(tt,3)) :: &  ! dimension (nlon,nlat,nlay)
        qt,       & ! total water mixing ratio (kg/kg)
        th,       & ! potential temperature (K)
        thv,      & ! virtual potential temperature (K)
        thli,     & ! ice-liquid water potential temperature (K)
        tv,       & ! virtual temperature (K)
        rho_full, & ! air density at full levels (kg/m3)
        ape         ! (P/P0)^(-Rd/cp), factor to compute potential temperature
  
  real, dimension(size(tt,1),size(tt,2),size(tt,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
        rho_half,   &    ! air densivty at half levels
        w1_u1, w1_v1, w1_q1, w1_qt1, w1_thv1, w1_thli1, &
        up_z, up_rho, &
        sum_up_aqt, sum_up_awq, avg_up_qt, sum_up_aqc, avg_up_qc

  !--- updraft surface condition variables
  real ::       & 
        w_star1, qt_star1, thv_star1, &
        w_sigma, qt_sigma, thv_sigma, &
        w1_thv1_surf0, w1_qt1_surf0,  &
        wmin, wmax, wlower, wupper

  logical, dimension(up_num, size(tt,1),size(tt,2)) :: &             ! dimension (up_num, nlon,nlat)
        is_moist_updraft

  real, dimension(size(tt,1),size(tt,2)) :: &     ! dimension (nlon,nlat)
        w1_thv1_surf,                       &     ! surface heat flux, w'theta_v' (K m/s)
        w1_th1_surf,                        &     ! surface heat flux, w'theta'   (K m/s)
        w1_th1_surf_in_tend,                &     ! surface heat flux used in tendency calculation  (K m/s)
        w1_qt1_surf_in_tend,                &     ! surface moisture flux used in tendency calculation  (kg/m2/s)
        w1_qt1_surf,                        &     ! surface moisture flux, w'qt'  (kg/kg m/s)
        shflx_star,                         &     ! sensible heat flux retrieved from star values (W/m2)
        evap_star,                          &     ! evaporation   flux retrieved from star values (kg/m2/s)
        tend_ratio,                         &     ! ratio by which tracer MF tendencies need to 
                                                  !   be reduced to permit realizability (i.e., to prevent
                                                  !   negative tracer mixing ratios) 
        is_moist_massflux                         ! 0: dry mass flux (no condensed cloud water)
                                                  ! 1: moist mass flux with condensed cloud water

  !      The vertical indexing of up_* is NOT as the same as the input variables and sum_up_*.
  !      The indexing of up_* is counted from the surface, i.e. k=1 is the lowermost model level, 
  !      while the indexing of input variables (ex: uu,vv) is counted from the top, i.e. k=1 is the uppermost level 
   
  real, dimension(up_num,size(tt,3)+1) ::  &  ! dimension (up_num, nlay+1)
        up_u, up_v, up_w, up_w2,           &  ! updraft zonal, meridional, vertical velocity (m/s), and vertical kinetic energy (m^2/s^2)
        up_a, up_thv, up_thli,             &  ! updraft fractional area (0-1, unitless) and virtual potential temperature (K)
        up_qt, up_qq,                      &  ! updraft total specific humidity, i.e. water vapor + condensended water (kg/kg)
        up_qc, up_ql, up_qi                   ! updraft cloud water(qc), cloud liquid(ql), and cloud ice(qi) specific humidity (kg/kg)  

  real, dimension(up_num,size(tt,3)) ::    &  ! dimension (up_num, nlay)
        ent                                   ! updraft entrainment rate (1/m)

  real, dimension(size(tt,1),size(tt,2),size(tt,3)) :: &  ! dimension (nlon,nlat,nlay)
        ent_mean, ent_min, ent_max

  real ::  &
        qt_src, thli_src,                  &  ! source terms for qt and thv
        ent_bw, ent_bw_EXP, entExp, buoy           
 
  integer ent_stoch                           ! stochastic factor for entrainment

  !integer, dimension(up_num,size(tt,3)) ::    &  ! dimension (up_num, nlay)
  !      ent_stoch_2d

  real, dimension(size(tt,3),up_num) ::    &  ! dimension (nlay, up_num)
     ENTf
  integer, dimension(size(tt,3),up_num) ::    &  ! dimension (nlay, up_num)
     ENTi

  integer, dimension(2) :: seedmf

  real :: water_frac ! liquid water fraction in updraft condensed water (0-1)

  !--- parameters
  real, parameter :: &
      p00 = 1000.0E2,      & ! 1000 hPa
      p00inv = 1./p00,     & ! 1/1000hPa 
      g = grav               ! gravity acceleration, 9.8 m/s^2

  character*20 :: varname

  !--- index variables & dimension
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
  logical used

  !--- variables for check
  character*100 :: data_source
  real, dimension(size(tt,3)+1) ::    &  ! dimension (nlay+1)
        phi_half
  logical do_printout_ncl
  logical do_check_consrv
  character*30, dimension(10) :: do_check_printouts
  real tt1,tt2,tt3
  integer ii1,ii2,ii3

  type(randomNumberStream), dimension(size(tt,1),size(tt,2)) :: &     ! dimension (nlon,nlat)
    streams
  real :: randomNumbers

!--------------------------------------------

!--- set dimensions
  ix  = size( tt, 1 )
  jx  = size( tt, 2 )
  kx  = size( tt, 3 )
  nx  = up_num
  kxp = kx + 1
  kxm = kx - 1
  ism = is - 1
  jsm = js - 1

!--- compute potential temperature, th
!            virtual potential temperature, thv
!            ice-liquid water potential temperature, thli
  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)  ! ape = (P/P0)^(-Rd/cp)
  th(:,:,:)=tt(:,:,:)*ape(:,:,:)  

  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

  thli(:,:,:)=th(:,:,:)   ! no cloud liquid/ice water from input, so thli equals to th
  !full expression of thli, thli(:,:,:)=th(:,:,:) - (hlv*qc(:,:,:)+hlf*qi(:,:,:)) /cp_air * ape(:,:,:)

!--- set total water mixing ratio  
  qt(:,:,:) = qq(:,:,:)  

!  !flag111 - set specific humidity at the lowest level
!  if (rh_flag111.gt.0.) then
!    if (rh_flag111_layer.eq."lowest_atm") then
!      call compute_qs(tt(1,1,kx), p_full(1,1,kx), tt1)
!      qt(1,1,kx) = tt1 * rh_flag111
!    else if (rh_flag111_layer.eq."column") then
!      do k=1,kx
!        call compute_qs(tt(1,1,k), p_full(1,1,k), tt1)
!        qt(1,1,k) = tt1 * rh_flag111
!      enddo
!    end if
!  end if
!  tv (:,:,:)=tt(:,:,:)*(qt(:,:,:)*d608+1.0)  ! because qq is changed, recompute thv
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

!--- compute air density at full and half levels
  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)

  do i=1,ix
  do j=1,jx
  do k=1,kx-1
    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
  enddo
  enddo
  enddo
  rho_half(:,:,1)    = rho_full(:,:,1)  
  !rho_half(:,:,kx+1) = 0.               ! no air at the surface level
  rho_half(:,:,kxp) = p_half(:,:,kxp)/(rdgas*tv(:,:,kx))  ! though rho_half(kx+1) should not be used,
                                                            ! set to a value to prevent something divided by rho_half

!--- set the z coordinate and conrresponding air density for 
!      for updraft levels
  if (option_updraft_level.eq."full") then
    up_z  (:,:,1:kx) = z_full(:,:,1:kx)
    up_z  (:,:,kxp ) = z_half(:,:,kxp)

    up_rho(:,:,1:kx) = rho_full(:,:,1:kx)
    up_rho(:,:,kxp ) = rho_half(:,:,kxp)

  else
    up_z  (:,:,:) = z_half(:,:,:)
    up_rho(:,:,:) = rho_half(:,:,:)
  end if

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho

!--- initialize return variables
  is_mass_flux      = 0. 
  is_moist_massflux = 0.

  sum_up_a        = 0.
  sum_up_aw       = 0.
  sum_up_awu      = 0.
  sum_up_awv      = 0.
  sum_up_awthv    = 0.
  sum_up_awthli   = 0.
  sum_up_awq      = 0.
  sum_up_awqt     = 0.
  sum_up_massflux = 0.

  avg_up_w        = 0.
  avg_up_qt       = 0.
  sum_up_aqt      = 0.
  avg_up_qc       = 0.
  sum_up_aqc      = 0.

  udt_mf          = 0.
  vdt_mf          = 0.
  tdt_mf          = 0.
  qdt_mf          = 0.
  thvdt_mf        = 0.
  thlidt_mf       = 0.
  qtdt_mf         = 0.

  !--- initialize work variables
  each_up_a        = 0.
  each_up_aw       = 0.
  each_up_awu      = 0.
  each_up_awv      = 0.
  each_up_awthv    = 0.
  each_up_awqt     = 0.
  each_up_massflux = 0.

  each_up_w        = 0.
  each_up_u        = 0.
  each_up_v        = 0.
  each_up_thv      = 0.
  each_up_qt       = 0.

  is_moist_updraft = .false.

!=====================================
!
!   compute the updraft mass flux
!
!=====================================

!-------------------------------------
! loop for each (i,j) point
do i=1,ix
do j=1,jx

! If the buoyancy flux (b_star*u_star) is positive,
!   there are updrafts. Otherwise, there is no any updraft.
if (b_star(i,j) .gt. 0.) then   ! use b_star here because u_star is always positive
!-------------------------------------

      !--- initialize working variables
      uu_rev    = 0.
      vv_rev    = 0.
      qt_rev    = 0.
      thv_rev   = 0.
      dz_rev    = 0.
      pfull_rev = 0.
      up_u      = 0.
      up_v      = 0.
      up_w      = 0.
      up_w2     = 0.
      up_a      = 0.
      up_thv    = 0.
      up_thli   = 0.
      up_qq     = 0.
      up_qc     = 0.
      up_qt     = 0.
      ent       = 0.

      !--- reverse grid-mean variables so that the vertical index counting from the surface
      !      upward, i.e. k=1 is the lowermost model level
      do k=1,kx
        kk=kx-k+1
        uu_rev   (kk) = uu  (i,j,k)
        vv_rev   (kk) = vv  (i,j,k)
        qt_rev   (kk) = qt  (i,j,k)
        thv_rev  (kk) = thv (i,j,k)
        thli_rev (kk) = thli(i,j,k)
        pfull_rev(kk) = p_full(i,j,k)
        dz_rev   (kk) = up_z(i,j,k) - up_z(i,j,k+1)
      enddo 

!------------------------------------------
!   compute the mass flux of each updraft
!------------------------------------------

      !------ set entrainment coefficients for each updraft ------
      !         ref: Eq (14), Suselj et al. (2019b)  

      !--- use stochastic entrainment rate
      if (do_stoch_entrain) then

        !--- use subroutine random_Poisson
        if (option_stoch_entrain.eq."random_Poisson") then
          do n=1,nx
            do k=1,kx
              !**************************************************
              !*** the subroutine random_Poisson is taken from Kay's EDMF package in WRF
              !*** the original random_Poisson caused AMIP run stall at the first time step.
              !*** Strangely, the mass_flux ran successfully, but the flux_down_from_atmos stalled.
              !*** More strangely, the 8-day and 30-day regression tests ran successfully
              !**************************************************
              call random_Poisson(dz_rev(k)/ent_length, .true., ent_stoch)  
              !ent_stoch = 1.
              ent(n,k)  = (ent0 / dz_rev(k)) * real(ent_stoch)
              !print*,'n,k,ent_stoch,ent',n,k,ent_stoch,ent(n,k)
            end do 
          end do

        !--- use subroutine Poisson
        elseif (option_stoch_entrain.eq."Poisson") then
            !------ set entrainment coefficients for each updraft ------
            !         ref: Eq (14), Suselj et al. (2019b)  
            !         The random number generator that Kay Suselj used in the GEOS model.
            do n=1,nx
              do k=1,kx
                ENTf(k,n) = dz_rev(k)/ent_length
              end do 
            end do
    
            seedmf(1) = 1000000 * ( 100*thli(i,j,kx)   - INT(100*thli(i,j,kx)  )) 
            seedmf(2) = 1000000 * ( 100*thli(i,j,kx-1) - INT(100*thli(i,j,kx-1)))
            call Poisson(1,nx,1,kx, ENTf, ENTi, seedmf)
    
            do n=1,nx
              do k=1,kx
                ent(n,k)  = (ent0 / dz_rev(k)) * real(ENTi(k,n))
         !print*,'n,k,ENTi,ent,ent0/dz',n,k,ENTi(k,n),ent(n,k),ent0 / dz_rev(k)
              end do 
            end do

        !--- use mean of the Poisson distribution
        elseif (option_stoch_entrain.eq."Poisson_mean") then
            do n=1,nx
              do k=1,kx
                ENTf(k,n) = dz_rev(k)/ent_length
                ENTi(k,n) = int(ENTf(k,n))
              end do 
            end do
    
            do n=1,nx
              do k=1,kx
                ent(n,k)  = (ent0 / dz_rev(k)) * real(ENTi(k,n))
             !print*,'n,k,ENTi,ent,ent0/dz',n,k,ENTi(k,n),ent(n,k),ent0 / dz_rev(k)
              end do 
            end do

        !--- unsupported option_stoch_entrain
        else
      
          call error_mesg(' mass_flux_mod',  &
                          ' unsupported option_stoch_entrain', &
                          FATAL )

        !--- end if of option_stoch_entrain
        endif

      !--- fixed entrainment rate for every updraft
      else
        ent(1:nx,1:kx) = ent_fixed

      endif  ! end if of do_stoch_entrain

!-------------------------
! save entrainment rates
!-------------------------
  do k=1,kx
    kk=kx-k+1
    ent_min (i,j,kk) = 1000. * minval(ent(:,k))              ! change unit from 1/m to 1/km
    ent_max (i,j,kk) = 1000. * maxval(ent(:,k))              ! change unit from 1/m to 1/km
    ent_mean(i,j,kk) = 1000. * sum(ent(:,k)) / real(up_num)  ! change unit from 1/m to 1/km
  enddo

!--- print out entrainment rates
if (do_writeout_profile) then
  do k=1,kx
    kk=kx-k+1
    write(6,*),'-----------'
    write(6,*),'k=',k
    write(6,*),'ent0 / dz_rev(k), ',ent0 / dz_rev(k)
    write(6,*),'option_stoch_entrain, ',option_stoch_entrain
    write(6,*),'dz_rev(k)/ent_length', dz_rev(k)/ent_length
    write(6,*),'ENTi, ',ENTi(k,:)
    write(6,*),''
    write(6,*),'ent(:,k)',ent(:,k)
    write(6,*),'ent_min(:,k)' ,ent_min(i,j,kk)
    write(6,*),'ent_max(:,k)' ,ent_max(i,j,kk)
    write(6,*),'ent_mean(:,k)',ent_mean(i,j,kk)
  enddo
endif
!  call get_random_number_streams ( is, js, Time_next, tt(:,:,1), streams)
!write(6,*) 'qqq, streams',streams
!  call getRandomNumbers (streams(1,1),randomNumbers)
!write(6,*) 'qqq, randomNumbers',randomNumbers

!--------------------------------------
! set initial conditions for updrafts
!      Ref: Suselj et al. (2019a, JAS), Appendix A
!
! Although the vertical index of the updraft base is 1, which is at the surface, 
! this does not mean the updrafts start right at the surface.
! Conceptually, the updrafts start a bit above the surface, say, delta_z above the surface.
! Assuming delta_z is small, the distance between delta_z to the lowest half level is 
! approximately the distance between the surface to the lowest half level.
! That is why the vertical index of updraft base is set to 1.
!--------------------------------------

      !--- get surface buoyancy flux, <w'thv'>, and moisture flux <w'qt1>, < > means average.
      !      buoyancy flux = (g/thv) * (w'thv' + 0.61*theta*(w'q'))  .... Eq (4.4.5d) in Stull 1988
      w1_thv1_surf (i,j) = u_star(i,j) * b_star(i,j) * thv(i,j,kx)/g  &
                           - d608*th(i,j,kx)* u_star(i,j)*q_star(i,j)
      w1_th1_surf  (i,j) = w1_thv1_surf (i,j) / (1+d608*qq(i,j,kx))
      w1_qt1_surf  (i,j) = u_star(i,j) * q_star(i,j)

      shflx_star   (i,j) = w1_thv1_surf (i,j) / (1.+d608*qq(i,j,kx)) * rho_full(i,j,kx) * cp_air
      evap_star    (i,j) = u_star(i,j) * q_star(i,j) * rho_full(i,j,kx)

      w1_thv1_surf0 = w1_thv1_surf (i,j) 
      w1_qt1_surf0  = w1_qt1_surf  (i,j)

      !--- compute scale variables of vertical velocity             (w_star1  , m/s  )
      !                               specific humidity             (qt_start , kg/kg)
      !                               virtual potential temperature (thv_star1, K    )
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_star1   = u_star(i,j)*b_star(i,j)*max(z_pbl_min,z_pbl(i,j))  ! note that u_star*b_star = (g/theta_v) * <w'theta_v'>|surface
                                                                     ! set z_pbl_min in order to avoid w_star1=0 
                                                                     ! that would cause unrealistically large thv at the bottom of the updrafts
      w_star1   = max(w_star_min, w_star1**(1./3.))                  ! get convetive velocity scale, w*
      qt_star1  = w1_qt1_surf0 /w_star1
      thv_star1 = w1_thv1_surf0/w_star1

      !--- compute variances of vertical velocity (w_sigma)
      !                         specific humidity (qt_sigma)
      !                         virtual potential temperature (thv_sigma)
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_sigma    = 1.34 * w_star1    * (z0_over_z_pbl)**(1./3.) * (1.-0.8*z0_over_z_pbl) 
      qt_sigma   = 1.34 * qt_star1   * (z0_over_z_pbl)**(-1./3.)
      thv_sigma  = 1.34 * thv_star1  * (z0_over_z_pbl)**(-1./3.)

      !--- set the upper and lower boundaries of surface vertical velocity for updraft ensemble
      wmin = w_sigma * pwmin
      wmax = w_sigma * pwmax

      !--- The surface vertical velocity is assumed to exhibit a normal distribution, bounding by wmin and wmax.
      !      The range of (wmax-wmin) is discretized into N bins and the mean of each bin is then assigned to each updraft. 
      do n=1,nx
        wlower = wmin + real(n-1)*(wmax-wmin)/real(nx)
        wupper = wmin + real(n)  *(wmax-wmin)/real(nx)
        
        up_u  (n,1) = uu_rev(1)
        up_v  (n,1) = vv_rev(1)
        up_w  (n,1) = min(w_max, 0.5*(wlower+wupper))
        up_w2 (n,1) = up_w(n,1)**2

        up_a   (n,1) = 0.5*erf(wupper/(sqrt(2.)*w_sigma))-0.5*erf(wlower/(sqrt(2.)*w_sigma)) ! ref: Eq (A15), Suselj et al. (2019a)
        up_thv (n,1) = thv_rev(1) + min(thv_excess_max, 0.58*up_w(n,1)*thv_sigma/w_sigma)    ! ref: Eq (A17), Suselj et al. (2019a)
        up_qt  (n,1) = qt_rev (1) + min(qt_excess_max , 0.58*up_w(n,1)*qt_sigma /w_sigma)    ! ref: Eq (A18), Suselj et al. (2019a)
        up_qc  (n,1) = 0.
        up_qq  (n,1) = up_qt(n,1) - up_qc(n,1)
        up_thli(n,1) = up_thv(n,1)/(up_qt(n,1)*d608+1.0)   ! no ice/liquid water so up_thli = up_theta

      enddo ! end loop of n

!-------------------------------------------
! compute the properties of each updraft
!-------------------------------------------

      !--- loop for each updraft
      do n=1,nx
        do k=1,kx

          !--- do microphysics processes (or not) in updrafts, 
          !      such as condensation, precipitation, etc
          if (do_mf_micro) then
            qt_src  = 0.         
            thli_src = 0. 
            !call compute_src_thli_qt        
          else
            qt_src  = 0.         
            thli_src = 0.         
          endif

          !--- set updraft area, updraft area does not change with height
          up_a (n,k+1) = up_a (n,k)

          !--- compute updraft thli,qt,u,v. Ref: Eq (A3), Suselj et al. (2014)
          entEXP = exp(-ent(n,k)*dz_rev(k))

          up_thli(n,k+1) = thli_rev(k)*(1.-entEXP) + up_thli(n,k)*entEXP + thli_src
          up_qt  (n,k+1) = qt_rev  (k)*(1.-entEXP) + up_qt  (n,k)*entEXP + qt_src
          up_u   (n,k+1) = uu_rev  (k)*(1.-entEXP) + up_u   (n,k)*entEXP
          up_v   (n,k+1) = vv_rev  (k)*(1.-entEXP) + up_v   (n,k)*entEXP

!if (n.eq.5) then
!print*,'----------------'
!print*,'updraft n',n
!print*,'----------------'
!  print*,'k,extEXP',k,entEXP
!  print*,'k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)'
!  print*,'  ',k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)
!  print*,'k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)'
!  print*,'  ',k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)
!endif

          !up_thv (n,k+1) = up_thli (n,k+1)  ! this will be replaced when moist processes are in

          !--- obtain updraft thv and qc
          !flag111 - set water_frac=1 at this moment
          water_frac = 1. 
          call compute_thv_qc( up_qt(n,k+1), up_thli(n,k+1), pfull_rev(k+1), water_frac, &
                               up_thv(n,k+1),up_qq(n,k+1), up_qc(n,k+1), up_ql(n,k+1), up_qi(n,k+1))

          !--- compute updraft vertical kinetic energy. Ref: Eq (B12), Suselj et al. (2019b)
          if (option_updraft_level.eq."full") then
            buoy = g * (up_thv(n,k+1)/thv_rev(k) - 1.)
            !print*,'k,up_thv(n,k+1)/thv_rev(k)',k,up_thv(n,k+1),thv_rev(k)
          else
            buoy = g * (0.5*(up_thv(n,k)+up_thv(n,k+1))/thv_rev(k) - 1.)
          end if
          ent_bw = bw*ent(n,k)
          ent_bw_EXP = exp(-2.*ent_bw*dz_rev(k))

          if (ent_bw.eq.0.) then
            up_w2(n,k+1) = up_w2(n,k) + 2.*aw*buoy*dz_rev(k)
          else
            up_w2(n,k+1) = up_w2(n,k)*ent_bw_EXP + aw*buoy/ent_bw * (1.-ent_bw_EXP)
          end if

          !--- compute vertical velocity
          if (up_w2(n,k+1) .gt. 0.) then
            up_w (n,k+1) = min(w_max, sqrt(up_w2(n,k+1)))
          else
            up_w (n,k+1) = 0.
          end if

          !--- if w^2 is less than zero then the updraft terminates
          if (up_w2(n,k+1) .le. 0.) then
            up_thv (n,k+1) = 0.
            up_thli(n,k+1) = 0.
            up_qq  (n,k+1) = 0.
            up_qt  (n,k+1) = 0.
            up_qc  (n,k+1) = 0.
            up_u   (n,k+1) = 0.
            up_v   (n,k+1) = 0.
            up_w2  (n,k+1) = 0.
            up_w   (n,k+1) = 0.
            up_a   (n,k+1) = 0.
            exit
          endif
        enddo  ! end loop of k
      enddo    ! end loop of n

!     !print out values
!     do n=1,nx
!     do k=1,kx
!       !print*,n,k,up_w2(n,k),up_w(n,k)
!       print*,n,k,'w,w2,u,thv',up_w(n,k),up_w2(n,k),up_u(n,k),up_thv(n,k)
!     enddo
!     print*,'------------'
!     enddo

!----------------------------------------------
!  filer moist mass flux if moist convection is handled by other schemes
!----------------------------------------------
     !--- search moist updraft
     do n=1,nx
       if (any(up_qc(n,:) .gt. 0.)) then
         is_moist_updraft(n,i,j) = .true.
       end if
     enddo

     !--- if any moist mass flux is present, mass_flux tendencies will be set to zero,
     !      i.e. no mass flux effects because these effects will be treated in other schemes.
     if (filter_massflux .eq. "if_moist_allmf_off") then
       if (any(up_qc(:,:) .gt. 0.)) then
         up_a(:,:) = 0.
       end if

     !--- if any moist mass flux is present, mass_flux tendencies only include the contribution from dry mass fluxes,
     !      i.e. mass flux program only handle dry mass flux, while moist mass flux are handled by other schemes.
     else if (filter_massflux .eq. "if_moist_allmoist_off") then
       do n=1,nx
         if (any(up_qc(n,:) .gt. 0.)) then
           up_a(n,:) = 0.
         end if
       enddo

     !--- do not set any filter
     else if (filter_massflux .eq. "none") then
       n=1

     !--- do not set any filter
     else
       !n=1
       call error_mesg(' mass_flux_mod',  &
                       ' unsupported filter_massflux value. It must be [if_moist_allmf_off] or [if_moist_allmoist_off] or [none]', &
                       FATAL )

     endif  ! end if of filter_massflux

!------------------------------
! summation of all updrafts
!   note that the vertical indexing is reversed in sum_up_*,
!   in order to be consistent with the CM4 vertical indexing
!------------------------------
      do k=1,kxp
        kk=kxp-k+1
        do n=1,nx
          sum_up_a     (i,j,kk) = sum_up_a     (i,j,kk) + up_a(n,k)
          sum_up_aw    (i,j,kk) = sum_up_aw    (i,j,kk) + up_a(n,k)*up_w(n,k)
          sum_up_awu   (i,j,kk) = sum_up_awu   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_u   (n,k)
          sum_up_awv   (i,j,kk) = sum_up_awv   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_v   (n,k)
          sum_up_awq   (i,j,kk) = sum_up_awq   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qq  (n,k)
          sum_up_awthv (i,j,kk) = sum_up_awthv (i,j,kk) + up_a(n,k)*up_w(n,k)*up_thv (n,k)
          sum_up_awthli(i,j,kk) = sum_up_awthli(i,j,kk) + up_a(n,k)*up_w(n,k)*up_thli(n,k)
          sum_up_awqt  (i,j,kk) = sum_up_awqt  (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qt  (n,k)
          sum_up_aqt   (i,j,kk) = sum_up_aqt   (i,j,kk) + up_a(n,k)          *up_qt(n,k)
          sum_up_aqc   (i,j,kk) = sum_up_aqc   (i,j,kk) + up_a(n,k)          *up_qc(n,k)

          each_up_a       (n,i,j,kk) = up_a   (n,k)
          each_up_w       (n,i,j,kk) = up_w   (n,k)
          each_up_aw      (n,i,j,kk) = up_a   (n,k)*up_w(n,k)
          each_up_u       (n,i,j,kk) = up_u   (n,k)
          each_up_v       (n,i,j,kk) = up_v   (n,k)
          each_up_thv     (n,i,j,kk) = up_thv (n,k)
          each_up_thli    (n,i,j,kk) = up_thli(n,k)
          each_up_qt      (n,i,j,kk) = up_qt  (n,k)
          each_up_qc      (n,i,j,kk) = up_qc  (n,k)
          each_up_massflux(n,i,j,kk) = up_rho (i,j,kk) * up_a(n,k)*up_w(n,k)
          each_up_awu     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_u   (n,k)
          each_up_awv     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_v   (n,k)
          each_up_awthv   (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thv (n,k)
          each_up_awthli  (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thli(n,k)
          each_up_awqt    (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_qt  (n,k)

        enddo  ! end loop of n
      enddo    ! end loop of k

      ! compute averaged vertical velocity of updradts
      do k=1,kxp
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aw (i,j,k) > 0.) then
          avg_up_w    (i,j,k) = sum_up_aw   (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_w    (i,j,k) = 0.
        endif
      enddo  

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqt (i,j,k) > 0.) then
          avg_up_qt    (i,j,k) = sum_up_aqt  (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_qt    (i,j,k) = 0.
        endif
      enddo

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqc (i,j,k) > 0.) then
          avg_up_qc    (i,j,k) = sum_up_aqc  (i,j,k) / sum_up_a (i,j,k)
          is_moist_massflux(i,j)   = 1.
        else
          avg_up_qc    (i,j,k) = 0.
        endif
      enddo

      ! get updraft mass flux, air density * updraft area * vertical velocity
      do k=1,kxp
        sum_up_massflux(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k)
      enddo

      if (any(sum_up_massflux(i,j,:) .gt. 0.)) then
        is_mass_flux(i,j) = 1. 
      else
        is_mass_flux(i,j) = 0.
      end if

!--------------------------------
!  end of updraft compuation
! 
endif  ! end of b_star(i,j)

enddo  ! end of loop j
enddo  ! end of loop i
!--------------------------------
 
  !i=1
  !j=1
!  do n=1,nx
!    print*,'-------------------'
!  do k=25,kx
!    print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
!  enddo
!  enddo
     
!==============================
!
!  compute tendencies for entire (i,j)
!    MF numerics, ED numerics, and surface flux are set in namelist
!
!==============================

        !if (do_use_updated_shflx) then
        if (option_surface_flux.eq."updated") then
          w1_th1_surf_in_tend(:,:) = shflx_updated / rho_full(:,:,kx) / cp_air
          w1_qt1_surf_in_tend(:,:) = qflx_updated  / rho_full(:,:,kx) / cp_air
        else
          w1_th1_surf_in_tend(:,:) = w1_th1_surf(:,:)
          w1_qt1_surf_in_tend(:,:) = w1_qt1_surf(:,:)
        endif

        !--- compute tendency of zonal wind, uu
        varname = "uu" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   uu, sum_up_awu, udt_mf, w1_u1, varname)
  
        !--- compute tendency of meridional wind, vv
        varname = "vv" 
        call mass_flux_tendencies (dt,  is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   vv, sum_up_awv, vdt_mf, w1_v1, varname)
  
        !--- compute tendency of total water mixing ratio, qt 
        varname = "qt" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qt, sum_up_awqt, qtdt_mf, w1_qt1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_qt1_surf_in_tend)
  
        !--- compute tendency of specific humidity, qq
        varname = "qq" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qq, sum_up_awq, qdt_mf, w1_q1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_qt1_surf_in_tend)
  
        !varname = "" 
        !call mass_flux_tendencies (dt, &
        !                           up_z, rho_full, up_rho, sum_up_aw, &
        !                           thv, sum_up_awthv, thvdt_mf, w1_thv1, varname)
  
        !--- compute tendency of ice-liquid water potential temperature, thli
        varname = "thli" 

!print*,'shflx_updated',shflx_updated
!print*,'w1_th1_surf_in_tend',w1_th1_surf_in_tend
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   thli, sum_up_awthli, thlidt_mf, w1_thli1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_th1_surf_in_tend)
  
        !--- compute temperature tendency tdt_mf. Because thli_env = theta_env. Convert tdt from theta_env
        tdt_mf(:,:,:) = thlidt_mf(:,:,:)/ape(:,:,:)


!====================================
!
! Check for tracer realizability. If MF tendencies would
!  produce negative tracer mixing ratios, scale down tracer tendency
!  terms uniformly for this tracer throughout convective column.
!
!====================================

!--- initialze tend_ratio
tend_ratio = 1.

if (do_check_trc_rlzbility) then

  call check_trc_rlzbility (dt, qq, qdt_mf, &
                                tend_ratio)

  !print*,'before tdt_mf',tdt_mf*86400.
  !print*,'tend_ratio',tend_ratio

  do i=1,ix
  do j=1,jx
    if (tend_ratio(i,j) /= 1.) then
      udt_mf   (i,j,:) = udt_mf   (i,j,:) * tend_ratio(i,j)
      vdt_mf   (i,j,:) = vdt_mf   (i,j,:) * tend_ratio(i,j)
      qtdt_mf  (i,j,:) = qtdt_mf  (i,j,:) * tend_ratio(i,j)
      qdt_mf   (i,j,:) = qdt_mf   (i,j,:) * tend_ratio(i,j)
      thlidt_mf(i,j,:) = thlidt_mf(i,j,:) * tend_ratio(i,j)
      tdt_mf   (i,j,:) = tdt_mf   (i,j,:) * tend_ratio(i,j)
    endif
  enddo    ! end loop of j
  enddo    ! end loop of i

  !print*,'after tdt_mf',tdt_mf*86400.
endif ! end if of do_check_trc_rlzbility

!==============================
!
! write out to history files
!
!==============================

!------- zonal wind (units: m/s) at full level -------
  if ( id_uu > 0) then
    used = send_data (id_uu, uu, Time_next, is, js, 1 )
  endif

!------- meridional wind (units: m/s) at full level -------
  if ( id_vv > 0) then
    used = send_data (id_vv, vv, Time_next, is, js, 1 )
  endif

!------- temperature (units: K) at full level -------
  if ( id_tt > 0) then
    used = send_data (id_tt, tt, Time_next, is, js, 1 )
  endif

!------- speficic humidity (units: kg/kg) at full level -------
  if ( id_qq > 0) then
    used = send_data (id_qq, qq, Time_next, is, js, 1 )
  endif

!------- averaged vertical velocity (units: m/s) at half level -------
  if ( id_up_w > 0) then
    used = send_data (id_up_w, avg_up_w, Time_next, is, js, 1 )
  endif

!------- updraft area (units: none) at half level -------
  if ( id_up_a > 0) then
    used = send_data (id_up_a, sum_up_a, Time_next, is, js, 1 )
  endif

!------- updraft area*w (units: m/s) at half level -------
  if ( id_up_aw > 0) then
    used = send_data (id_up_aw, sum_up_aw, Time_next, is, js, 1 )
  endif

!------- updraft area*w*u (units: m2/s2) at half level -------
  if ( id_up_awu > 0) then
    used = send_data (id_up_awu, sum_up_awu, Time_next, is, js, 1 )
  endif

!------- updraft area*w*v (units: m2/s2) at half level -------
  if ( id_up_awv > 0) then
    used = send_data (id_up_awv, sum_up_awv, Time_next, is, js, 1 )
  endif

!------- updraft area*w*theta_v (units: K m/s) at half level -------
  if ( id_up_awthv > 0) then
    used = send_data (id_up_awthv, sum_up_awthv, Time_next, is, js, 1 )
  endif

!------- updraft area*w*qt (units: kg/kg m/s) at half level -------
  if ( id_up_awqt > 0) then
    used = send_data (id_up_awqt, sum_up_awqt, Time_next, is, js, 1 )
  endif

!------- updraft mass flux (units: kg/m2/s) at half level -------
  if ( id_up_massflux > 0) then
    used = send_data (id_up_massflux, sum_up_massflux, Time_next, is, js, 1 )
  endif

!------- u tendency from mass flux (units: m/s2) at full level -------
  if ( id_udt_mf > 0) then
    used = send_data (id_udt_mf, udt_mf, Time_next, is, js, 1 )
  endif

!------- v tendency from mass flux (units: m/s2) at full level -------
  if ( id_vdt_mf > 0) then
    used = send_data (id_vdt_mf, vdt_mf, Time_next, is, js, 1 )
  endif

!------- t tendency from mass flux (units: K/s) at full level -------
  if ( id_tdt_mf > 0) then
    used = send_data (id_tdt_mf, tdt_mf, Time_next, is, js, 1 )
  endif

!------- q tendency from mass flux (units: kg/kg/s) at full level -------
  if ( id_qdt_mf > 0) then
    used = send_data (id_qdt_mf, qdt_mf, Time_next, is, js, 1 )
  endif

!------- thv tendency from mass flux (units: K/s) at full level -------
  if ( id_thvdt_mf > 0) then
    used = send_data (id_thvdt_mf, thvdt_mf, Time_next, is, js, 1 )
  endif

!------- thli tendency from mass flux (units: K/s) at full level -------
  if ( id_thlidt_mf > 0) then
    used = send_data (id_thlidt_mf, thlidt_mf, Time_next, is, js, 1 )
  endif

!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
  if ( id_qtdt_mf > 0) then
    used = send_data (id_qtdt_mf, qtdt_mf, Time_next, is, js, 1 )
  endif

!------- w'thli' from mass flux (units: kg/kg/s) at half level -------
  if ( id_w1_thli1_mf > 0) then
    used = send_data (id_w1_thli1_mf, w1_thli1, Time_next, is, js, 1 )
  endif

!------- updraft averaged in-cloud total water (units: kg/kg) at half level -------
  if ( id_up_qt > 0) then
    used = send_data (id_up_qt, avg_up_qt, Time_next, is, js, 1 )
  endif

!------- updraft averaged in-cloud cloud water (units: kg/kg) at half level -------
  if ( id_up_qc > 0) then
    used = send_data (id_up_qc, avg_up_qc, Time_next, is, js, 1 )
  endif

!------- whether moist mass flux is present --- 
  if ( id_moist_massflux > 0) then
    used = send_data (id_moist_massflux, is_moist_massflux, Time_next, is, js)
  endif

!------- whether moist mass flux is present --- 
  if ( id_is_massflux > 0) then
    used = send_data (id_is_massflux, is_mass_flux, Time_next, is, js)
  endif

!------- MF tendency ratio due to tracer stability --- 
  if ( id_tend_ratio > 0) then
    used = send_data (id_tend_ratio, tend_ratio, Time_next, is, js)
  endif

!------- MF entrainment rate minimum (units: 1/m) at full level -------
  if ( id_ent_min > 0) then
    used = send_data (id_ent_min, ent_min, Time_next, is, js, 1 )
  endif

!------- MF entrainment rate maximum (units: 1/m) at full level -------
  if ( id_ent_max > 0) then
    used = send_data (id_ent_max, ent_max, Time_next, is, js, 1 )
  endif

!------- MF entrainment rate mean (units: 1/m) at full level -------
  if ( id_ent_mean > 0) then
    used = send_data (id_ent_mean, ent_mean, Time_next, is, js, 1 )
  endif

!------------------------------
! write out profiles into the log file, fms.out
!------------------------------
  !--- write out profiles that have issues
  if (do_writeout_profile) then
    !--- loop for all i,j
    do i=1,ix
    do j=1,jx

      !--- write out the profile where tdt_mf > 2000 K/day
      !tt1 = maxval(abs(tdt_mf(i,j,:)))*86400.
      !if (tt1.gt.2000.) then   ! if tdt_mf > 2000 K/day

      tt1 = 0.             ! write out all
      if (tt1.eq.0.) then   

        write(6,*)    '!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
        write(6,*)    '! is,ie,js,je',is,ie,js,je 
        write(6,*)    '! i,j,',i,j
        write(6,*)    '! is_mass_flux',is_mass_flux(i,j)
        write(6,*)    '! is_moist_updraft',is_moist_updraft(:,i,j)
        write(6,*)    '!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
        write(6,*)    '' 
        write(6,*)    '' 
        !write(6,*)    'Time_next,days,seconds'
        !write(6,*)    Time_next%days, Time_next%seconds   ! compiler error when I want to write Time_next
        !write(6,*)    'i,j,',i,j
        write(6,*)    '! tdt_mf,',tdt_mf(i,j,:)*86400.
        write(6,*)    '! sum_up_massflux,',sum_up_massflux(i,j,:)
        write(6,*)    '! w1_thli1', w1_thli1(i,j,:)
        write(6,*)    ''
        write(6,*)    '!================='
        write(6,*)    '! Description'
        write(6,*)    '! A profile taken from GFDL CM4 AMIP run that the mass flux program has trouble'
        write(6,*)    '!'
        write(6,*)    '! Yi-Hsuan Chen'
        write(6,*)    '!================='
        write(6,*)    ''
        write(6,*)    '!==================='
        write(6,*)    '!==================='
        write(6,*)    '!  Input profiles'
        write(6,*)    '!==================='
        write(6,*)    '!==================='
        write(6,*)    ''
        write(6,*)    '! pressure at half level (Pa)'
        write(6,3001) 'data p_half/',p_half(i,j,:)
        write(6,*)    ''
        write(6,*)    '! height at half level above the surface (m)'
        write(6,3001) 'data z_half/',z_half(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! pressure at full level (Pa)'
        write(6,3001) 'data p_full/',p_full(i,j,:)
        write(6,*)    ''
        write(6,*)    '! height at full level above the surface (m)'
        write(6,3001) 'data z_full/',z_full(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! actual height at half level (m)'
        write(6,3001) 'data z_half_actual/',z_half(i,j,:)
        write(6,*)    ''
        write(6,*)    '! actual height at full level (m)'
        write(6,3001) 'data z_full_actual/',z_full(i,j,:)
        write(6,*)    ''
        write(6,*)    '! zonal wind velocity at full levels (m/s)'
        write(6,3001) 'data uu/'    ,uu(i,j,:)
        write(6,*)    ''
        write(6,*)    '! meridional wind velocity at full levels (m/s)'
        write(6,3001) 'data vv/'    ,vv(i,j,:)
        write(6,*)    ''
        write(6,*)    '! temperatur at full levels (K)'
        write(6,3001) 'data tt/'    ,tt(i,j,:)
        write(6,*)    ''
        write(6,*)    '! specific humidity at full levels (kg/kg)'
        write(6,3002) 'data qq/'    ,qq(i,j,:)
        write(6,*)    ''
        write(6,*)    '! potential temperature at full levels (K)'
        write(6,3001) 'data th/'    ,th(i,j,:)
        write(6,*)    ''
        if (present(diff_t)) then
          write(6,*)    ''
          write(6,*)    '! diffusion coefficient of heat (m2/s) at half levels'
          write(6,3004) 'data diff_t/', diff_t(i,j,:),'0,'
        endif
        if (present(diff_m)) then 
          write(6,*)    ''
          write(6,*)    '! diffusion coefficient of momentum (m2/s) at half levels'
          write(6,3004) 'data diff_m/', diff_m(i,j,:),'0,'
        endif
        write(6,*)    ''
        write(6,*)    '! PBL depth (m)'
        write(6,3000) 'data z_pbl/' ,z_pbl(i,j)
        write(6,*)    ''
        write(6,*)    '! buoyancy flux (m2/s3)'
        write(6,3003) 'data buoy_flux/',u_star(i,j)*b_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface heat flux, w1_thv1 (K m/s)'
        write(6,3003) 'data w1_thv1_surf/',w1_thv1_surf(i,j)  !u_star(i,j) * b_star(i,j) * thv(i,j,kx)/g
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux (K m/s)'
        write(6,3003) 'data w1_th1_surf/',w1_th1_surf(i,j)  
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux used in tend calculation (K m/s)'
        write(6,3003) 'data w1_th1_surf_in_tend/',w1_th1_surf_in_tend(i,j)  
        write(6,*)    ''
        write(6,*)    '! surface moisture flux (kg/kg m/s'
        write(6,3003) 'data w1_qt1_surf/',w1_qt1_surf(i,j) !u_star(i,j) * q_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux diagnosed from star values (W/m2)'
        write(6,3003) 'data shflx_star/',shflx_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface evaporation flux diagnosed from star values (kg/m2/s)'
        write(6,3003) 'data evap_star/',evap_star(i,j)
        write(6,*)    ''
        write(6,3000) 'data u_star/',u_star(i,j)
        write(6,3003) 'data b_star/',b_star(i,j)
        write(6,3003) 'data q_star/',q_star(i,j)
        write(6,*)    ''
        write(6,*)    '!======================================='
        write(6,*)    '!======================================='
        write(6,*)    '!  Output from the mass flux program'
        write(6,*)    '!======================================='
        write(6,*)    '!======================================='
        write(6,*)    ''
        write(6,*)    '! ------------------------------------'
        !write(6,*)    '! option_solver  : ',option_solver
       ! write(6,*)    '!  do_IMPtend_MF : ',do_IMPtend_MF
       ! write(6,*)    '!  do_IMPtend_ED : ',do_IMPtend_ED
       ! write(6,*)    '!  do_IMPtend_include_surf_flux: ',do_IMPtend_include_surf_flux
        !write(6,*)    '! do_MF_explicit        : ',do_MF_explicit
        !write(6,*)    '! do_MF_implicit        : ',do_MF_implicit
        !write(6,*)    '! do_ED_explicit        : ',do_ED_explicit
        !write(6,*)    '! do_ED_implicit        : ',do_ED_implicit
        write(6,*)    '! option_MF_numerics    : ',option_MF_numerics
        write(6,*)    '! option_ED_numerics    : ',option_ED_numerics
        write(6,*)    '! do_include_surf_flux  : ',do_include_surf_flux
        write(6,*)    '! option_surface_flux   : ',option_surface_flux
        !write(6,*)    '! do_use_updated_shflx  : ',do_use_updated_shflx
        write(6,*)    '! option_MF_env_half    : ',option_MF_env_half
        write(6,*)    '! do_check_trc_rlzbility: ',do_check_trc_rlzbility
        write(6,*)    '!   tend_ratio          : ',tend_ratio(i,j) 
        write(6,*)    '! dt                    : ',dt
        write(6,*)    '! ------------------------------------'
        write(6,*)    ''
        write(6,*)    '! height level of updraft (m)'
        write(6,3001) 'data up_z/',up_z(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! sum of updraft mass flux (kg/m2/s) at half level'
        write(6,3002) 'data sum_up_massflux /'    ,sum_up_massflux(i,j,:)
        write(6,*)    ''
        write(6,*)    '! averaged updraft velocity (m/s) at half levels'
        write(6,3001) 'data avg_up_w /'    ,avg_up_w(i,j,:)
        write(6,*)    ''
        write(6,*)    '! heat flux w1_theta_li1 (K m/s) at half level'
        write(6,3002) 'data w1_thli1 /'    ,w1_thli1(i,j,:)
        write(6,*)    ''
        write(6,*)    '! ice-liquid potential temperature tendency (K/day) at full level'
        write(6,3001) 'data thlidt_mf /'    ,thlidt_mf(i,j,:)*86400.
        write(6,*)    ''
        write(6,*)    '! temperature tendency (K/day) at full level'
        write(6,3001) 'data tdt_mf /'    ,tdt_mf(i,j,:)*86400.
        write(6,*)    ''
        write(6,*)    '! specific humidity tendency (kg/kg/s) at full level'
        write(6,3002) 'data qdt_mf /'    ,qdt_mf(i,j,:)
        write(6,*)    ''
        write(6,*)    '! averaged updraft specific humidity (kg/kg) at half level'
        write(6,3002) 'data avg_up_qt /'    ,avg_up_qt(i,j,:)
        write(6,*)    ''
        write(6,*)    '! ratio from check_tracer_realizability'
        write(6,3003) 'data tend_ratio /',tend_ratio(i,j)

        write(6,*)    ''
        write(6,*)    '!-----------------------------'
        write(6,*)    '!  Some vi commands'
        write(6,*)    '!-----------------------------'
        write(6,*)    ''
        write(6,*)    '!*** Fortran'
        write(6,*)    '! remove the space at the beginning       : [1,$s/^ */  /g]'
        write(6,*)    '! replace ",$" to "/" at the end          : [1,$s/,$/\//g]'
        write(6,*)    ''
        write(6,*)    '!*** NCL '
        write(6,*)    '! remove the space at the beginning       : [1,$s/^ */  /g]'
        write(6,*)    '! remove data                             : [1,$s/data //g]'
        write(6,*)    '! replace "/" to "=(/"                    : [1,$s/\/  / = (\//g]'
        write(6,*)    '! replace "," to "/" at the end           : [1,$s/,$/\/)/g]'
        write(6,*)    '! replace "!" to ";"                      : [1,$s/!/;/g]'
        write(6,*)    ''

      endif  ! end if of tt1
    enddo
    enddo

    if (do_stop_run) then
      call error_mesg(' mass_flux_mod',' end do_writeout_profile: stop', FATAL )
    end if
  end if  ! end if of do_writeout_profile

!**********************************************************
!**********************************************************
!****   check part   **************************************
!**********************************************************
!**********************************************************

  if ( do_printouts ) then

      !  write out to the log file, fms.out
       write(6,*) 'Tend_mf tendencies'
       write(6,*) ''
      !i=is
      !j=js
      i=11
      j=5
      write(6,*) 'i,j,tt',tt(i,j,:)
      write(6,*) 'i,j,qq',qq(i,j,:)

       write(6,*) '------------------------------------'
       write(6,*) 'i,j,u*,b*,q*,z_pbl',i,j,u_star(i,j),b_star(i,j),q_star(i,j),z_pbl(i,j)
       write(6,*) 'i,j,u*',i,j,u_star(i,j)
       write(6,*) 'i,j,b*',i,j,b_star(i,j)
       write(6,*) 'i,j,q*',i,j,q_star(i,j)
       write(6,*) 'i,j,z_pbl',i,j,z_pbl(i,j)
       write(6,*) '------------------------------------'
      do kk=1,kxp
         write(6,*) 'kk,z',kk,z_half(i,j,kk)
         write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
         write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,kk)
         write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,kk)
         write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,kk)
         write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,kk)
         write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,kk)
         write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

      do kk=1,kx
         write(6,*) 'kk,z',kk,z_full(i,j,kk)
         write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,kk)
         write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,kk)
         write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,kk)
         write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,kk)
         write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,kk)
         write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,kk)
         write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

    !call error_mesg(' mass_flux_mod',' end do_mass_flux: stop', FATAL )

  endif  ! end if of do_printouts

!------------------
! printout 
!------------------
do_check_printouts = ""
!do_check_printouts(1) = "up_qt_qc"
!do_check_printouts(2) = "qtdt_mf"
!do_check_printouts(1) = "sum_up"
!do_check_printouts(6) = "each_up"
!do_check_printouts(2) = "sum_up"
!do_check_printouts(3) = "dt_mf"
!do_check_printouts(4) = "w1_phi1"
!do_check_printouts(5) = "is_mass_flux"
!do_check_printouts = ""

kk=22  ! smallest k index
i=is  ! i index
j=js  ! j index

do ii1=1,10
  !-----------
  if (do_check_printouts(ii1).eq."is_mass_flux") then
    print*,''
    print*,'================================'
    print*,'is_mass_flux',is_mass_flux(i,j)
    print*,'is_moist_updraft',is_moist_updraft(:,i,j)
  endif

  !-----------
  if (do_check_printouts(ii1).eq."up_qt_qc") then
    print*,''
    print*,'================================'
    ! print out qt,qc
    do n=1,nx
      print*,'----- updraft ',n,' -----'
      do k=kk,kx
        print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
      enddo
    enddo
  
    !print*,'**********************'
    !print*,'base RH',rh_flag111
    !print*,'is_moist_massflux',is_moist_massflux
    !print*,'avg_up_qc',avg_up_qc
  endif 

  !-----------
  if (do_check_printouts(ii1).eq."qtdt_mf") then
    print*,''
    print*,'================================'
    print*,'qtdt_mf',qtdt_mf
  endif

  !-----------
  if (do_check_printouts(ii1).eq."sum_up") then
    print*,''
    print*,'================================'
    do k=kk,kxp
       write(6,*) 'k,z',k,z_half(i,j,k)
       write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
       write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,k)
       write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,k)
       write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,k)
       write(6,*) '   sum_up_awq,      ', sum_up_awq  (i,j,k)
       write(6,*) '   sum_up_awqt,     ', sum_up_awqt (i,j,k)
       write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,k)
       write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,k)
       write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,k)
       write(6,*) '   w1_thli1,        ', w1_thli1(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."dt_mf") then
    print*,''
    print*,'================================'
    do k=kk,kx
       write(6,*) 'k,z',k,z_full(i,j,k)
       write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,k)
       write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,k)
       write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,k)
      ! write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,k)
       write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,k)
       write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,k)
       write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."each_up") then
    print*,''
    print*,'================================'
    do n=1,nx
      print*,''
      !print*,'----- updraft ',n,' -----'
      print*,'***************************'
      print*,'*****   updraft ',n,' *****'
      print*,'***************************'
      !do k=1,kxp
      do k=kk,kxp
         write(6,*) 'n,k,z',n,k,z_half(i,j,k)
         write(6,*) '   ent              ', ent(n,k)
         write(6,*) '   each_up_thli     ', each_up_thli(n,i,j,k)
         write(6,*) '   each_up_qt       ', each_up_qt  (n,i,j,k)
         write(6,*) '   each_up_qc       ', each_up_qc  (n,i,j,k)
         write(6,*) '------------------------------------'
      enddo
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."w1_phi1") then
    print*,''
    print*,'================================'
      do k=kk,kxp
         write(6,*) 'k,z',k,z_half(i,j,k)
         write(6,*) '   w1_qt1           ', w1_qt1  (i,j,k)
         write(6,*) '   w1_q1            ', w1_q1  (i,j,k)
         write(6,*) '   w1_thli1            ', w1_thli1  (i,j,k)
         write(6,*) '------------------------------------'
      enddo
  endif
enddo  ! end do of ii1


!print*,'filter_massflux,',filter_massflux
!print*,'is_moist_updraft',is_moist_updraft
!print*,'is_moist_massflux',is_moist_massflux

!    print*,''
!    print*,'**********************'
!    print*,'base RH',rh_flag111
!    print*,'is_moist_massflux',is_moist_massflux
!    print*,'**********************'
!    print*,''

!------------------
!check mass/energy conservation
!------------------
!do_check_consrv = .true.
do_check_consrv = .false.

if (do_check_consrv) then
  !*** check qt ***
  tt1 = 0.
  tt2 = 0.

  i=1
  j=1 
  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + qt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (qtdt_mf(i,j,k)*dt+qt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_qt, new_qt, rho, dz',qt(i,j,k),(qtdt_mf(i,j,k)*dt+qt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  qtdt_mf',qtdt_mf(i,j,k)
  enddo

  print*,''
  !print*,'option_solver: ',option_solver
  print*,'old qt (kg/m2), ',tt1
  print*,'new qt (kg/m2), ',tt2
  print*,'-----------------------------------------'

!*** check dry static energy ***
  tt1 = 0.
  tt2 = 0.

  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_tt, new_tt, rho, dz',tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  tdt_mf',tdt_mf(i,j,k)
  enddo

  print*,''
  !print*,'option_solver: ',option_solver
  print*,'column old energy, integral(rho*T*dz), ',tt1,', (times Cp to convert to J)'
  print*,'column new energy, integral(rho*T*dz), ',tt2,', (times Cp to convert to J)'
end if ! end if of do_check_consrv

!-----------------------------------------------------------
!  write out values of each updraft for NCL plotting use
!-----------------------------------------------------------

do_printout_ncl = .false.
!do_printout_ncl = .true.

if (do_printout_ncl) then
  print*,''
  print*,';---------------------------'
  print*,'; data source: '
  print*,';   ',data_source
  print*,';   dt=',dt
  print*,''
  print*,';    remove the space at the beginning	: [1,$s/^ */  /g]'
  print*,';    add "/)" at the end              	: [1,$s/$/\/)/g]'
  print*,';    add comma            		: [1,$s/   /,  /g]'
  print*,';    replace (/, with (/  		: [1,$s/\/,/\//g]'
  print*,';    replace ", ," to "," 		: [1,$s/, *,/,/g]'
  print*,';    replan then/) to then		: [1,$s/then\/)/then/g]'
  print*,';    replan end if/) to end if	: [1,$s/end if\/)/end if/g]'
  print*,';---------------------------'
  print*,''
  print*,';  wks_name = ""'
  print*,';  data_source = ""'
  print*,''
  
  write(*,2001) 'p_half = (/',p_half/100.
  write(*,2001) 'z_half = (/',z_half
  write(*,2001) 'p_full = (/',p_full/100.
  write(*,2001) 'z_full = (/',z_full
  write(*,1001) 'tt = (/',tt
  write(*,1001) 'thli = (/',thli
  write(*,1001) 'uu = (/',uu
  write(*,1001) 'vv = (/',vv
  write(*,1000) 'qq = (/',qq
  
  i=1
  j=1
  phi_half(1) = thli(i,j,1)
  do k=2,kx
    phi_half(k) = 0.5* (thli(i,j,k) + thli(i,j,k-1))
  enddo
  !write(*,1001) 'thli_env_half = (/',phi_half
  
!  do n=1,nx
!    write(*,1002) 'each_up_thv (',n-1,',:) = (/',each_up_thv(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1002) 'each_up_w (',n-1,',:) = (/',each_up_w(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_a (',n-1,',:) = (/',each_up_a(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_massflux (',n-1,',:) = (/',each_up_massflux(n,i,j,:)
!  enddo
  
  !write(*,1000) 'sum_up_aw = (/',sum_up_aw
  !write(*,1000) 'sum_up_awthv = (/',sum_up_awthv
  write(*,1001) 'avg_up_w = (/',avg_up_w
  write(*,1000) 'sum_up_massflux = (/',sum_up_massflux
  write(*,1000) 'w1_thli1 = (/',w1_thli1
  write(*,1000) 'tdt_mf = (/',tdt_mf*86400.  ! K/day
end if ! end if of do_printout_ncl
!
!*** check sum and each updraft ***
!  i=1
!  j=1
!  do k=1,kxp
!    !print*,'k=',k,', sum_up_a,',sum_up_a(i,j,k),', each_up_a,',each_up_a(:,i,j,k)
!    !print*,'k=',k,', avg_up_w,',avg_up_w(i,j,k),', each_up_w,',each_up_w(:,i,j,k)
!    !print*,'k=',k,', sum_up_massflux,',sum_up_massflux(i,j,k),', each_up_massflux,',each_up_massflux(:,i,j,k)
!    print*,'k=',k,', sum_up_awthv,',sum_up_awthv(i,j,k),', each_up_awthv,',each_up_awthv(:,i,j,k)
!  enddo
!
1000 format (A25,40(E12.4,2X))
1001 format (A25,40(F8.3,2X))
1002 format (A25,I2,A10,40(F8.3,2X))
1003 format (A25,I2,A10,40(E12.4,2X))
2001 format (A25,40(F12.3,2X))
3000 format (A25,2X,F8.2,',')
3001 format (A25,2X,34(F10.3,2X,','))
3002 format (A25,2X,34(E12.4,2X,','))
3003 format (A25,2X,E12.4,',')
3004 format (A25,2X,33(F10.3,2X,','),A5)

end subroutine mass_flux

!#######################################################################
! subroutine mass_flux_tendencies
!
!*************
! Purpose:
!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, <w'phi'>.
!
!*************
! Numerical discretation:
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
!*************
! Equation:
!
!   The tendency equation is Eq (1) in Suselj et al. (2019b)
!
!         mean_phi(t+dt,k) - mean_phi(t,k)       w'phi'(t+dt/t,k+1) - w'phi'(t+dt/t,k)
!      -------------------------------------- = ---------------------------------------
!                      dt                                  dz
!
!   The treatment of <w'phi'> is Eq (7) in Suselj et al. (2019b)
!
!       mean_phi = uu, vv, tt, or qt
!       mean_w   = 0.
!
!       w'phi'(t/t+dt,k) = sum [ up_area * (up_phi-mean_phi) * (up_w-0) ]
!                        = sum [ up_area(t,k) * ( up_phi(t,k) - 0.5(mean_phi(t+dt/t,k-1)+mean_phi(t+dt/t,k) ) * up_w(t,k) ]
!
!*************
! Solver for time-difference scheme:
!
!   The updraft properties are treated explicitly, i.e. evaluated at time=t.
!   The grid-scale phi can be treated explicitly or implicitly (evaluated at time=t+dt). If done implicitly, it can be called
!   semi-implicit scheme, 
!      "In this solver, the large-scale horizontal advection and source terms are
!      treated explicitly (i.e., they are taken at the time, t), whereas the
!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!      subgrid fluxes are treated semi-implicitly." (Appendix A, Suselj et al., 2019b)
!
!   There are two solver options in this subroutine: "explicit" and "implicit". 
!     "Explicit" option evaluates all terms on the right-hand side of Eq (1) at time t, which are known. The only unknown term is
!     mean_phi(t+dt,k), which can be then solved directly.
!
!     "Implicit" evaluates all terms on the right-hand side of Eq (1) at time t except the mean_phi terms, which are evaluated at
!     t+dt. As a result, a set of linear euqations of unknown variables, mean_phi(t+dt,k), will show up. 
!     These equations are solved by the Tridiagonal matrix algorithm. Wiki has a detailed explanation about this algorithm: 
!     https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm 
!
!      --- Tridiagonal matrix algorithm ---
!      a,b,c - are coefficients on the LHS
!      d     - is initially RHS on the output becomes a solution vector
!
!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!      [ a1,  0, an, bn   ]   [xn]    [dn]
!
!      a1=0 and cn=0
!
!*************
! History:
!   2020/06/21 Copy from the subroutine OUTDATED_massflux_tendencies and modify
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
!*************
! References:
!   Suselj et al. (2014, WAF):
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS):
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1
!
!-------------------------------------------------------------------- 

subroutine mass_flux_tendencies (dt, is_mass_flux, &
                                 z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                 phi, sum_up_awphi, phidt_return, w1_phi1, varname, &
                                 diff_phi, w1_phi1_surf)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    option_solver -  solver to obtain the tendency. 'explicit' or 'implicit' only
!    varname       -  variable name for reference 
!    dt            -  Time step               (sec)
!    is_mass_flux  -  whether compute MF tendencies  (0: no, 1: yes) , dimension (nlon, nlat) 
!    z_half        -  Height at half levels   (meter)                , dimension (nlon, nlat, nlay+1)
!    z_full        -  Height at full levels   (meter)                , dimension (nlon, nlat, nlay)
!    rho_half      -  Air density at half levels (kg/m3)             , dimension (nlon, nlat, nlay+1)
!    rho_full      -  Air density at full levels   (kg/m3)           , dimension (nlon, nlat, nlay)
!    up_z          -  Updraft height levels   (meter)                , dimension (nlon, nlat, nlay+1)
!    up_rho        -  Air density at updraft levels (kg/m3)          , dimension (nlon, nlat, nlay+1)
!    sum_up_aw     - sum of the product of fractional area and vertical velocity for individual updraft
!                      i.e. a*w   (unit: m/s),                       , dimension (nlon, nlat, nlay+1)
!    phi           - a grid-mean variable (units_phi), e.g. u,v,t,q, , dimension (nlon, nlat, nlay)
!    sum_up_awphi  - sum of the product of fractional area, vertical velocity, and the variable phi for individual updraft
!                      i.e. a*w*phi (unit: m/s * units_phi)          , dimension (nlon, nlat, nlay+1)
!
!    diff_phi      - eddy-diffusion coefficients for phi (m2/s)      , dimension (nlon, nlat, nlay)
!                      note that this should be (nlon, nlat, nlay+1), but CM4 set it to (nlay), 
!                      though it doesn't matter in code and calculation
!    w1_phi1_surf  - surface flux of phi (phi_unit * m/s)            , dimension (nlon, nlat)
!---------------------------------------------------------------------

  character*20, intent(in)            :: varname
  real,  intent(in)                   :: dt

  real,  intent(in), dimension(:,:)   :: &  ! dimension (nlon, nlat)
    is_mass_flux

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
    z_full, rho_full, phi

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay+1)
    z_half, rho_half

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay+1)
    up_z, up_rho, sum_up_aw, sum_up_awphi

  real,  intent(in), optional, dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
    diff_phi

  real,  intent(in), optional, dimension(:,:) :: &  ! dimension (nlon, nlat)
    w1_phi1_surf

!---------------------------------------------------------------------
! Arguments (Intent out)
!
!    phidt_return  -  the tendency term of phi, i.e. dphi/dt,   dimension (nlon, nlat, nlay)
!    w1_phi1   -  the subgrid-scale flux  , i.e. w'phi'_bar
!---------------------------------------------------------------------
  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay)
    phidt_return

  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay+1)
    w1_phi1

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- working variables
  real, dimension(size(z_half,1),size(z_half,2),size(z_half,3)) :: &  ! dimension (nlon, nlat, nlay+1) 
    nu_phi,          &  ! nu term in eddy-diffusivity calculation. Ref: Eq (11) in GFDL vertical diffusion technical note 
    rho_flux_ED         ! air density * eddy flux (units: kg/m3 m/s unit_phi)

  real, dimension(size(up_z,1),size(up_z,2),size(up_z,3)) :: &  ! dimension (nlon, nlat, nlay+1) 
    rho_w1_phi1   ,  &    ! air density (kg/m3) * w'phi'
    rho_flux_MF   ,  &    ! air density * MF flux (units: kg/m3 m/s unit_phi)
    sum_up_raw    ,  &    ! air density (kg/m3) * sum_up_aw            , 'r' represents 'rho'
    sum_up_rawphi ,  &    ! air density (kg/m3) * sum_up_awphi         , 'r' represents 'rho'
    sum_env_rawphi        ! air density (kg/m3) * sum_up_aw * mean_phi , 'r' represents 'rho'

  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: &    ! dimension (nlon, nlat, nlay) 
    phidt_MF, phidt_ED, phidt_surf_flux, &
    env_rho               ! the air density between two adjacent updraft levels (kg/m3)

  real :: phidt_negative_max

  !--- working variables that the vertical indexing are reversed, i.e. k=1 becomes the lowermost level
  real, dimension(size(phi,3)) ::    &      ! dimension (nlay)
        phi_work, dz_work, rho_work, &
        mu_work, mu_prime_work      

  real, dimension(size(phi,3)+1) ::    &    ! dimension (nlay+1)
        nu_phi_work, &
        sum_up_raw_work, sum_up_rawphi_work

  real :: &
        w1_phi1_surf_work, rho_w1_phi1_surf_work

  !--- variables for the tridiag solver
  real, dimension(size(phi,3)) :: &  ! dimension (nlay)
        a_ED, b_ED, c_ED, d_ED,     &                 ! arrays for the tridiag solver
        a_impMF_cd, b_impMF_cd, c_impMF_cd, d_impMF_cd, &                   ! arrays for the tridiag solver
        a_impMF_uw_up, b_impMF_uw_up, c_impMF_uw_up, d_impMF_uw_up, &                   ! arrays for the tridiag solver
        a_impMF_uw_env, b_impMF_uw_env, c_impMF_uw_env, d_impMF_uw_env, &                   ! arrays for the tridiag solver
        a_expMF_cd, b_expMF_cd, c_expMF_cd, d_expMF_cd, &                   ! arrays for the tridiag solver
        a_expMF_uw, b_expMF_uw, c_expMF_uw, d_expMF_uw, &                   ! arrays for the tridiag solver
        a_work, b_work, c_work, d_work, &                   ! arrays for the tridiag solver
        a, b, c, d                   ! arrays for the tridiag solver

  !--- index variables 
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm

  !--- variables for check
  logical do_check_lhs_rhs
  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: & 
    phi_new
  real lhs, rhs

!---------------------------

!--- set dimensions
  ix  = size( phi, 1 )
  jx  = size( phi, 2 )
  kx  = size( phi, 3 )
  kxp = kx + 1
  kxm = kx - 1

!--- initialize output variables
  phidt_return = 0.
  w1_phi1  = 0.

!--- initialize work variables 
  sum_up_raw   (:,:,:) = up_rho(:,:,:) * sum_up_aw   (:,:,:)
  sum_up_rawphi(:,:,:) = up_rho(:,:,:) * sum_up_awphi(:,:,:)
  sum_env_rawphi = 0.
  rho_flux_ed    = 0.

  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring
  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
  sum_up_raw   (:,:,kxp) = 0.
  sum_up_rawphi(:,:,kxp) = 0.

!--- set env_rho
  if (option_updraft_level.eq."full") then
    env_rho(:,:,1:kx) = rho_half(:,:,2:kxp)
  else
    env_rho(:,:,1:kx) = rho_full(:,:,1:kx)
  endif

!--- compute eddy-diffusivity term, nu_phi
  nu_phi = 0.           ! initialize to 0
  nu_phi(:,:,1)   = 0.  ! zero at model top
  nu_phi(:,:,kxp) = 0.  ! zero at the surface

  if (present(diff_phi)) then
    do i=1,ix
    do j=1,jx
    do k=2,kx
      nu_phi(i,j,k) = -diff_phi(i,j,k) * rho_half(i,j,k) / (z_full(i,j,k)-z_full(i,j,k-1))
    enddo
    enddo
    enddo
  else
    nu_phi = 0.
  end if

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho
!print*,'env_rho',env_rho
!stop

!***************************
!
!   solve the tendencies
!
!***************************

!---  loop of i,j
do i=1,ix
do j=1,jx

!===============================================
! explicit MF, no ED, surface flux can be included.
!
  !if (do_MF_explicit) then   
  if (option_MF_numerics .eq. "explicit") then   
!
!===============================================
      ! compute environmental flux in MF term, rho * a * w * mean_phi_at_half_levels
      sum_env_rawphi = 0.
      do k=2,kx
        if (option_MF_env_half.eq."upwind_env") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k-1)
        else if (option_MF_env_half.eq."upwind_updraft") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
        else if (option_MF_env_half.eq."centered-diff") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * 0.5*(phi(i,j,k-1)+phi(i,j,k))
        else
          call error_mesg(' mass_flux_mod',' option_MF_env_half must be : stop', FATAL )
        endif
  
        if (option_updraft_level.eq."full") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
        endif
      enddo

    !--- compute MF flux
    phidt_MF = 0.
    rho_flux_MF(:,:,1:kx) = sum_up_rawphi(:,:,1:kx) - sum_env_rawphi(:,:,1:kx)

    rho_w1_phi1 = 0.
    rho_w1_phi1(:,:,1:kx) = rho_flux_MF(:,:,1:kx)
    w1_phi1    (:,:,1:kx) = rho_flux_MF(:,:,1:kx)/up_rho  (:,:,1:kx) 

    !--- set surface flux 
    if (do_include_surf_flux .and. present(w1_phi1_surf)) then
      w1_phi1    (:,:,kxp) = w1_phi1_surf(:,:)
      rho_w1_phi1(:,:,kxp) = rho_half(:,:,kxp) * w1_phi1_surf(:,:)
    else
      w1_phi1    (:,:,kxp) = 0. 
      rho_w1_phi1(:,:,kxp) = 0. 
    end if

    !--- compute MF tendency
    do k=kx,1,-1
      phidt_MF    (i,j,k) = -1./env_rho(i,j,k) * (rho_flux_MF(i,j,k)-rho_flux_MF(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))
      phidt_return(i,j,k) = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))
    enddo

    !--- return MF tendency
    !phidt_return(:,:,:) = phidt_MF(:,:,:)

!    print*,'explicit MF'
!    print*,'w1_phi1_surf',w1_phi1_surf
!    write(6,3002) 'data phidt_MF/',phidt_MF
!    write(6,3002) 'data phidt_return/',phidt_return
!    write(6,3002) 'data phidt_MF/',phidt_MF*86400.

!===============================================
  endif  ! end if of do_MF_explicit
!===============================================

!===============================================
! explicit MF, explicit ED, surface flux can be included.
!
  !if (do_MF_explicit .and. do_ED_explicit) then   
  if (option_MF_numerics.eq."explicit" .and. option_ED_numerics.eq."explicit") then

!
!===============================================

    !--- intialize working arrays
    phidt_ED        = 0.
    phidt_MF        = 0.
    phidt_surf_flux = 0.

    !--- compute ED flux
    rho_flux_ED = 0.
    !if (do_ED_explicit .and. present(diff_phi)) then
    if (option_ED_numerics.eq."explicit" .and. present(diff_phi)) then
      do k=2,kx
        rho_flux_ED(i,j,k) = -diff_phi(i,j,k) * rho_half(i,j,k) / (z_full(i,j,k)-z_full(i,j,k-1)) &
                         * (phi(i,j,k)-phi(i,j,k-1))
      enddo
    endif

    !--- compute the ED+MF flux
    rho_w1_phi1 = 0.
    rho_w1_phi1(i,j,1:kx) =   rho_flux_ED(i,j,1:kx)   &
                            + rho_flux_MF(i,j,1:kx) 

    w1_phi1    (i,j,1:kx) =   rho_flux_ED(i,j,1:kx)/rho_half(i,j,1:kx)  &
                            + rho_flux_MF(i,j,1:kx)/up_rho  (i,j,1:kx) 

!print*,'z_half',z_half
!print*,'z_full',z_full
!print*,'rho_half',rho_half
!print*,'rho_full',rho_full
!print*,'rho_flux_ED',rho_flux_ED
!print*,'rho_flux_MF',rho_flux_MF
!print*,'sum_up_aw',sum_up_aw
!print*,'sum_env_rawphi',sum_env_rawphi
!print*,'sum_up_rawphi',sum_up_rawphi
!stop

    !--- set surface flux 
    if (do_include_surf_flux .and. present(w1_phi1_surf)) then
      w1_phi1    (i,j,kxp) = w1_phi1_surf(i,j)
      rho_w1_phi1(i,j,kxp) = rho_half(i,j,kxp) * w1_phi1_surf(i,j)
    else
      w1_phi1    (i,j,kxp) = 0. 
      rho_w1_phi1(i,j,kxp) = 0. 
    end if
!
    !--- compute dphi/dt
    phidt_surf_flux(i,j,kx) = -1./env_rho(i,j,kx) * (0.-rho_w1_phi1(i,j,kxp))   &
                                            / (up_z(i,j,kx) - up_z(i,j,kxp))

    do k=kx,1,-1
      phidt_ED    (i,j,k) = -1./rho_full(i,j,k) * (rho_flux_ED(i,j,k)-rho_flux_ED(i,j,k+1))  &
                                            / (z_half(i,j,k) - z_half(i,j,k+1))
      phidt_MF    (i,j,k) = -1./env_rho(i,j,k) * (rho_flux_MF(i,j,k)-rho_flux_MF(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))

      phidt_return(i,j,k) = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))

      !***************
      !***************
      !***************
      !***************
      ! NEED TO FIX. Need to think about how to avoid negative tracer concentration
      !***************
      !***************
      !***************
      !***************
      !--- compute the most negative dphi/dt so that phi isn't less than zero (e.g. total water specific humidity must be positive)
!      if (varname.eq."qt" .or. varname.eq."thli") then
!        phidt_negative_max = -phi(i,j,k)/dt
!
!        !--- if phidt_return < phidt_negative_max, modity phidt_return & rho_w1_phi1 at the top 
!        if (phidt_return(i,j,k) .le. phidt_negative_max) then
!          phidt_return(i,j,k) = phidt_negative_max
!  
!          !print*,'-----  ',varname,'-----'
!          !print*,'k,rho_w1_phi1(i,j,k),old',k,rho_w1_phi1(i,j,k)
!          rho_w1_phi1(i,j,k) = -phidt_return(i,j,k)*rho_env(i,j,k)*(up_z(i,j,k) - up_z(i,j,k+1)) & 
!                              + rho_w1_phi1(i,j,k+1)
!          !print*,'k,rho_w1_phi1(i,j,k),new',k,rho_w1_phi1(i,j,k)
!        end if  ! end if of phidt_return
!      endif     ! end if of varaname
    enddo

!    write(6,3002) 'data phidt_MF/',phidt_MF
!    write(6,3002) 'data phidt_ED/',phidt_ED
!    write(6,3002) 'data phidt_surf_flux/',phidt_surf_flux
!    write(6,3002) 'data phidt_return/',phidt_return
!    write(6,3002) 'data phidt_sum/',phidt_MF+phidt_ED+phidt_surf_flux
!stop

!===============================================
  endif  ! end if of do_MF_explicit .and. .not.do_ED_implicit
!===============================================

  !===============================================
  ! implicit ED, implicit or explicit MF, surface flux can be included
  !   note that if both do_ED_explicit and do_ED_implicit are .false., ED terms are zeros,
  !   which means this would be the same as implicit or explicit MF
  !
  !if (.not.do_ED_explicit) then  ! Implicit solver
  !if (.not.option_ED_numerics.eq."explicit") then  ! Implicit solver
  if (option_ED_numerics.eq."implicit") then  ! Implicit solver
  !
  !===============================================
  
      !--- set working variables for the solver 
      do k=1,kx
        !kk=kx-k+1
        kk=k
        phi_work (kk) = phi(i,j,k)
        dz_work  (kk) = up_z(i,j,k+1) - up_z(i,j,k)
        rho_work (kk) = env_rho(i,j,k)
        mu_work  (kk) = -1./ rho_work(kk) / dz_work(kk)
        mu_prime_work(kk) = dt * mu_work  (kk)      ! = dt * g/dp if hydrostatic approximation is valid
      enddo
 
      !--- whether including MF in the solver
      !if (do_MF_implicit .or. do_MF_explicit) then
      if (option_MF_numerics.eq."explicit" .or. option_MF_numerics.eq."implicit") then
        sum_up_raw_work   (:) = sum_up_raw   (i,j,:)
        sum_up_rawphi_work(:) = sum_up_rawphi(i,j,:)
      else
        sum_up_raw_work   (:) = 0. 
        sum_up_rawphi_work(:) = 0. 
      endif
  
      !--- whether including ED in the solver
      !if (do_ED_implicit) then
      if (option_ED_numerics.eq."implicit") then
        nu_phi_work (:) = nu_phi (i,j,:)
      else
        nu_phi_work (:) = 0.
      endif
 
!print*,'do_ED_implicit',do_ED_implicit
!print*,'nu_phi',nu_phi
!print*,'yaya1'
!stop

 
      !--- whether including surface flux in the solver
      if (do_include_surf_flux .and. present(w1_phi1_surf)) then
        w1_phi1_surf_work     = w1_phi1_surf(i,j)
        rho_w1_phi1_surf_work = rho_half(i,j,kxp) * w1_phi1_surf(i,j)
      else
        w1_phi1_surf_work     = 0.
        rho_w1_phi1_surf_work = 0.
      endif
      w1_phi1    (i,j,kxp) = w1_phi1_surf_work
      rho_w1_phi1(i,j,kxp) = rho_w1_phi1_surf_work
  
     !*******************************************************
     !*******************************************************
     !
     ! set tridiag matrix coefficients for the ED part: 
     !   a_ED, b_ED, c_ED
     ! 
     !*******************************************************
     !*******************************************************
     a_ED = 0.
     b_ED = 1.
     c_ED = 0.
  
     !if (do_ED_implicit) then
     if (option_ED_numerics.eq."implicit") then
  
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(1) =   1.   &
                    + mu_prime_work(k)*nu_phi_work(k+1)         ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(1) = - mu_prime_work(k)*nu_phi_work(k+1)            ! ED term
  
        !--- other levels
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(k) = - mu_prime_work(k)*nu_phi_work(k)            ! ED term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(k) =   1.   &
                    + mu_prime_work(k)*nu_phi_work(k+1) + mu_prime_work(k)*nu_phi_work(k)     ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(k) = - mu_prime_work(k)*nu_phi_work(k+1)            ! ED term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(kx) = - mu_prime_work(k)*nu_phi_work(k)           ! ED term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(kx) =   1. &
                    +  mu_prime_work(k)*nu_phi_work(k)           ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(kx) = 0.

!print*,'mu_prime_work',mu_prime_work 
!print*,'nu_phi_work', nu_phi_work
!print*,'a_ED',a_ED
!print*,'b_ED',b_ED
!print*,'c_ED',c_ED
!stop 

     endif  ! end if of do_ED_implicit
  
     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, centered-difference
     !    a_impMF_cd, b_impMF_cd, c_impMF_cd
     !
     !*******************************************************
     !*******************************************************
     a_impMF_cd = 0.
     b_impMF_cd = 0.
     c_impMF_cd = 0.
     d_impMF_cd = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."centered-diff") then 
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."centered-diff") then 
       !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(1) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1))       ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(1) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
    
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(k) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)     ! MF term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(k) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(k) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(kx) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)    ! MF term 
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(kx) = - 0.5*mu_prime_work(k)*sum_up_raw_work(k)    ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(kx) = 0.
  
        !************************
        ! solve ED + implicit MF_centered-difference
        !************************

        !--- set tridiagnoal matrxi coefficients
        a_work(:) = a_ED(:) + a_impMF_cd(:)
        b_work(:) = b_ED(:) + b_impMF_cd(:)
        c_work(:) = c_ED(:) + c_impMF_cd(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work   ! surface flux term
  
!  print*,'phi_work(k)',phi_work(k)
!  print*,'mu_prime_work(k)*sum_up_rawphi_work(k)',mu_prime_work(k)*sum_up_rawphi_work(k)
!  print*,'mu_prime_work(k)*rho_w1_phi1_surf_work',mu_prime_work(k)*rho_w1_phi1_surf_work
!  print*,'mu_prime_work(k)',mu_prime_work(k)
!  print*,'rho_w1_phi1_surf_work',rho_w1_phi1_surf_work
!  print*,'a_work',a_work
!  print*,'b_work',b_work
!  print*,'c_work',c_work
!  print*,'d_work',d_work
  !stop
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
       !--- get phi_new and phidt_return
       do k=1,kx
         phi_new  (i,j,k) = d_work(k)
         phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
       enddo
   
       !--- retrieve fluxes
       rho_w1_phi1(:,:,1) = 0.
       w1_phi1    (:,:,1) = 0.
    
       do k=2,kx
         sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * 0.5 * (phi_new(i,j,k)+phi_new(i,j,k-1))
         rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
         rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                 + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
    
         w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                 + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
       enddo
    
     endif  ! end if of do_MF_implicit .and. option_MF_env_half.eq."centered-diff"

     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, upwind_env-difference
     !    a_impMF_uw_env, b_impMF_uw_env, c_impMF_uw_env, d_impMF_uw_env
     !
     !*******************************************************
     !*******************************************************
     a_impMF_uw_env = 0.
     b_impMF_uw_env = 0.
     c_impMF_uw_env = 0.
     d_impMF_uw_env = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."upwind_env") then
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."upwind_env") then
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(1) = mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(1) = 0.       ! MF term
    
          !! a, the coefficient of phi_bar(t+dt,k-1)
          !a_impMF_cd(k) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)     ! MF term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          !b_impMF_cd(k) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          !c_impMF_cd(k) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(k) = - mu_prime_work(k)*sum_up_raw_work(k)
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(k) = mu_prime_work(k)*sum_up_raw_work(k+1)                                      ! MF term
                 !+ 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(k) = 0.
                 !+ mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(kx) = - mu_prime_work(k)*sum_up_raw_work(k)
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(kx) = 0.                                     ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(kx) = 0.
  
        !-----------------------------------
        ! set tridiag matrix coefficients: a,b,c,d
        !-----------------------------------
        a_work(:) = a_ED(:) + a_impMF_uw_env(:)
        b_work(:) = b_ED(:) + b_impMF_uw_env(:)
        c_work(:) = c_ED(:) + c_impMF_uw_env(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels 
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work
  
  !print*,'a_work',a_work
  !print*,'b_work',b_work
  !print*,'c_work',c_work
  !print*,'d_work',d_work
  !stop
  
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
     
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.
     
        do k=2,kx
          sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * phi_new(i,j,k-1)
          rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
          rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                  + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
          w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                  + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
        enddo
  
     endif ! end if of do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft"
    

     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, upwind_updraft-difference
     !    a_impMF_uw_up, b_impMF_uw_up, c_impMF_uw_up, d_impMF_uw_up
     !
     !*******************************************************
     !*******************************************************
     a_impMF_uw_up = 0.
     b_impMF_uw_up = 0.
     c_impMF_uw_up = 0.
     d_impMF_uw_up = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft") then
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."upwind_updraft") then
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(1) = - mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(1) = mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
    
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(k) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(k) = - mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
                 !+ 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(k) = + mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
                 !+ mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(kx) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(kx) = -  mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(kx) = 0.
  
        !-----------------------------------
        ! set tridiag matrix coefficients: a,b,c,d
        !-----------------------------------
        a_work(:) = a_ED(:) + a_impMF_uw_up(:)
        b_work(:) = b_ED(:) + b_impMF_uw_up(:)
        c_work(:) = c_ED(:) + c_impMF_uw_up(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels 
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work
  
  !print*,'a_work',a_work
  !print*,'b_work',b_work
  !print*,'c_work',c_work
  !print*,'d_work',d_work
  !stop
  
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
     
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.
     
        do k=2,kx
          sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * phi_new(i,j,k)
          rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
          rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                  + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
          w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                  + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
        enddo
  
     endif ! end if of do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft"
  
     !*******************************************************
     !*******************************************************
     ! 
     !  set tridiag matrix coefficients for the explicit MF, 
     !    rho_flux_MF is calculated in previous do_explicit_MF, 
     !    which already used centered-difference or upwind_updraft-difference 
     ! 
     !*******************************************************
     !*******************************************************
  
     !if (do_MF_explicit .and. .not.do_MF_implicit) then
     !if (.not.do_MF_implicit) then
     if (.not. option_MF_numerics.eq."implicit") then

        !--- no MF, i.e. ED only
        !if (.not.do_MF_explicit) then
        if (.not. option_MF_numerics.eq."explicit") then
          rho_flux_MF = 0.
        endif

        !--- set tridiagnoal matrxi coefficients
        a_work(:) = a_ED(:) 
        b_work(:) = b_ED(:) 
        c_work(:) = c_ED(:) 
        d_work(:) = 0 ! initialze working array       

        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*rho_flux_MF(i,j,k+1)

        !--- other levels
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k) * (rho_flux_MF(i,j,k+1) - rho_flux_MF(i,j,k))
                      !+ mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo

        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*rho_flux_MF(i,j,k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work   ! surface flux term

        !-----------------------------------------
        ! call tridiag matrix and compute w'phi'
        !-----------------------------------------
!  print*,'a_work',a_work
!  print*,'b_work',b_work
!  print*,'c_work',c_work
!  print*,'d_work',d_work
!  stop
        call tridiag(kx,a_work,b_work,c_work,d_work)

        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
  
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.

        do k=2,kx
          rho_flux_ED   (i,j,k) =  nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
        enddo

        rho_w1_phi1(i,j,1:kx) =  rho_flux_ED(i,j,1:kx) + rho_flux_MF(i,j,1:kx)
        w1_phi1    (i,j,1:kx) =  rho_flux_ED(i,j,1:kx)/rho_half(i,j,1:kx) &
                               + rho_flux_MF(i,j,1:kx)/up_rho  (i,j,1:kx)

!print*,'yaya'
!print*,'rho_w1_phi1',rho_w1_phi1
!print*,'w1_phi1',w1_phi1
!print*,'phidt_return',phidt_return
!stop
     endif  ! end if of do_MF_explicit .and. .not.do_MF_implicit
  
 !========================== 
  
!===============================================
  end if  ! end if of .not.do_ED_explicit
!===============================================

!---
enddo    ! end do of j
enddo    ! end do of i

!**********************************************************
!**********************************************************
!****   check part   ******
!**********************************************************
!**********************************************************

do_check_lhs_rhs = .false.
!do_check_lhs_rhs = .true.

!-----------------------------------
! check part - flux divergence calculation
!   check whether the lhs, dphi/dt, equals to the rhs, -1/rho * d/dz(rho*w'phi')
!-----------------------------------
if (do_check_lhs_rhs) then
  
  i=1
  if (i.eq.1) then
  !if (varname.eq."qt") then
  ! compute left-hand side, dphi/dt, and right-hand side, 1/rho * d/dz (w'phi')
  do i=1,ix
  do j=1,jx
  do k=1,kx
    lhs = phidt_return(i,j,k)
    rhs = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                              / (up_z(i,j,k) - up_z(i,j,k+1))

    !print*,'---------  solver = ',option_solver,'  ---------'
    print*,'i,j,k,',i,j,k
    print*,'lhs (dphi/dt), rhs (-1/rho * d/dz (w1phi1), lhs-rhs'
    print*,'  ',lhs,rhs,lhs-rhs
  enddo
  enddo
  enddo

  end if

  !stop
  !print*,'up_z',up_z
!  print*,''
!        write(6,*)    '! ------------------------------------'
!        write(6,*)    '! do_MF_explicit      : ',do_MF_explicit
!        write(6,*)    '! do_MF_implicit      : ',do_MF_implicit
!        write(6,*)    '! do_ED_explicit      : ',do_ED_explicit
!        write(6,*)    '! do_ED_implicit      : ',do_ED_implicit
!        write(6,*)    '! do_include_surf_flux: ',do_include_surf_flux
!        write(6,*)    '! option_MF_env_half  : ',option_MF_env_half
!        write(6,*)    '! dt                  : ',dt
!        write(6,*)    '! ------------------------------------'
!
!  print*,''
!  print*,'w1_phi1',w1_phi1
!  print*,''
!  print*,'phidt_return',phidt_return*86400.
  stop

  !write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/up_rho(:,:,:)
  !write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf
end if ! end if of do_check_lhs_rhs

101 format ("(40f5.2)")
2000 format (A25,40(E12.4,2X))
2001 format (A25,40(F8.3,2X))
2002 format (A25,I2,A10,40(F8.3,2X))
2003 format (A25,I2,A10,40(E12.4,2X))
3000 format (A25,2X,F8.2)
3001 format (A25,2X,33(F9.3,2X,','))
3002 format (A25,2X,33(E12.4,2X,','))
3003 format (A25,2X,E12.4)

end subroutine mass_flux_tendencies

!#######################################################################

!subroutine compute_src_thli_qt_prec (dt, p, rho, dz, &
!                                     up_a, up_w, up_qc, water_frac, tau0, &
!                                     qt_src, thli_src, qc_src, qi_src, rr, ri)
!  !---------------------------------------
!  ! Description:
!  !   compute the source terms for ice-liquid water potential temperature and total water mixing ratio  
!  !
!  !   copy from the subroutine cmassflux_precip in WRF, written by Dr, Kay Suselj, 
!  !   and then modified by Yi-Hsuan Chen
!  !---------------------------------------
!
!  !--- input argument
!  real, intent(in)  :: &
!      dt,              &  ! time step, 				units: sec
!      p,               &  ! pressure, 				units: Pa
!      rho,             &  ! air density, 			units: kg/m3
!      dz,              &  ! delta_z, 				units: m 
!      up_a,            &  ! updraft area, 			units: fraction
!      up_w,            &  ! updraft vertical velocity, 		units: m/s
!      up_qc,           &  ! updraft cloud water content,	units: kg/kg
!      water_frac,      &  ! 
!      tau0                !
!
!  !--- output argument
!  real, intent(out) :: &
!      qt_src,          &  ! source term for total water mixing ratio, 			units: kg/kg/s
!      thli_src,        &  ! source term for ice-liquid water potential temperature,	units: K/s
!      qc_src,          &  ! source term for cloud liquid water, 			units: kg/kg/s
!      qi_src,          &  ! source term for cloud ice    water,				units: kg/kg/s
!      rr,              &  ! liquid precipitation rate, 					units: m/s
!      ri                  ! ice    precipitation rate, 					units: m/s
!
!  !--- local varialbes 
!  real, parameter ::        &
!      p00 = 1000.0E2,       & ! 1000 hPa
!      p00inv = 1./p00,      & ! 1/1000hPa 
!      hlv_cp = hlv/cp_air,  & ! L_l/cp, L_l is the latent heat of evaporation 
!      hlf_cp = hlf/cp_air,  & ! L_f/cp, L_l is the latent heat of fusion
!      g = grav                ! gravity acceleration, 9.8 m/s^2    
!
!  real ::       &
!      exn,      &  ! Exner function, (P/P0)^(Rd/cp)
!      hlvf_cp,  &  ! 
!      q0,       &  ! qc threshold of autoconversion, units: kg/kg
!      q0_liq,   &  ! 
!      q0_ice       !
!
!!----------------------------------
!
!! initialize output variables
!  qt_src = 0. 
!  thli_src = 0. 
!  qc_src = 0.    
!  qi_src = 0.   
!  rr = 0.  
!  ri = 0.
!
!  ! compute the threshold for autoconversion, q0
!  q0=water_frac*q0_liq+(1.-water_frac)*q0_ice
!
!  if (up_qc .gt. q0) then
!
!    ! compute Exner function, (P/P0)^(Rd/cp)     
!    exn=(p*p00inv)**kappa
!
!    ! compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
!    hlvf_cp = hlv_cp*water_frac + hlf_cp*(1.-water_frac)
!
!    ! source term for qt
!    qt_src=-(up_qc-q0)*(1.-exp(-dz/(up_w*tau0)))      
!
!    ! source term for theta_li
!    thli_src=-qt_src*hlvf_cp/exn
!
!    ! source term for qc, qi
!    qc_src=(up_qc-q0)/dt*(exp(-dt/tau0)-1.)*up_a    
!    qi_src=qc_src*(1.-water_frac)
!    qc_src=qc_src*water_frac
!
!    ! compute precipitation flux, m/s
!    rr=-rho*qc_src*up_a*dz/dens_h2o
!    ri=-rho*qi_src*up_a*dz/dens_h2o
!
!  end if
!
!end subroutine compute_src_thli_qt_prec
!
!!#######################################################################
!
subroutine compute_thv_qc (qt, thli, p, water_frac, &
                           thv, qq, qc, ql, qi,         &
                           qsat)
  !---------------------------------------
  ! Description:
  !   compute virtual potential temperature and cloud water specific humidity 
  !   based on ice-liquid water potential temperature and total water specific humidity
  !
  !   copy from the subroutine condensation_edmf in WRF, written by Dr, Kay Suselj, 
  !   and then modified by Yi-Hsuan Chen
  !---------------------------------------

  !--- input argument
  real, intent(in)  :: &
      qt,              &   ! total water specific humidity (vapor + cloud liquid + cloud ice), units: kg/kg
      thli,            &   ! ice-liquid water potential temperature  	                     , units: K
      p,               &   ! pressure                                       	             , units: Pa
      water_frac           ! cloud liquid water fraction                         	     , units: fraction

  real, intent(in), optional :: & 
      qsat                 ! optional: the saturation specific humidity can be an input      , units: kg/kg
                           !   This helps to debug in an offline code

  !--- output argument
  real, intent(out) :: &
      thv,             &   ! virtual potential temperature 	    , units: K
      qq,              &   ! specific humidity, units: kg/kg
      qc,              &   ! cloud water (liq+ice) specific humidity, units: kg/kg
      ql,              &   ! cloud liquid water specific humidity   , units: kg/kg
      qi                   ! cloud ice    water specific humidity   , units: kg/kg
 
  !--- local varialbes 
  real, parameter ::        &
      p00 = 1000.0E2,       & ! 1000 hPa
      p00inv = 1./p00,      & ! 1/1000hPa 
      g = grav,             & ! gravity acceleration, 9.8 m/s^2    
      rv_rd = rvgas/rdgas,  & ! rv/rd = 1.6
      hlv_cp = hlv/cp_air,  & ! hlv/cp, hlv is the latent heat of evaporation 
      hlf_cp = hlf/cp_air,  & ! hlf/cp, hlf is the latent heat of fusion
      niter = 50,           & ! number of iterations
      diff  = 1.e-4           ! minimum difference for iteration

  real ::         &
      t,          &    ! temperature (K)
      tv,         &    ! temperature (K)
      qs,         &    ! saturation vapor specific humidity (kg/kg)
      exn,        &    ! Exner function, (P/P0)^(Rd/cp)
      hlvf_cp,    &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_hlvf_cp, &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_old           ! 
   
  real :: tt1

  integer i
!------------------------------------

  !--- initialize return variables
  thv = 0.
  qc  = 0.
  qc  = 0.
  ql  = 0.
  qi  = 0.
  
 !--- compute Exner function, (P/P0)^(Rd/cp) 
  exn=(p*p00inv)**kappa  

  !--- iterate to get qc
  do i=1,niter

    !--- compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
    hlvf_cp = (hlv_cp*water_frac + hlf_cp*(1.-water_frac))
    qc_hlvf_cp = qc * hlvf_cp

    !--- compute temperature
    t  = exn*(thli+qc_hlvf_cp)     

    !--- compute saturation specific humidity
    if (present(qsat)) then
      qs = qsat
    else
      qs = qs_edmf(t,p,water_frac)   
    endif

    !--- compute qc, and qc_old
    qc_old = qc
    qc    = max(0.5*qc+0.5*(qt-qs),0.)
    if (abs(qc-qc_old)<diff) exit   ! compare previous qc and current qc values
  end do

  !--- get the final value of t, qs, qc, and thv
  qc_hlvf_cp = qc * hlvf_cp
  t = exn*(thli+qc_hlvf_cp)

  qq  = max(qt-qc,0.)    ! note that qq is very close to qs(t), but not exactly the same due to numerics
  ql  = qc * water_frac
  qi  = qc * (1.-water_frac)

  thv = (thli+qc_hlvf_cp/exn)*(1.+qt*(rv_rd-1.)-rv_rd*qc)  ! Kay's formula, but I don't understand why
  !tt1 = t*(qq*d608+1.0)/exn                                ! standard virtual potential temperature formula
  !print*,'thv_Kay,thv_d608,diff',thv,tt1,thv-tt1  ! the difference is very small

  !print*,'aa, thv= ',thv
  !print*,'aa, qc=  ',qc
  !print*,'thli,qt,p,',thli,qt,p,', thv,qc',thv,qc
  !print*,'-----------------'
  !print*,'t,p',t,p
  !print*,'thli,thv,',thli,thv
  !print*,'qt,qq,qc',qt,qq,qc

!  if (qc.gt.0.) then
!    ! write(6,*) '--------------------------'
!    !! write(6,*),'ggg1, thli,thv,qt',thli,thv,qt
!    ! write(6,*),'ggg1, thli,thv',thli,thv
!    ! write(6,*),'ggg2, qt,qc',qt,qc
!    qs = qs_edmf(t,p,water_frac)
!    ! write(6,*),'ggg3, qq,rh',qq,qq/qs*100.
!  end if

end subroutine compute_thv_qc

!#######################################################################

subroutine check_trc_rlzbility (dt, tracer, tracer_tend, &
                                tend_ratio)

!---------------------------------------------------------------------
!  Check for tracer realizability. If tracer tendencies would
!  produce negative tracer mixing ratios, scale down tracer tendency
!  terms uniformly for this tracer throughout convective column. 
!
!  Reference: subroutine don_d_check_trc_rlzbility, src/atmos_param/donner_deep/donner_deep_k.F90
!---------------------------------------------------------------------

!---------------------------------------------------------------------
! Arguments (Intent in)
!     dt             physics time step               , [ sec ]
!     tracer         tracer mixing ratios            , [ kg(tracer) / kg (dry air) ]
!     tracer_tend    tendency of tracer mixing ratios, [ kg(tracer) / kg (dry air) / sec ]
!---------------------------------------------------------------------
  real,    intent(in)                   :: dt
  real,    intent(in), dimension(:,:,:) :: tracer, tracer_tend

!---------------------------------------------------------------------
! Arguments (Intent out)
!     tend_ratio     ratio by which tracer tendencies need to 
!                    be reduced to permit realizability (i.e., to prevent
!                    negative tracer mixing ratios)
!---------------------------------------------------------------------
  real, intent(out), dimension(:,:)     :: tend_ratio
  
!---------------------------------------------------------------------
! Arguments (Intent local)
!     tracer0        column tracer mixing ratios before MF
!     tracer1        column tracer mixing ratios after  MF transport only
!     trtend         column tracer mixing ratio tendencies due to convective transport [ (tracer units) / s ]
!     tracer_min     minimum of tracer0
!     tracer_max     maximum of tracer0
!---------------------------------------------------------------------

  real, dimension(size(tracer,3)) ::    &  ! dimension (nlay)
    tracer0, trtend, tracer1

  real :: &
    tracer_min, tracer_max, ratio

  character*40 cause

  !--- index variables & dimension
  integer i,j,k
  integer ix,jx,kx  

!--------------------------

!--- set dimensions
  ix  = size( tracer, 1 )
  jx  = size( tracer, 2 )
  kx  = size( tracer, 3 )

!--- initialze return variable
  tend_ratio = 1.

!---------------------
! compute tend_ratio
!   Updated tracer concentation must be 
!   (1) not negative, 
!   (2) in the range of max/min of tracer0
!---------------------
  do i=1,ix
  do j=1,jx

    !--- set column tracer concentration
    tracer0(:)  = tracer(i,j,:)
    trtend (:)  = tracer_tend(i,j,:)
    tracer1(:)  = tracer0(:) + dt * trtend(:)

!write(6,*),'tracer0',tracer0
!write(6,*),'tracer1',tracer1
!write(6,*),'trtend',trtend

    !--- get max/min of tracer0
    tracer_min = 1.e20
    tracer_max = -1.e20

    do k = 1,kx
       if (trtend(k) /= 0.) then
          tracer_max = max(tracer0(k),tracer_max)
          tracer_min = min(tracer0(k),tracer_min)
       end if
    end do

!print*,'tracer_max',tracer_max
!print*,'tracer_min',tracer_min

    !--- compute ratio
    ratio = 1.
    do k = 1,kx

       !--- if tracer1 is less than zero
       if (tracer0(k) > 0. .and. tracer1(k)<0.) then
          ratio = MIN( ratio,tracer0(k)/(-trtend(k)*dt) )
          cause = "tracer1 is less than zero"
          !write(6,*),'-------'
          !write(6,*),'aa1, less than zero, k,ratio',k,ratio
          !write(6,*),'  tracer0(k), tracer1(k), ',tracer0(k), tracer1(k)
       end if

       !--- if tracer1 is less than tracer_min
       if (tracer1(k)<tracer_min .and. trtend(k) /= 0.0 ) then
          ratio = MIN( ratio,(tracer0(k)-tracer_min)/(-trtend(k)*dt) )
          cause = "tracer1 is less than tracer_min"
          !write(6,*),'-------'
          !write(6,*),'aa2, less than min, k,ratio',k,ratio
          !write(6,*),'  tracer1(k), tracer_min, ',tracer1(k), tracer_min
       end if

       !--- if tracer1 is larger than tracer_max
       if (tracer1(k)>tracer_max  .and. trtend(k) /= 0.0 ) then
          ratio = MIN( ratio,(tracer_max-tracer0(k))/(trtend(k)*dt) )
          cause = "tracer1 is larger than tracer_max"
          !write(6,*),'-------'
          !write(6,*),'aa3, larger than max, k,ratio',k,ratio
          !write(6,*),'  tracer1(k), tracer_max, ',tracer1(k), tracer_max
       end if

    end do

    !--- make sure 1 > ratio > 0
    ratio = MAX(0.,MIN(1.,ratio))

    tend_ratio(i,j) = ratio

  enddo   ! end do of j
  enddo   ! end do of i

end subroutine check_trc_rlzbility

!#######################################################################

function qs_edmf(t,p,water_frac)
  real, intent(in)  :: &
      t, &
      p, &
      water_frac
  real qsat, qs_edmf
!  real :: &
!      esl, esi, es
!--------------------------
  !esl = 
  !esi = 

  !es = 
  !es = esl*water_frac + esi*(1.-water_frac)

  call compute_qs(t, p, qsat)

  qs_edmf = qsat

end function

!!#######################################################################
!! subroutine OUTDATED_massflux_tendencies
!!   ****  This subroutine is no longer used after June 20, 2020. ****
!!
!! Purpose:
!!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, i.e. <w'phi'>
!!
!!   According to Appendix A in Suselj et al. (2019b): 
!!     "In this solver, the large-scale horizontal advection and source terms are
!!      treated explicitly (i.e., they are taken at the time, t), whereas the
!!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!!      subgrid fluxes are treated semi-implicitly."
!!
!! Numerical discretation:
!!
!!   --------- 1   (top of the atmospheric model)
!!     * 1    
!!   --------- 2
!!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!!   --------- k-1
!!     * k-1
!!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!!     * k               as well as subgrid mixing terms <w'phi'>
!!   --------- k+1
!!     * k+1
!!   --------- ...
!!     ....
!!   --------- kx
!!     * kx
!!   --------- kxp=kx+1
!!
!!    SURFACE
!!
!!=== Equation: Eq (7) in Suselj et al. (2019b)
!!
!!   mean_PHI = uu, vv, tt, or qt
!!   mean_w   = 0.
!!
!!   w'PHI'(t,k) = sum [ up_area * (up_PHI-mean_PHI) * (up_w-0) ]
!!               = sum [ up_area(t,k) * ( up_PHI(t,k) - 0.5(mean_PHI(t,k-1)+mean_PHI(t,k) ) * up_w(t,k) ]
!!
!!=== Equation: Eq (1) in Suselj et al. (2019b)
!!
!!   mean_PHI(k,t+dt) - mean_PHI(k,t+dt)      w'PHI'(t+dt,k+1) - w'PHI'(t+dt,k)
!!  -------------------------------------- = ---------------------------------------
!!                  dt                                  dz
!!
!!  To compute <w'PHI'>, mean_PHI are taken at time (t+dt) and up_* are taken at time (t)
!!
!!  These will result in a set of linear euqations of unknown variables, mean_PHI(t+dt,k), 
!!  and these equations are solved by the Tridiagonal matrix algorithm.
!!
!!
!! History:
!!   2020/05/17  Make the input sum_up_**_input variables have the same vertical indexing with the CM4, i.e. k=1 at the uppermost.
!!   2020/06/04  Make updraft fluxes at the surface to zero, to avoid updraft bringing energy/tracer from
!!               the surface to the atmosphere that will cause  additional energy/tracer adding to the atmosphere
!!   2020/06/07  Add check part
!!   2020/06/20  Stop updating this subroutine because it is replaced by another subroutine, mass_flux_tendencies
!!
!! Author:
!!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!!
!! Notes:
!!   1. Solver, subroutine tridiag
!!      This program uses the "Tridiagonal matrix algorithm" to compute the tendency terms.
!!      Wiki has a detailed explanation about this algorithm: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm
!!
!!      a,b,c - are coefficients on the LHS
!!      d     - is initially RHS on the output becomes a solution vector
!!
!!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!!      [ a1,  0, an, bn   ]   [xn]    [dn]
!!
!!      a1=0 and cn=0
!!
!! References:
!!   Suselj et al. (2014, WAF):
!!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!!     https://doi.org/10.1175/WAF-D-14-00043.1
!!   Suselj et al. (2019a, JAS):
!!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!!     https://doi.org/10.1175/JAS-D-18-0121.1
!!   Suselj et al. (2019b, JAS):
!!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!!     https://doi.org/10.1175/JAS-D-18-0239.1
!!-----------------------
!
!subroutine OUTDATED_massflux_tendencies ( is, js, dt, time,                   &
!                                 p_half, p_full, z_half, z_full,     &
!                                 uu, vv, tt, qq,                     &
!                                 is_mass_flux,                       & 
!                                 sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!                                 sum_up_awthv_input, sum_up_awqt_input,  &
!                                 udt_mf, vdt_mf, tdt_mf, qdt_mf,     & 
!                                 thvdt_mf, qtdt_mf)
!
!!---------------------------------------------------------------------
!! Arguments (Intent in)
!!    dt           -  Time step               (sec)
!!    time         -  variables needed for netcdf diagnostics
!!    p_half       -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!!    p_full       -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!!    z_half       -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!!    z_full       -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!!    uu           -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!!    vv           -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!!    tt           -  Potential temperature   (K)     , dimension (nlon, nlat, nlay)
!!    qq           -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)
!!
!!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!!                                                        dimension (nlon,nlat)
!!
!!    sum_up_aw_input     - sum of the product of fractional area and vertical velocity for individual updraft
!!                      i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!!    sum_up_awu_input    - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!!                      i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awv_input    - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!!                      i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awthv_input  - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!!                      i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!!    sum_up_awqt_input   - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!!                      i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!!
!! Note:
!!   1. All updraft variables are at half level, i.e. the number of levels is nlay+1
!!---------------------------------
!
!  integer, intent(in)                 :: is, js
!  real,  intent(in)                   :: dt
!  type(time_type),      intent(in)    :: time
!  real,  intent(in), dimension(:,:,:) :: p_full, z_full   ! dimension (nlon, nlat, nlay)
!  real,  intent(in), dimension(:,:,:) :: p_half, z_half   ! dimension (nlon, nlat, nlay+1)
!  real,  intent(in), dimension(:,:,:) :: uu, vv, tt, qq   ! dimension (nlon, nlat, nlay)
!
!  real,  intent(in), dimension(:,:,:) ::             &    ! dimension (nlon, nlat, nlay+1)
!         sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!         sum_up_awthv_input, sum_up_awqt_input
!
!  logical, intent(in), dimension(:,:) :: is_mass_flux     ! dimension (nlon, nlat)
!
!!---------------------------------------------------------------------
!! Arguments (Intent out)
!!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!!   thvdt_mf - virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!!   qtdt_mf  - total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!!
!! Note:
!!   1. The vertical indexing of d*_dt terms is the same as the input variables such as uu,vv,tt,etc.
!!        i.e. k=1 is the uppermost level
!!---------------------------------------------------------------------
!
!  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
!      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
!      thvdt_mf, qtdt_mf
!
!!---------------------------------------------------------------------
!!  (Intent local)
!!---------------------------------------------------------------------
!
!  !--- updraft variables for work
!  !      times the input sum_up_* by air density (rho, abbreviated as 'r')
!  !      note that the vertical indexing is reversed from sum_up_*_input. The new indexing is counted upward from the surface,
!  !      i.e. k=1 is the lowermost model level
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!         sum_up_raw, sum_up_rawu, sum_up_rawv,              &
!         sum_up_rawthv, sum_up_rawqt
!
!  !--- grid-mean variables for work
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        uu_rev, vv_rev, thv_rev,    &  ! reverse indexing so that they are counted from surface upward
!        qt_rev, dz_rev, rho_rev, dt_rhodz  !   i.e. k=1 is the lowermost level
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)) :: &  ! dimension (nlon,nlat,nlay)
!        qt,   & ! total specific humidity (vapor+condensed), (kg/kg)
!        tv,   & ! virtual temperature                        (K)
!        thv,  & ! virtual potential temperature              (K)
!        rho_full,  & ! air density at full levels                               (kg/m3)
!        ape     ! factor to compute potential temperature
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!        rho_half    ! air density at half levels (kg/m3)
!
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp
!
!  !--- variables for the tridiag solver
!  real, dimension(size(uu,3)) :: &  ! dimension (nlay)
!        a, b, c, d                  ! arrays for the tridiag solver
!
!
!  !*** parameters ***
!  real, parameter :: &
!      p00 = 1000.0E2,     & ! 1000 hPa
!      p00inv = 1./p00,    & ! 1/1000hPa
!      g = grav              ! gravity acceleration
!
!  !*** index variables ***
!  integer i,j,k,kk,n
!  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
!
!  !*** use for netCDF output ***
!  logical used
!
!  !*** variables for result checking ***
!  real tt1,tt2,tt3,tt4,tt5
!  real awphi_k, awphi_kp
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: sum_up_rawphi, sum_env_rawphi, w1phi1
!  real, dimension(size(uu,1),size(uu,2),size(uu,3))   :: phi, dphi_dt, phi_new
!  real, dimension(size(uu,3)) :: phi_rev, phi_d
!  character*5, phi_name
!  logical use_explicit_solver   ! use explicit solver to obtain tendency terms. For check use only
!
!!---------------------------------------------------------------
!
!!--- set dimensions
!  ix  = size( uu, 1 )
!  jx  = size( uu, 2 )
!  kx  = size( uu, 3 )
!  kxp = kx + 1
!  kxm = kx - 1
!  ism = is - 1
!  jsm = js - 1
!
!!--- compute virtual potential temperature, thv
!  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)
!  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  
!  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)
!
!!--- compute air density at full and half levels
!  do i=1,ix
!  do j=1,jx
!  do k=1,kx-1
!    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
!  enddo
!  enddo
!  enddo
!  rho_half(:,:,1)    = rho_full(:,:,1)  
!  rho_half(:,:,kx+1) = rho_full(:,:,kx)
!
!!--- set updraft working variables, in which the vertical indexing is reversed 
!!      so that k=1 is at the lowermost model level
!  do i=1,ix
!  do j=1,jx
!  do k=1,kxp
!    kk=kxp-k+1
!    sum_up_raw   (i,j,kk) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,kk) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,kk) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,kk) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,kk) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo
!  enddo
!  enddo
!
!  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring 
!  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
!  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
!  sum_up_raw   (:,:,1) = 0.
!  sum_up_rawu  (:,:,1) = 0.
!  sum_up_rawv  (:,:,1) = 0.
!  sum_up_rawthv(:,:,1) = 0.
!  sum_up_rawqt (:,:,1) = 0.
!
!!--- initialize return and working variables 
!  udt_mf   = 0.
!  vdt_mf   = 0.
!  tdt_mf   = 0.
!  qdt_mf   = 0.
!  thvdt_mf = 0.
!  qtdt_mf  = 0.
!
!  qt(:,:,:) = qq(:,:,:)
!
!  a = 0.
!  b = 0.
!  c = 0.
!  d = 0.
!
!!----------------------
!! compute tendencies 
!!----------------------
!
!  !--- loop for each (i,j) point
!  do i=1,ix
!  do j=1,jx
!
!!------------------------
!! if there are updrafts
!!------------------------
!    if (is_mass_flux(i,j)) then
!
!    !--- reverse variables so that the vertical index counting from the surface
!    !    upward, i.e. k=1 is the lowermost model level
!    do k=1,kx
!      kk=kx-k+1
!      uu_rev  (kk) = uu (i,j,k)
!      vv_rev  (kk) = vv (i,j,k)
!      qt_rev  (kk) = qt (i,j,k)
!      thv_rev (kk) = thv(i,j,k)
!      dz_rev  (kk) = z_half(i,j,k) - z_half(i,j,k+1)
!      rho_rev (kk) = rho_full(i,j,k)
!      dt_rhodz(kk) = dt / rho_rev(kk) / dz_rev(kk)
!    enddo
!
!!-----------------------------------
!! set tridiag matrix coefficients: a,b,c, 
!!   which are the same for the all variables such as uu,vv,tt,qq,etc.
!!-----------------------------------
!
!    !--- the lowermost level of the model
!    k=1
!    a(1) = 0.
!    b(1) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!    c(1) =    - 0.5 * dt_rhodz(k) *  sum_up_raw(i,j,k+1)
!
!    !--- other levels 
!    do k=2,kx-1
!      a(k) = dt_rhodz(k)      * 0.5 *  sum_up_raw(i,j,k)
!      b(k) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!      c(k) =    - dt_rhodz(k) * 0.5 *  sum_up_raw(i,j,k+1)
!    enddo
!
!    !--- the uppermost level of the model
!    a(kx) = 0.
!    b(kx) = 1.
!    c(kx) = 0.
!
!!-----------------------
!! compute uu tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )  
!    enddo
!
!    d(kx) = uu_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      udt_mf (i,j,kk) = (d(k) - uu_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute vv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!    enddo
!
!    d(kx) = vv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      vdt_mf (i,j,kk) = (d(k) - vv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute thv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!    enddo
!
!    d(kx) = thv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      thvdt_mf (i,j,kk) = (d(k) - thv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute qt tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!    enddo
!
!    d(kx) = qt_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      qtdt_mf (i,j,kk) = (d(k) - qt_rev(k))/dt
!    enddo
!
!!----------------------
!! compute qq tendency
!!----------------------
!
!    ! Set to qtdt at this moment
!    qdt_mf(i,j,:) = qtdt_mf(i,j,:)
!
!!------------------------------------
!! compute tt tendency 
!!  based on thv and qt tendencies
!!------------------------------------
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!
!!------------------------
!! end if of is_mass_flux
!!------------------------
!    endif 
!
!
!!*********************
!!*********************
!!  check part
!!*********************
!!*********************
!
!!-------------------------------
!! check part - flux divergence
!!   check whether dphi/dt = -1/rho * d/dz(rho*w'phi') for the implicit solver
!!-------------------------------
!  !phi_name = "uu"
!  !phi_name = "vv"
!  phi_name = "thv"
!  !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi    (:,:,:) = uu   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi    (:,:,:) = vv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi    (:,:,:) = thv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi    (:,:,:) = qt   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  print*,'sum_up_awthv,',sum_up_awthv_input
!  print*,'sum_up_rawphi',sum_up_rawphi 
!!  print*,'sum_env_rawphi',sum_env_rawphi 
!!  print*,'sum_env_awphi',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!!  print*,'rho*w1phi1',w1phi1
!!  print*,'phi_name,',phi_name
!!  print*,'dphi_dt',dphi_dt
!!  print*,'thvdt_mf',thvdt_mf
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf
! 
!!-----------------------------------------
!! check part - use explicit solver to compute tendency
!!-----------------------------------------
!
!use_explicit_solver = .true.
!!use_explicit_solver = .false.
!if (use_explicit_solver) then
!
!    !phi_name = "uu"
!    !phi_name = "vv"
!    phi_name = "thv"
!    !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      phi    (:,:,:) = uu   (:,:,:)
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi_rev(:) = uu_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      phi    (:,:,:) = vv   (:,:,:)
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi_rev(:) = vv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      phi    (:,:,:) = thv   (:,:,:)
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi_rev(:) = thv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      phi_name = "qt"
!      phi    (:,:,:) = qt   (:,:,:)
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi_rev(:) = qt_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  !print*,'sum_up_rawphi',sum_up_rawphi 
!  !print*,'sum_env_rawphi',sum_env_rawphi 
!  !print*,'rho*w1phi1',w1phi1
!  !print*,'phi_name,dphi_dt',phi_name,dphi_dt
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_explicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_explicit = (/',dphi_dt
!
!  ! replace tendency terms
!    thvdt_mf(:,:,:) = dphi_dt(:,:,:)
!    qdt_mf(:,:,:)   = 0.
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!end if ! end if of use_explicit_solver
!!
!!!------------------
!!!check part - mass/energy conservation
!!!------------------
!!
!!!*** check qq ***
!!  tt1 = 0.
!!  tt2 = 0.
!! 
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + qq(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (qdt_mf(i,j,k)*dt+qq(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_qq, new_qq, rho, dz',k,qq(i,j,k),(qdt_mf(i,j,k)*dt+qq(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   qdt_mf',qdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'old qq (kg/m2), ',tt1
!!  print*,'new qq (kg/m2), ',tt2
!!  print*,'-----------------------------------------'
!!
!!!*** check tt ***
!!  tt1 = 0.
!!  tt2 = 0.
!!
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_tt, new_tt, rho, dz',k,tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   tdt_mf',tdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'column old energy (J), ',tt1,'*Cp'
!!  print*,'column new energy (J), ',tt2,'*Cp'
!!  print*,'-----------------------------------------'
!!   
!!  tt1=0.
!!  tt2=0.
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tdt_mf(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + tt1
!!    print*,'k,tdt_mf,  heat_mf(J/s),',k,tdt_mf(i,j,k), tt1,'*Cp'
!!  enddo
!!
!!  print*,'sum of heat_mf (J/s), should cloase to zero,',tt2,'*Cp'
!!
!!!------------------
!!!check part - tridiagnol solver 
!!!------------------
!!  if (is_mass_flux(i,j)) then
!!    !phi_name = "uu"
!!    !phi_name = "vv"
!!    phi_name = "thv"
!!    !phi_name = "qt"
!! 
!!    !*** set phi ***
!!    if (phi_name == "uu") then
!!      phi    (:,:,:) = uu   (:,:,:)
!!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!!      phi_rev(:) = uu_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!!
!!    elseif (phi_name == "vv") then
!!      phi    (:,:,:) = vv   (:,:,:)
!!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!!      phi_rev(:) = vv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!!  
!!    elseif (phi_name == "thv") then
!!      phi    (:,:,:) = thv   (:,:,:)
!!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!!      phi_rev(:) = thv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!!  
!!    elseif (phi_name == "qt") then
!!      phi_name = "qt"
!!      phi    (:,:,:) = qt   (:,:,:)
!!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!!      phi_rev(:) = qt_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!!
!!    endif
!!
!!    !*** check program ***
!!    do k=1,kx
!!      kk=kx-k+1
!!      phi_d(kk) = phi (i,j,k) + dphi_dt(i,j,k)*dt  ! reverse 
!!    enddo
!!
!!    do k=1,kx
!!      print*,'i,j,k,phi(t),dphi,',i,j,k,phi(i,j,k),dphi_dt(i,j,k)*dt,' ',phi_name
!!    enddo
!!    print*,'-------------------------'
!!
!!    k=1
!!    !tt1 = phi_d(k) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!    tt2 = phi_d(k) * (1. - 0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt4 = phi_rev(k) - dt_rhodz(k)*sum_up_rawphi(i,j,k+1)
!!    print*,'k,lhs,rhs,lhs-rhs',k,tt2+tt3,tt4,tt2+tt3-tt4
!!
!!    do k=2,kx
!!      tt1 = phi_d(k-1) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!      tt2 = phi_d(k) * (1. + 0.5*dt_rhodz(k)*(sum_up_raw(i,j,k)-sum_up_raw(i,j,k+1)))
!!      tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!      tt4 = phi_rev(k) + dt_rhodz(k)*(sum_up_rawphi(i,j,k)-sum_up_rawphi(i,j,k+1))
!!      print*,'k,lhs,rhs,lhs-rhs',k,tt1+tt2+tt3,tt4,tt1+tt2+tt3-tt4
!!    enddo
!!
!!    end if ! end if of is_mass_flux
!!!------------------
!!!check part end
!!!------------------
!
!  enddo  ! end loop of j
!  enddo  ! end loop of i
!
!!!------------------------------
!!! write out to history files
!!!------------------------------
!!
!!!------- u tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_udt_mf > 0) then
!!    used = send_data (id_udt_mf, udt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- v tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_vdt_mf > 0) then
!!    used = send_data (id_vdt_mf, vdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- t tendency from mass flux (units: K/s) at full level -------
!!  if ( id_tdt_mf > 0) then
!!    used = send_data (id_tdt_mf, tdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- q tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qdt_mf > 0) then
!!    used = send_data (id_qdt_mf, qdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- thv tendency from mass flux (units: K/s) at full level -------
!!  if ( id_thvdt_mf > 0) then
!!    used = send_data (id_thvdt_mf, thvdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qtdt_mf > 0) then
!!    used = send_data (id_qtdt_mf, qtdt_mf, time, is, js, 1 )
!!  endif
!
!1000 format (A35,40(E12.4,2X))
!1001 format (A25,40(F8.3,2X))
!1002 format (A25,I2,A10,40(F8.3,2X))
!1003 format (A25,I2,A10,40(E12.4,2X))
!
!end subroutine OUTDATED_massflux_tendencies

!#######################################################################

subroutine random_Poisson(mu,first,ival) 
!**********************************************************************
!     Translated to Fortran 90 by Alan Miller from:
!                           RANLIB
!
!     Library of Fortran Routines for Random Number Generation
!
!                    Compiled and Written by:
!
!                         Barry W. Brown
!                          James Lovato
!
!             Department of Biomathematics, Box 237
!             The University of Texas, M.D. Anderson Cancer Center
!             1515 Holcombe Boulevard
!             Houston, TX      77030
!
! This work was supported by grant CA-16672 from the National Cancer Institute.

!                    GENerate POIsson random deviate
!                            Function
! Generates a single random deviate from a Poisson distribution with mean mu.
!                            Arguments
!     mu --> The mean of the Poisson distribution from which
!            a random deviate is to be generated.
!                              REAL mu
!                              Method
!     For details see:
!               Ahrens, J.H. and Dieter, U.
!               Computer Generation of Poisson Deviates
!               From Modified Normal Distributions.
!               ACM Trans. Math. Software, 8, 2
!               (June 1982),163-179
!     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT
!     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL
!     SEPARATION OF CASES A AND B

!     .. Scalar Arguments ..
	REAL, INTENT(IN)    :: mu
	LOGICAL, INTENT(IN) :: first
INTEGER             :: ival
!     ..
!     .. Local Scalars ..
	REAL          :: b1, b2, c, c0, c1, c2, c3, del, difmuk, e, fk, fx, fy, g,  &
                    omega, px, py, t, u, v, x, xx
	REAL, SAVE    :: s, d, p, q, p0
        INTEGER       :: j, k, kflag
	LOGICAL, SAVE :: full_init
        INTEGER, SAVE :: l, m
!     ..
!     .. Local Arrays ..
	REAL, SAVE    :: pp(35)
!     ..
!     .. Data statements ..
	REAL, PARAMETER :: a0 = -.5, a1 = .3333333, a2 = -.2500068, a3 = .2000118,  &
                a4 = -.1661269, a5 = .1421878, a6 = -.1384794,   &
                 a7 = .1250060

	REAL, PARAMETER :: fact(10) = (/ 1., 1., 2., 6., 24., 120., 720., 5040.,  &
            40320., 362880. /)

        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

!     ..
!     .. Executable Statements ..
   IF (mu > 10.0) THEN
!     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED)

  IF (first) THEN
s = SQRT(mu)
d = 6.0*mu*mu

!             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL
!             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484)
!             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 .

l = mu - 1.1484
full_init = .false.
  END IF


!     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE

	  g = mu + s*random_normal()
	  IF (g > 0.0) THEN
		ival = g

	!     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH

		IF (ival>=l) RETURN

	!     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U

		fk = ival
		difmuk = mu - fk
		CALL RANDOM_NUMBER(u)
		IF (d*u >= difmuk*difmuk*difmuk) RETURN
	  END IF

	!     STEP P. PREPARATIONS FOR STEPS Q AND H.
	!             (RECALCULATIONS OF PARAMETERS IF NECESSARY)
	!             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7.
	!             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE
	!             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK.
	!             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION.

	  IF (.NOT. full_init) THEN
		omega = .3989423/s
		b1 = .4166667E-1/mu
		b2 = .3*b1*b1
		c3 = .1428571*b1*b2
		c2 = b2 - 15.*c3
		c1 = b1 - 6.*b2 + 45.*c3
		c0 = 1. - b1 + 3.*b2 - 15.*c3
		c = .1069/mu
		full_init = .true.
	  END IF

	  IF (g < 0.0) GO TO 50

	!             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN)

	  kflag = 0
	  GO TO 70

	!     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE)

	  40 IF (fy-u*fy <= py*EXP(px-fx)) RETURN

	!     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL
	!             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT'
	!             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.)

	  50 e = random_exponential()
	  CALL RANDOM_NUMBER(u)
	  u = u + u - one
	  t = 1.8 + SIGN(e, u)
	  IF (t <= (-.6744)) GO TO 50
	  ival = mu + s*t
	  fk = ival
	  difmuk = mu - fk

	!             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN)

	  kflag = 1
	  GO TO 70

	!     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION)

	  60 IF (c*ABS(u) > py*EXP(px+e) - fy*EXP(fx+e)) GO TO 50
	  RETURN

	!     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY.
	!             CASE ival < 10 USES FACTORIALS FROM TABLE FACT

	  70 IF (ival>=10) GO TO 80
	  px = -mu
	  py = mu**ival/fact(ival+1)
	  GO TO 110

	!             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION
	!             A0-A7 FOR ACCURACY WHEN ADVISABLE
	!             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5)

	  80 del = .8333333E-1/fk
	  del = del - 4.8*del*del*del
	  v = difmuk/fk
	  IF (ABS(v)>0.25) THEN
		px = fk*LOG(one + v) - difmuk - del
	  ELSE
		px = fk*v*v* (((((((a7*v+a6)*v+a5)*v+a4)*v+a3)*v+a2)*v+a1)*v+a0) - del
	  END IF
	  py = .3989423/SQRT(fk)
	  110 x = (half - difmuk)/s
	  xx = x*x
	  fx = -half*xx
	  fy = omega* (((c3*xx + c2)*xx + c1)*xx + c0)
	  IF (kflag <= 0) GO TO 40
	  GO TO 60

	!---------------------------------------------------------------------------
	!     C A S E  B.    mu < 10
	!     START NEW TABLE AND CALCULATE P0 IF NECESSARY

	ELSE
	  IF (first) THEN
		m = MAX(1, INT(mu))
		l = 0
		p = EXP(-mu)
		q = p
		p0 = p
	  END IF

	!     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD

	  DO
		CALL RANDOM_NUMBER(u)
		ival = 0
		IF (u <= p0) RETURN

	!     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE
	!             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES
	!             (0.458=PP(9) FOR MU=10)

		IF (l == 0) GO TO 150
		j = 1
		IF (u > 0.458) j = MIN(l, m)
		DO k = j, l
		  IF (u <= pp(k)) GO TO 180
		END DO
		IF (l == 35) CYCLE

	!     STEP C. CREATION OF NEW POISSON PROBABILITIES P
	!             AND THEIR CUMULATIVES Q=PP(K)

		150 l = l + 1
		DO k = l, 35
		  p = p*mu / k
		  q = q + p
		  pp(k) = q
		  IF (u <= q) GO TO 170
		END DO
		l = 35
	  END DO

	  170 l = k
	  180 ival = k
	  RETURN
	END IF

	RETURN
	END subroutine random_Poisson

!#######################################################################
	FUNCTION random_normal() RESULT(fn_val)

	! Adapted from the following Fortran 77 code
	!      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM.
	!      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
	!      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435.

	!  The function random_normal() returns a normally distributed pseudo-random
	!  number with zero mean and unit variance.

	!  The algorithm uses the ratio of uniforms method of A.J. Kinderman
	!  and J.F. Monahan augmented with quadratic bounding curves.

	REAL :: fn_val

	!     Local variables
	REAL     :: s = 0.449871, t = -0.386595, a = 0.19600, b = 0.25472,           &
				r1 = 0.27597, r2 = 0.27846, u, v, x, y, q
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	!     Generate P = (u,v) uniform in rectangle enclosing acceptance region

	DO
	  CALL RANDOM_NUMBER(u)
	  CALL RANDOM_NUMBER(v)
	  v = 1.7156 * (v - half)

	!     Evaluate the quadratic form
	  x = u - s
	  y = ABS(v) - t
	  q = x**2 + y*(a*y - b*x)

	!     Accept P if inside inner ellipse
	  IF (q < r1) EXIT
	!     Reject P if outside outer ellipse
	  IF (q > r2) CYCLE
	!     Reject P if outside acceptance region
	  IF (v**2 < -4.0*LOG(u)*u**2) EXIT
	END DO

	!     Return ratio of P's coordinates as the normal deviate
	fn_val = v/u
	RETURN

	END FUNCTION random_normal

!#######################################################################
	FUNCTION random_exponential() RESULT(fn_val)

	! Adapted from Fortran 77 code from the book:
	!     Dagpunar, J. 'Principles of random variate generation'
	!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9

	! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM
	! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL
	! TO EXP(-random_exponential), USING INVERSION.

	REAL  :: fn_val

	!     Local variable
	REAL  :: r
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	DO
	  CALL RANDOM_NUMBER(r)
	  IF (r > zero) EXIT
	END DO

	fn_val = -LOG(r)
	RETURN

	END FUNCTION random_exponential

!#######################################################################
  SUBROUTINE tridiag(n,a,b,c,d)

!! to solve system of linear eqs on tridiagonal matrix n times n
!! after Peaceman and Rachford, 1955
!! a,b,c,d - are vectors of order n 
!! a,b,c - are coefficients on the LHS
!! d - is initially RHS on the output becomes a solution vector
    
!-------------------------------------------------------------------

    INTEGER, INTENT(in):: n
    REAL, DIMENSION(n), INTENT(in) :: a,b
    REAL, DIMENSION(n), INTENT(inout) :: c,d
    
    INTEGER :: i
    REAL :: p
    REAL, DIMENSION(n) :: q
    
    c(n)=0.
    q(1)=-c(1)/b(1)
    d(1)=d(1)/b(1)
    
    DO i=2,n
       p=1./(b(i)+a(i)*q(i-1))
       q(i)=-c(i)*p
       d(i)=(d(i)-a(i)*d(i-1))*p
    ENDDO
    
    DO i=n-1,1,-1
       d(i)=d(i)+q(i)*d(i+1)
    ENDDO

  END SUBROUTINE tridiag


!#######################################################################
subroutine Poisson(istart,iend,jstart,jend,mu,POI,seed)
implicit none
integer, intent(in) :: istart,iend,jstart,jend
real,dimension(istart:iend,jstart:jend),intent(in) :: MU
integer, dimension(istart:iend,jstart:jend), intent(out) :: POI
integer,dimension(2),intent(in) :: seed
integer :: seed_len,i,j
integer,allocatable:: the_seed(:)

!if (seed .le. 0) then seed=max(-seed,1)


call random_seed(SIZE=seed_len)
allocate(the_seed(seed_len))
the_seed(1:2)=seed
! Gfortran uses longer seeds, so fill the rest with zero
if (seed_len > 2) the_seed(3:) = seed(2)
 
 
!yhc note: if this random_seed is commented out, the dry SCM would produce strange results
call random_seed(put=the_seed)


do i=istart,iend
 do j=jstart,jend
    poi(i,j)=poidev(mu(i,j))
    
enddo
 enddo

deallocate(the_seed)  ! yhc added

end subroutine Poisson

!#######################################################################
FUNCTION poidev(xm)
!USE nrtype
!USE nr, ONLY : gammln,ran1
IMPLICIT NONE
INTEGER, PARAMETER :: SP = KIND(1.0)
REAL(SP), INTENT(IN) :: xm
REAL(SP) :: poidev
REAL(SP), PARAMETER :: PI=3.141592653589793238462643383279502884197_sp
!Returns as a floating-point number an integer value that is a random deviate drawn from a
!Poisson distribution of mean xm, using ran1 as a source of uniform random deviates.
REAL(SP) :: em,harvest,t,y
REAL(SP), SAVE :: alxm,g,oldm=-1.0_sp,sq
REAL(SP) :: tt1
!oldm is a flag for whether xm has changed since last call.
if (xm < 12.0) then !Use direct method.
!write(6,*) 'qq1, direct method'
if (xm /= oldm) then
oldm=xm
g=exp(-xm) !If xm is new, compute the exponential.
end if
em=-1
t=1.0
do
em=em+1.0_sp     !Instead of adding exponential deviates it is
                 !equivalent to multiply uniform deviates.
                 !We never actually have to take the log;
                 !merely compare to the pre-computed exponential.
call random_number(harvest)
!write(6,*) 'qq1, harvest',harvest

t=t*harvest
if (t <= g) exit
end do
!write(6,*) 'qq1, direct method, em',em

else      !    Use rejection method.
!write(6,*) 'qq1, rejection method, em',em
if (xm /= oldm) then  !If xm has changed since the last call, then precompute
                       !some functions that occur below.
oldm=xm
sq=sqrt(2.0_sp*xm)
alxm=log(xm)
g=xm*alxm-gammln_s(xm+1.0_sp) ! The function gammln is the natural log of the
end if                      ! gamma function, as given in §6.1.
do
do
call random_number(harvest)  !y is a deviate from a Lorentzian comparison
y=tan(PI*harvest)   !function.
em=sq*y+xm          !em is y, shifted and scaled.
if (em >= 0.0) exit !Reject if in regime of zero probability.
end do

em=int(em)          ! The trick for integer-valued distributions.
!write(6,*) 'qq1, rejection method, em',em

!<-- yhc
tt1=em+1.0_sp
if (tt1.le.0.) then
  !write(6,*) 'ggg, poidev,1 em,sq,y,xm', em,sq,y,xm
  !if (em.le.0.) em=int(1.)  ! yhc
  !write(6,*) 'ggg, poidev,2 em,sq,y,xm', em,sq,y,xm
  if (do_stop_run) call error_mesg(' mass_flux_mod',' poidev, em+1 is negative', FATAL )
endif
!--> yhc

t=0.9_sp*(1.0_sp+y**2)*exp(em*alxm-gammln_s(em+1.0_sp)-g)
!The ratio of the desired distribution to the comparison function; we accept or reject
!by comparing it to another uniform deviate. The factor 0.9 is chosen so that t never
!exceeds 1.
call random_number(harvest)
if (harvest <= t) exit
end do
end if
poidev=em
END FUNCTION poidev
        
!#######################################################################
FUNCTION arth_d(first,increment,n)
implicit none
INTEGER, PARAMETER :: SP = KIND(1.0)
INTEGER, PARAMETER :: DP = KIND(1.0D0)
INTEGER, PARAMETER :: I4B = SELECTED_INT_KIND(9)
REAL(DP), INTENT(IN) :: first,increment
INTEGER(I4B), PARAMETER :: NPAR_ARTH=16,NPAR2_ARTH=8
INTEGER(I4B), INTENT(IN) :: n
REAL(DP), DIMENSION(n) :: arth_d
INTEGER(I4B) :: k,k2
REAL(DP) :: temp
if (n > 0) arth_d(1)=first
if (n <= NPAR_ARTH) then
do k=2,n
arth_d(k)=arth_d(k-1)+increment
end do
else
do k=2,NPAR2_ARTH
arth_d(k)=arth_d(k-1)+increment
end do
temp=increment*NPAR2_ARTH
k=NPAR2_ARTH
do
if (k >= n) exit
k2=k+k
arth_d(k+1:min(k2,n))=temp+arth_d(1:min(k,n-k))
temp=temp+temp
k=k2
end do
end if
END FUNCTION arth_d
      
!#######################################################################
FUNCTION gammln_s(xx)
IMPLICIT NONE
INTEGER, PARAMETER :: SP = KIND(1.0)
INTEGER, PARAMETER :: DP = KIND(1.0D0)
REAL(SP), INTENT(IN) :: xx
REAL(SP) :: gammln_s
!Returns the value ln[Γ(xx)] for xx > 0.
REAL(DP) :: tmp,x
!Internal arithmetic will be done in double precision, a nicety that you can omit if five-figure
!accuracy is good enough.
REAL(DP) :: stp = 2.5066282746310005_dp
REAL(DP), DIMENSION(6) :: coef = (/76.18009172947146_dp,&
-86.50532032941677_dp,24.01409824083091_dp,&
-1.231739572450155_dp,0.1208650973866179e-2_dp,&
-0.5395239384953e-5_dp/)
!call assert(xx > 0.0, ’gammln_s arg’)
if (xx .le. 0.) print *,'gammaln fails'

!<-- yhc
if (xx .le. 0.) then
  write(6,*),'ggg, gammaln fails, ',xx
  if (do_stop_run) call error_mesg(' mass_flux_mod',' gammaln fails', FATAL )
endif
!--> yhc

x=xx
tmp=x+5.5_dp
tmp=(x+0.5_dp)*log(tmp)-tmp
gammln_s=tmp+log(stp*(1.000000000190015_dp+&
sum(coef(:)/arth_d(x+1.0_dp,1.0_dp,size(coef))))/x)
END FUNCTION gammln_s


end module mass_flux_mod
