module mass_flux_mod

!=======================================================================
!  Mass Flux parameterization that could be used in EDMF (Eddy-Diffusivity/Mass-Flux) approach
!
!  Create by Yi-Hsuan Chen & Chuck Seman, 2020.
!
!  History:
!    2020/05/26  ver 1.0
!    2020/05/27  ver 1.1  Add send_data codes in mass_flux and mass_flux_tendencies subroutines
!                         Also, add an input argument, time, to these two subroutines
!    ......               Miss tracks
!    2020/07/10  ver 3.0  dry version of mass-flux scheme
!    2020/08/22  ver 4.0  dry version of mass-flux scheme, with difference numerical option
!    2020/09/26  ver 5.0  Full dry EDMF version (ED can be handled by mass_flux)
!                         correct the bad loop of mass_flux_tendencies (this in is i,j loop)
!    2020/09/28  ver 5.1  Replace Poisson program
!    2020/10/10  ver 5.2  Add fixed entrainment rate option
!=======================================================================

use           mpp_mod, only: input_nml_file

use           fms_mod, only: file_exist, open_namelist_file,       &
                             error_mesg, FATAL, close_file, note,  &
                             check_nml_error, mpp_pe, mpp_root_pe, &
                             write_version_number, stdlog, stdout, &
                             mpp_chksum

use     constants_mod, only: rdgas, rvgas, kappa, grav, &
                             cp_air, dens_h2o, hlv, hlf

use  diag_manager_mod, only: register_diag_field, send_data

use  time_manager_mod, only: time_type

use  sat_vapor_pres_mod,    only: compute_qs

use random_numbers_mod,    only:  randomNumberStream,   &
                                  getRandomNumbers

use random_number_streams_mod, only: random_number_streams_init, &
                                     get_random_number_streams, &
                                     random_number_streams_end
 
!---------------------------------------------------------------------

implicit none
private

!---------------------------------------------------------------------

public :: mass_flux_driver, mass_flux_init, mass_flux, &
          save_massflux_tendencies, mass_flux_end

private :: &
  ! functions
  antithetic_get, cgn_get, i4_uni, initialized_get, multmod, r4_uni_01, r8_uni_01, &
  genbet, genchi, genexp, genf, gengam, gennch, gennf, gennor, genunf, &
  ignbin, ignnbn, ignpoi, ignuin, &
  lennob, r4_exp, r4_exponential_sample, r4vec_covar, r8_exponential_sample, r8vec_covar, &
  sdot, sexpo, sgamma, snorm, &

  ! subroutines
  advance_state, antithetic_memory, antithetic_set, cg_get, cg_memory, cg_set, &
  cgn_memory, cgn_set, get_state, ig_get, ig_memory, ig_set, &
  init_generator, initialize, initialized_memory, initialized_set, &
  lg_get, lg_memory, lg_set, set_initial_seed, set_seed, timestamp, &
  genmn, genmul, genprm, prcomp, setcov, setgmn, spofa, stats, trstat

!---------------------------------------------------------------------

!---------------------------------------------------------------------

character(len=128) :: version = '$Id$'
character(len=128) :: tagname = '$Name$'
logical            :: module_is_initialized = .false.
 
!---------------------------------------------------------------------
!  derived type definition for mf_tendency_type variable
!---------------------------------------------------------------------

public :: mf_tendency_type

type mf_tendency_type
     real, dimension(:,:,:), allocatable :: utnd
     real, dimension(:,:,:), allocatable :: vtnd
     real, dimension(:,:,:), allocatable :: ttnd
     real, dimension(:,:,:), allocatable :: qtnd
     real, dimension(:,:,:), allocatable :: thvtnd
     real, dimension(:,:,:), allocatable :: qttnd
end type mf_tendency_type

! routines to allocate and deallocate Tend_mf (currently not used)

private :: MF_alloc, MF_dealloc

!---------------------------------------------------------------------
! --- Constants
!---------------------------------------------------------------------

real, parameter :: p00    = 1000.0e2
real, parameter :: p00inv = 1./p00
real, parameter :: d622   = rdgas/rvgas
real, parameter :: d378   = 1.-d622
real, parameter :: d608   = d378/d622

!integer, parameter:: dp=kind(0.d0)                   ! double precision
!integer, parameter:: sp=kind(0.)                     ! single precision

!---------------------------------------------------------------------
! --- Namelist
!---------------------------------------------------------------------

integer :: up_num = 10                ! number of updrafts

logical :: do_mf_micro = .false.      ! enable/disable microphysics computation in updrafts. 
                                      ! True: do moist processes. False: no moist processes, i.e. all updrafts are assumed to be dry

!--- MF options ---
character*20 :: option_MF_numerics = "explicit"
!character*20 :: option_MF_numerics = "implicit"
!character*20 :: option_MF_numerics = "none"

!--- ED options ---
logical :: do_ED_in_mass_flux = .false.   ! do ED in mass_flux

!character*20 :: option_ED_numerics = "explicit"
!character*20 :: option_ED_numerics = "implicit"
character*20 :: option_ED_numerics = "none"

!--- surface flux option ---
!logical :: do_include_surf_flux = .true.
logical :: do_include_surf_flux = .false.

character*20 :: option_surface_flux = "star"     ! use surface flux diagnosed from u_star, q_star, b_star
!character*20 :: option_surface_flux = "updated"

real, parameter :: shflx_updated = 13.06  ! W/m2    ! temperoray 
real, parameter :: qflx_updated = 1.e-8  ! kg/m2/s

! compute phi_bar at half levels to calculate flux (now only available for the explicit solver)
!   default: centered-difference, i.e. phi_bar(k-1/2) = 0.5( phi_bar(k-1)+phi_bar(k) )
!   upwind : upwind-difference  , i.e. phi_bar(k-1/2) = phi_bar(k)
character*20 :: option_MF_env_half = "upwind_env"
!character*20 :: option_MF_env_half = "upwind_updraft"   
!character*20 :: option_MF_env_half = "centered-diff"   

!--- set the levels where updrafts are put
!      half (default): updrafts are put at model half levels
!      full          : updrafts are put at model full levels. 
!                      Note that the tendencies are calculated at half levels. If returning tendencies to the parent model,
!                      the tendencies should be put back to model full levels 
!character*20, parameter :: option_updraft_level = "full" ! put updrafts at full levels   
character*20 :: option_updraft_level = "half" ! default put updrafts at half levels   

!--- fileter of moist mass flux
!      "none": no filter
!      "if_moist_allmf_off": if moist updraft is present, set ALL mass flux to zero, i.e. no mass flux
!      "if_moist_allmoist_off": if moist updraft is present, exclude the contributions from moist updrafts
character*40 :: filter_massflux = "none" 
!character*40 :: filter_massflux = "if_moist_allmf_off"       ! if moist updraft is present, set ALL mass flux effect to zero
!character*40 :: filter_massflux = "if_moist_allmoist_off"   ! if moist updraft is present, exclude moist updraft contribution

!--- choose which tendencies are returned to the host model
!      default: return u,v,t,q tendencies
!      t_q    : only return t and q tendencies 
!      t      : only return t tendencies 
character*20 :: choose_return = "u_v_t_q"
!character*20 :: choose_return = "t_q"
!character*20 :: choose_return = "t"

real :: z_pbl_min = 100.              ! set minimum PBL height in order to avoid unrealistic lower BCs of updrafts
real :: w_star_min = 0.1              ! set minimum w* in order to avoid unrealistic lower BCs of updrafts
real :: ent0 = 0.2                    ! epsilon_0, Eq (14), Suselj (2019b)
real :: ent_length = 30.              ! L_epsilon, Eq (30), Suselj (2019b). Set to a constant at this moment
real :: z0_over_z_pbl = 0.1           ! z_0/z_pbl, Eq (A19-21), Suselj (2019a)
real :: pwmin = 1.                    ! pwmin*w_sigma is the smallest surface vertical velocity for updraft ensembles
real :: pwmax = 3.                    ! pwmax*w_sigma is the largest  surface vertical velocity for updraft ensembles
real :: aw = 1.                       ! a_w, Eq (12), Suselj (2019b)  
real :: bw = 1.5                      ! b_w, Eq (12), Suselj (2019b)
real :: w_max = 2.                    ! maximum of updraft velcovity (m/s)
real :: qt_excess_max = 1.e-3         ! maximum of moisture excess at updraft base (kg/kg) 
real :: thv_excess_max = 0.5          ! maximum of virtual potential temperature excess at updraft base (K)
real :: ent_fixed = 5.e-3             ! fixed entrainment rate (1/m) when do_stoch_entrain = .false.

real :: ent_mf_min = 0.               ! minimum of updraft entrainment rate (1/m)
real :: ent_mf_max = 1.e+4            ! maximum of updraft entrainment rate (1/m)

logical :: do_printouts = .false.         ! OUTDATED. write out some fields into the fms.log
logical :: do_writeout_profile = .false.  ! write out some fields into the fms.log
logical :: do_stop_run = .false.          ! stop the simulation if some problematic things happen, e.g. 2000 K/day heating rate

logical :: do_check_trc_rlzbility = .true. ! check tracer realizability
!logical :: do_stoch_entrain       = .true. ! do stochastic entrainmentm otherwise the entrainment rate is fixed by ent_fixed
character*20 :: option_stoch_entrain = "Poisson"
!character*20 :: option_stoch_entrain = "random_Poisson"

logical :: use_tau_mf = .true.            ! .true. use current u,v,t,q in the mass_flux program
                                          ! else   use updated u,v,t,q, i.e. u,v,t,q plus the tendencies times dt

!--- temp tests 
real :: rh_flag111 = 0.    ! a test simulation that put some moisture at the atmospheric lowest level
                           ! and see how much cloud water is condensed in the updraft.
                           ! The purpose of this test is to understand how frequent moist updrafts are.
!character*20, public, parameter :: rh_flag111_layer = "column"
!character*20 :: rh_flag111_layer = "lowest_atm"
character*20 :: rh_flag111_layer = ""

namelist / mass_flux_nml / up_num, do_mf_micro, &
                           z_pbl_min, w_star_min, &
                           ent0, ent_length, z0_over_z_pbl, &
                           pwmin, pwmax, aw, bw, &
                           filter_massflux, choose_return, &
                           w_max, qt_excess_max, thv_excess_max, &
                           option_MF_env_half, &
                           use_tau_mf,   &
                           option_stoch_entrain, ent_fixed, ent_mf_min, ent_mf_max, &
                           option_MF_numerics, option_ED_numerics, option_surface_flux, do_include_surf_flux, do_ED_in_mass_flux, &      
                           do_writeout_profile, do_printouts, do_stop_run, do_check_trc_rlzbility
         
!---------------------------------------------------------------------
!--- Diagnostic fields       
!---------------------------------------------------------------------

character(len=10) :: mod_name = 'mass_flux'
real              :: missing_value = -999.

integer :: & 
           id_uu, id_vv, id_tt, id_qq, &
           id_up_a, id_up_w, id_up_aw, id_up_awu, id_up_awv, id_up_awthv, id_up_awqt,  &
           id_udt_mf, id_vdt_mf, id_tdt_mf, id_qdt_mf, id_thvdt_mf, id_thlidt_mf, id_qtdt_mf, id_up_massflux, id_w1_thli1_mf, &
           id_ent_min, id_ent_max, id_ent_mean, &
           id_up_qt, id_up_qc, id_moist_massflux, id_is_massflux, id_tend_ratio

!---------------------------------------------------------------------

  contains

!#######################################################################

subroutine mass_flux_init(lonb, latb, axes, time, id, jd, kd)

!-----------------------------------------------------------------------
!  (Intent in)
!-----------------------------------------------------------------------
!   latb, lonb  - latitudes and longitudes at grid box corners
!   axes, time  - variables needed for netcdf diagnostics
!   id, jd, kd  - size of the first 3 dimensions

 integer,              intent(in) :: id, jd, kd, axes(4)
 type(time_type),      intent(in) :: time
 real, dimension(:,:), intent(in) :: lonb, latb

!-----------------------------------------------------------------------
!  (Intent local)
!-----------------------------------------------------------------------
 integer, dimension(3) :: full = (/1,2,3/), half = (/1,2,4/)
 integer :: unit, io, ierr, logunit

!=======================================================================

  if ( module_is_initialized ) return

!-----------------------------------------------------------------------
! --- Read namelist
!-----------------------------------------------------------------------

#ifdef INTERNAL_FILE_NML
   read (input_nml_file, nml=mass_flux_nml, iostat=io)
   ierr = check_nml_error(io,'mass_flux_nml')
#else   
  if( file_exist( 'input.nml' ) ) then
! -------------------------------------
   unit = open_namelist_file( )
   ierr = 1
   do while( ierr .ne. 0 )
   READ ( unit,  nml = mass_flux_nml, iostat = io, end = 10 ) 
   ierr = check_nml_error (io, 'mass_flux_nml')
   end do
10 continue
   call close_file( unit )
! -------------------------------------
  end if
#endif

!-----------------------------------------------------------------------
! --- Check namelist
!-----------------------------------------------------------------------

if (do_ED_in_mass_flux) then
  if ( trim(option_ED_numerics) /= 'explicit' .and. &
       trim(option_ED_numerics) /= 'implicit' )       then 
    call error_mesg( ' mass_flux',     &
                     ' when do_ED_in_mass_flux is .true., option_ED_numerics must be "explicit" or "implicit" in the mass_flux_nml',&
                     FATAL )
  endif
  if (.not.do_include_surf_flux) then
    call error_mesg( ' mass_flux',     &
                     ' when do_ED_in_mass_flux is .true., do_include_surf_flux must be .true. in the mass_flux_nml',&
                     FATAL )
  endif

  !if (do_include_surf_flux) then
  !  call error_mesg( ' mass_flux',     &
  !                   ' when do_ED_in_mass_flux is .true., do_include_surf_flux must be .false. in the mass_flux_nml',&
  !                   FATAL )
  !endif

endif

!  if ( trim(option_solver) /= 'explicit' .and. &
!       trim(option_solver) /= 'implicit' )       then 
!    call error_mesg( ' mass_flux',     &
!                     ' option_solver must be "explicit" or "implicit" in the mass_flux_nml',&
!                     FATAL )
!  end if

!-----------------------------------------------------------------------
! --- Output version
!-----------------------------------------------------------------------

  if ( mpp_pe() == mpp_root_pe() ) then
       call write_version_number(version, tagname)
       logunit = stdlog()
       WRITE( logunit, nml = mass_flux_nml ) 
  endif

!-----------------------------------------------------------------------
!--- Register diagnostic fields       
!-----------------------------------------------------------------------

  id_tend_ratio = register_diag_field (mod_name, 'MF_tend_ratio', axes(1:2), Time, &
                 'tend ratio due to tracer realizibility', 'none' , &
                 missing_value=missing_value )

  id_is_massflux = register_diag_field (mod_name, 'is_massflux', axes(1:2), Time, &
                 'is mass flux (0: no, 1: yes)', 'none' , &
                 missing_value=missing_value )

  id_moist_massflux = register_diag_field (mod_name, 'is_moist_massflux', axes(1:2), Time, &
                 'is moist flux (0: no, 1: yes)', 'none' , &
                 missing_value=missing_value )

  id_uu = register_diag_field (mod_name, 'uu', axes(full), Time, &
                 'zonal wind', 'm/s' , &
                 missing_value=missing_value )

  id_vv = register_diag_field (mod_name, 'vv', axes(full), Time, &
                 'meridional wind', 'm/s' , &
                 missing_value=missing_value )

  id_tt = register_diag_field (mod_name, 'tt', axes(full), Time, &
                 'temperature', 'K' , &
                 missing_value=missing_value )

  id_qq = register_diag_field (mod_name, 'qq', axes(full), Time, &
                 'speficic humidity', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_a  = register_diag_field (mod_name, 'up_a', axes(half), Time, &
                 'updraft fractional area', 'fraction' , &
                 missing_value=missing_value )

  id_up_w = register_diag_field (mod_name, 'up_w', axes(half), Time, &
                 'averaged updraft velocity', 'm/s' , &
                 missing_value=missing_value )

  id_up_qc = register_diag_field (mod_name, 'up_qc', axes(half), Time, &
                 'updraft averaged in-cloud cloud water content', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_qt = register_diag_field (mod_name, 'up_qt', axes(half), Time, &
                 'updraft averaged in-cloud total water content', 'kg/kg' , &
                 missing_value=missing_value )

  id_up_aw = register_diag_field (mod_name, 'up_aw', axes(half), Time, &
                 'updraft area*w', 'm/s' , &
                 missing_value=missing_value )
 
  id_up_massflux = register_diag_field (mod_name, 'up_massflux', axes(half), Time, &
                 'updraft mass flux', 'kg/m2/s' , &
                 missing_value=missing_value )

  id_up_awu = register_diag_field (mod_name, 'up_awu', axes(half), Time, &
                 'updraft area*w*u', 'm2/s2' , &
                 missing_value=missing_value )

  id_up_awv = register_diag_field (mod_name, 'up_awv', axes(half), Time, &
                 'updraft area*w*v', 'm2/s2' , &
                 missing_value=missing_value )

  id_up_awthv = register_diag_field (mod_name, 'up_awthv', axes(half), Time, &
                 'updraft area*w*theta_v', 'K m/s' , &
                 missing_value=missing_value )

  id_up_awqt = register_diag_field (mod_name, 'up_awqt', axes(half), Time, &
                 'updraft area*w*qt', 'kg/kg m/s' , &
                 missing_value=missing_value )

  id_udt_mf = register_diag_field (mod_name, 'udt_mf', axes(full), Time, &
                 'u tendency from mass flux', 'm/s2' , &
                 missing_value=missing_value )

  id_vdt_mf = register_diag_field (mod_name, 'vdt_mf', axes(full), Time, &
                 'v tendency from mass flux', 'm/s2' , &
                 missing_value=missing_value )

  id_tdt_mf = register_diag_field (mod_name, 'tdt_mf', axes(full), Time, &
                 't tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_qdt_mf = register_diag_field (mod_name, 'qdt_mf', axes(full), Time, &
                 'q tendency from mass flux', 'kg/kg/s' , &
                 missing_value=missing_value )

  id_thvdt_mf = register_diag_field (mod_name, 'thvdt_mf', axes(full), Time, &
                 'thv tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_thlidt_mf = register_diag_field (mod_name, 'thlidt_mf', axes(full), Time, &
                 'thli tendency from mass flux', 'K/s' , &
                 missing_value=missing_value )

  id_qtdt_mf = register_diag_field (mod_name, 'qtdt_mf', axes(full), Time, &
                 'qt tendency from mass flux', 'kg/kg/s' , &
                 missing_value=missing_value )

  id_w1_thli1_mf = register_diag_field (mod_name, 'w1_thli1_mf', axes(half), Time, &
                 'subgrid mixing theta_li, w1_thli1', 'K m/s' , &
                 missing_value=missing_value )

  id_ent_min = register_diag_field (mod_name, 'MF_ent_min', axes(full), Time, &
                 'MF entrainment minimum', '1/km' , &
                 missing_value=missing_value )

  id_ent_max = register_diag_field (mod_name, 'MF_ent_max', axes(full), Time, &
                 'MF entrainment maximum', '1/km' , &
                 missing_value=missing_value )

  id_ent_mean = register_diag_field (mod_name, 'MF_ent_mean', axes(full), Time, &
                 'MF entrainment mean', '1/km' , &
                 missing_value=missing_value )

!-----------------------------------------------------------------------
!--- Done with initialization
!-----------------------------------------------------------------------

  module_is_initialized = .true.

!-----------------------------------------------------------------------

end subroutine mass_flux_init

!#######################################################################

subroutine MF_alloc ( id, jd, kd, Tend_mf )

 integer, intent(in) :: id, jd, kd

 type(mf_tendency_type), intent(inout) :: Tend_mf

!-----------------------------------------------------------------------
! --- allocate and initialize Tend_mf mass flux tendencies
!-----------------------------------------------------------------------

  allocate (Tend_mf%utnd  (id,jd,kd)) ; Tend_mf%utnd   = 0.
  allocate (Tend_mf%vtnd  (id,jd,kd)) ; Tend_mf%vtnd   = 0.
  allocate (Tend_mf%ttnd  (id,jd,kd)) ; Tend_mf%ttnd   = 0.
  allocate (Tend_mf%qtnd  (id,jd,kd)) ; Tend_mf%qtnd   = 0.
  allocate (Tend_mf%thvtnd(id,jd,kd)) ; Tend_mf%thvtnd = 0.
  allocate (Tend_mf%qttnd (id,jd,kd)) ; Tend_mf%qttnd  = 0.

!-----------------------------------------------------------------------

end subroutine MF_alloc

!#######################################################################

subroutine mass_flux_end

!-----------------------------------------------------------------------

  if (.not.module_is_initialized) return

  module_is_initialized = .false.

!-----------------------------------------------------------------------

  end subroutine mass_flux_end

!#######################################################################

subroutine MF_dealloc ( Tend_mf )

 type(mf_tendency_type), intent(inout) :: Tend_mf

!-----------------------------------------------------------------------
! deallocate Tend_mf mass flux tendencies
!-----------------------------------------------------------------------

  if (allocated(Tend_mf%utnd))   deallocate (Tend_mf%utnd  )
  if (allocated(Tend_mf%vtnd))   deallocate (Tend_mf%vtnd  )
  if (allocated(Tend_mf%ttnd))   deallocate (Tend_mf%ttnd  )
  if (allocated(Tend_mf%qtnd))   deallocate (Tend_mf%qtnd  )
  if (allocated(Tend_mf%thvtnd)) deallocate (Tend_mf%thvtnd)
  if (allocated(Tend_mf%qttnd))  deallocate (Tend_mf%qttnd )

end subroutine MF_dealloc

!#######################################################################

subroutine save_massflux_tendencies ( udt_mf, vdt_mf, tdt_mf, qdt_mf, & 
                                      thvdt_mf, qtdt_mf, &
                                      Tend_mf )

!---------------------------------------------------------------------
!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!   thvdt_mf - virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!   qtdt_mf  - total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!---------------------------------------------------------------------

  real, intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
      udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, qtdt_mf

!---------------------------------------------------------------------
!   Tend_mf  - mass flux tendencies derived type variable
!---------------------------------------------------------------------

  type(mf_tendency_type), intent(out) :: Tend_mf

!---------------------------------------------------------------------
!  Local
!---------------------------------------------------------------------

  integer :: i,j,k
  integer :: ix,jx,kx

!---------------------------------------------------------------

    Tend_mf%utnd  (:,:,:) =   udt_mf(:,:,:)
    Tend_mf%vtnd  (:,:,:) =   vdt_mf(:,:,:)
    Tend_mf%ttnd  (:,:,:) =   tdt_mf(:,:,:)
    Tend_mf%qtnd  (:,:,:) =   qdt_mf(:,:,:)
    Tend_mf%thvtnd(:,:,:) = thvdt_mf(:,:,:)
    Tend_mf%qttnd (:,:,:) =  qtdt_mf(:,:,:)

!--- set dimensions

  ix  = size( udt_mf, 1 )
  jx  = size( udt_mf, 2 )
  kx  = size( udt_mf, 3 )

!--- assign tendencies to Tend_mf derived type variable

!  do i=1,ix
!  do j=1,jx
!  do k=1,kx
!    Tend_mf%utnd  (i,j,k) =   udt_mf(i,j,k)
!    Tend_mf%vtnd  (i,j,k) =   vdt_mf(i,j,k)
!    Tend_mf%ttnd  (i,j,k) =   tdt_mf(i,j,k)
!    Tend_mf%qtnd  (i,j,k) =   qdt_mf(i,j,k)
!    Tend_mf%thvtnd(i,j,k) = thvdt_mf(i,j,k)
!    Tend_mf%qttnd (i,j,k) =  qtdt_mf(i,j,k)
!  enddo
!  enddo
!  enddo

end subroutine save_massflux_tendencies


!###########################################
! subroutine mass_flux_driver
!
!   The interface of mass_flux program
!###########################################
!subroutine mass_flux_driver ( is, ie, js, je, dt, Time_next,            &
!                              do_mass_flux_diagnostic, &
!                              p_half, p_full, z_half, z_full,   & 
!                              u_star, b_star, q_star, z_pbl,    &
!                              uu, vv, tt, qq,                   &
!                              udt, vdt, tdt, qdt )

subroutine mass_flux_driver ( is, ie, js, je, dt, Time_next,           &
                              do_mass_flux_diagnostic, do_EDMF_in_mass_flux,    &
                              p_half, p_full, z_half, z_full,          &
                              u_star, b_star, q_star, z_pbl,           &
                              uu_in, vv_in, tt_in, qq_in,              &
                              udt, vdt, tdt, qdt, &
                              diff_t, diff_m, diff_t_to_vdiff, diff_m_to_vdiff )

!---------------------------------------------------------------------
! Arguments (Intent in)  
!   Descriptions of these variables are in subroutine mass_flux
!---------------------------------------------------------------------

  integer, intent(in)                   :: is, ie, js, je
  real,    intent(in)                   :: dt
  type(time_type), intent(in)           :: Time_next
  logical, intent(in)                   :: do_mass_flux_diagnostic
  real,    intent(in), dimension(:,:,:) :: p_full, z_full
  real,    intent(in), dimension(:,:,:) :: p_half, z_half
  real,    intent(in), dimension(:,:,:) :: uu_in, vv_in, tt_in, qq_in
  real,    intent(in), dimension(:,:)   :: z_pbl, u_star, b_star, q_star

  !real,    intent(in), optional, dimension(:,:,:) :: diff_t, diff_m
  real,    intent(in)   , optional, dimension(:,:,:) :: diff_t, diff_m
  real,    intent(out)  , optional, dimension(:,:,:) :: diff_t_to_vdiff, diff_m_to_vdiff

!---------------------------------------------------------------------
! Arguments (Intent out)
!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!
!   The tendencies from the mass flux program will be added up to the existing ones.
!---------------------------------------------------------------------

  real,    intent(inout), dimension(:,:,:) :: udt, vdt, tdt, qdt
  logical, intent(out)                     :: do_EDMF_in_mass_flux

!---------------------------------------------------------------------
!  Local
!   Descriptions of these variables are in subroutine mass_flux
!---------------------------------------------------------------------

  real   , dimension(size(tt_in,1),size(tt_in,2),size(tt_in,3))    :: &
           uu, vv, tt, qq,                                   &                ! state variables used in the mass flux program
           udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf       ! tendencies terms
  
  real   , dimension(size(tt_in,1),size(tt_in,2),size(tt_in,3)+1)  ::   &
           sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,        &   ! subgrid mixing terms
           sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux
  
  real, dimension(size(tt_in,1),size(tt_in,2))   :: is_mass_flux        ! indicate whether there are updrafts

  integer :: i,j,k
  real    :: tt1, tt2

!----------------------------------

  if (use_tau_mf) then   ! use current u,v,t,q
    uu(:,:,:) = uu_in(:,:,:)
    vv(:,:,:) = vv_in(:,:,:)
    tt(:,:,:) = tt_in(:,:,:)
    qq(:,:,:) = qq_in(:,:,:)

  else   ! use updated u,v,t,q
    uu(:,:,:) = uu_in(:,:,:) + udt(:,:,:)*dt
    vv(:,:,:) = vv_in(:,:,:) + vdt(:,:,:)*dt
    tt(:,:,:) = tt_in(:,:,:) + tdt(:,:,:)*dt
    qq(:,:,:) = qq_in(:,:,:) + qdt(:,:,:)*dt
  endif

  !--- initialize diff_t_to_vdiff and diff_m_to_vdiff
  if (present(diff_t_to_vdiff)) diff_t_to_vdiff(:,:,:) = diff_t(:,:,:)
  if (present(diff_m_to_vdiff)) diff_m_to_vdiff(:,:,:) = diff_m(:,:,:)

  !--- if doing ED in the mass_flux program, to avoid double counting ED in vert_diff
  !    set diff_t & diff_m to zeros
  if (do_ED_in_mass_flux) then
    do_EDMF_in_mass_flux = .true.

    if (.not.present(diff_t) .or. .not.present(diff_m)) &
       call error_mesg(' mass_flux_mod',  &
                       ' when do_ED_in_mass_flux is .true., diff_t and diff_m must be present in mass_flux program', &
                       FATAL )     

    if (.not.present(diff_t_to_vdiff) .or. .not.present(diff_m_to_vdiff)) &
       call error_mesg(' mass_flux_mod',  &
                       ' when do_ED_in_mass_flux is .true., diff_t_to_vdiff and diff_m_to_vdiff must be present in mass_flux program', &
                       FATAL )     

    if (present(diff_t_to_vdiff)) diff_t_to_vdiff = 0.
    if (present(diff_m_to_vdiff)) diff_m_to_vdiff = 0.
  endif

  !--- compute mass flux and corresponding tendency terms
  call mass_flux ( is, ie, js, je, dt, Time_next,                        &
                   p_half, p_full, z_half, z_full,                       & 
                   u_star, b_star, q_star, z_pbl,                        &
                   uu, vv, tt, qq,                                       &
                   is_mass_flux,                                         &
                   sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                   sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                   udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf, &
                   diff_t = diff_t, diff_m = diff_m)

  !--- added mass_flux tendencies to the existing tendencies
  if (.not.do_mass_flux_diagnostic) then
    if (choose_return.eq."t") then
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)

    else if (choose_return.eq."t_q") then
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)
      qdt(:,:,:) = qdt(:,:,:) + qdt_mf(:,:,:)
    else
      udt(:,:,:) = udt(:,:,:) + udt_mf(:,:,:)
      vdt(:,:,:) = vdt(:,:,:) + vdt_mf(:,:,:)
      tdt(:,:,:) = tdt(:,:,:) + tdt_mf(:,:,:)
      qdt(:,:,:) = qdt(:,:,:) + qdt_mf(:,:,:)
    end if
  end if

  !--- put tendency terms into Tend_mf
  !call save_massflux_tendencies ( udt_mf, vdt_mf, tdt_mf, qdt_mf, &
  !                                thvdt_mf, qtdt_mf, &
  !                                Tend_mf )

3000 format (A15,2X,F8.2)
3001 format (A15,2X,33(F10.3,2X,','))
3002 format (A15,2X,33(E12.4,2X,','))
3003 format (A15,2X,E12.4)

end subroutine mass_flux_driver

!###########################################
! subroutine mass_flux
!
! To-do (as of 06/21/2020)
!   1. Use ice-liquid water potential temperature, instead of virtual temperature
!
! Purpose:
!   (1) Compute updraft properties based on the grid-scale input variables, such as uu,vv,tt,qq, etc.
!   (2) Compute subgrid mixing from all updrafts, i.e. <w'phi'>
!   (3) Compute the tendencey terms by the subgrid mixing
!
! Numerical discretation. Note that when the vertical indexing is reversed when calculating updraft properties and tendencies from the implicit solver, in order to be consistent with Suselj et al. (2019b, JAS). 
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_*
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
! History:
!   2020/05/14  Add outputs of sum_up_a and avg_up_w
!               Add z_pbl_min and w_star1_min
!   2020/05/17  Make the vertical indexing of sum_up_* consistent with CM4 indexing
!   2020/06/04  Add sum_up_mass output argument
!   2020/06/07  Add check part
!   2020/06/21  Move mass_flux_tendencies program here, to simplify the calling structure
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
! References:
!   Suselj et al. (2014, WAF): 
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS): 
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1 
!###########################################

subroutine mass_flux ( is, ie, js, je, dt, Time_next,                        &
                       p_half, p_full, z_half, z_full,                       & 
                       u_star, b_star, q_star, z_pbl,                        &
                       uu, vv, tt, qq,                                       &
                       is_mass_flux,                                         &
                       sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                       sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                       udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf, &
                       diff_t, diff_m)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    is,ie,js,je -  indices marking the slab of model working on
!    dt          -  Time step               (sec)
!    Time_next   -  variable needed for netcdf output diagnostics
!    p_half      -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!    p_full      -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!    z_half      -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!    z_full      -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!    uu          -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!    vv          -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!    tt          -  temperature             (K)     , dimension (nlon, nlat, nlay)
!    qq          -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)  ,see note 1 below
!    z_pbl       -  boundary layer depth    (m)     , dimension (nlon, nlat)        ,see note 2 below
!    u_star      -  friction velocity       (m/s)   , dimension (nlon, nlat)        ,see note 2 below
!    b_star      -  buoyancy scale          (m/s^2) , dimension (nlon, nlat)        ,see note 2 below
!    q_star      -  moisture scale          (kg/kg) , dimension (nlon, nlat)        ,see note 2 below
!
!    diff_t      -  vertical diffusion coefficient for temperature (m2/s), dimension (nlon, nlat, nlay), see note 1 below
!    diff_m      -  vertical diffusion coefficient for momemtum    (m2/s), dimension (nlon, nlat, nlay), see note 1 below
!
! Set in namelist -  
!    up_num        - number of updrafts    (an integer)
!    do_mf_micro   - enable/disable microphysics computation in updrafts. 
!                      True: do moist processes. False: no moist processes, i.e. all updrafts are assumed to be dry
!    option_solver - option for solving the tendency terms. Detail description is in subroutine mass_flux_tendencies
!                      "explicit" uses an explicit scheme.     
!                      "implicit" uses an semi-implicit scheme
!
! Note:
!    1. z_pbl, diff_t,and diff_m are from a PBL scheme, e.g. my25, tke_turb, etc
!       Note that diff_t,and diff_m are not used in the mass flux program because vert_diff program handles these.
!
!    2. u_star and b_star are from monin_obukhov program, src/atmos_param/monin_obukhov/monin_obukhov_kernel.F90
!       q_star            is  from surface flux  program, src/FMScoupler/surface_flux.F90    
!
!            The magnitude of the wind stress is 
!                 density*(u_star**2)
!            The buoyancy flux, (g/theta_v) * <w'theta_v'>|surface, is
!                 u_star*b_star
!            The evaporation rate), kg vapor/m^2/s, is
!                 density*u_star*q_star
!                 So, u_star*q_star is surface moisture flux, <w'q'>, unit: (m/s * kg vapor/kg air)
!---------------------------------------------------------------------

  integer, intent(in)                   :: is, ie, js, je
  real,    intent(in)                   :: dt
  type(time_type), intent(in)           :: Time_next             
  real,    intent(in), dimension(:,:,:) :: p_full, z_full  
  real,    intent(in), dimension(:,:,:) :: p_half, z_half  
  real,    intent(in), dimension(:,:,:) :: uu, vv, tt, qq  
  real,    intent(in), dimension(:,:)   :: z_pbl, u_star, b_star, q_star

  real,    intent(in), optional, dimension(:,:,:) :: diff_t, diff_m

!---------------------------------------------------------------------
! Arguments (Intent out)
!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!                                                        dimension (nlon,nlat)
!    sum_up_a        - sum of the fractional area of individual updraft
!                        i.e. area   (unit: none),           dimension (nlon, nlat, nlay+1)
!    sum_up_aw       - sum of the product of fractional area and vertical velocity for individual updraft
!                        i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_awu      - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!                        i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awv      - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!                        i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awthv    - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!    sum_up_awthli   - sum of the product of fractional area, vertical velocity, and ice-liquid water potential temp for individual updraft
!                        i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!    sum_up_awqt     - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!                        i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!    avg_up_w        - averaged vertical velocity of updrafts, sum_up_aw/sum_up_a
!                        i.e. w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_massflux - sum of the updraft mass flux, i.e. rho * sum_up_aw
!                        i.e. a*w   (unit: kg/m2/s),           dimension (nlon, nlat, nlay+1)
!
!    udt_mf    -  zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!    vdt_mf    -  meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!    tdt_mf    -  temperature tendency                                (K/s)    , i.e. dt/dt
!    qdt_mf    -  specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!    thvdt_mf  -  virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!    thlidt_mf -  ice-liquid water potential temperature tendency     (K/s)    , i.e. dtheta_v/dt
!    qtdt_mf   -  total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!
! Note:
!   1. All updraft variables , sum_up_*, are at half level, i.e. the number of levels is nlay+1
!   2. All tendency variables, *dt_mf  , are at full level, i.e. the number of levels is nlay 
!---------------------------------------------------------------------

  real, intent(out), dimension(:,:)      :: &  ! dimension (nlon, nlat)
        is_mass_flux

  real, intent(out), dimension(:,:,:)       :: &  ! dimension (nlon, nlat, nlay+1)
        sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,     &
        sum_up_awthv, sum_up_awthli, sum_up_awqt,                       &
        avg_up_w, sum_up_massflux

  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
      thvdt_mf, thlidt_mf, qtdt_mf

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- variable for each updraft
  real, dimension(up_num, size(tt,1),size(tt,2),size(tt,3)+1)       :: &  ! dimension (up_num, nlon, nlat, nlay+1)
        each_up_a, each_up_aw,                                         &
        each_up_u, each_up_v, each_up_thv, each_up_thli, each_up_qt, each_up_qc,      &
        each_up_awu, each_up_awv, each_up_awthv,each_up_awthli, each_up_awqt,         &
        each_up_w, each_up_massflux

  !--- grid-mean variables for work
  real, dimension(size(tt,3)) ::      &  ! dimension (nlay)
        uu_rev, vv_rev, thv_rev,      &  ! reverse indexing so that these variables are counted from surface upward
        qt_rev, dz_rev,               &  !   i.e. k=1 is the lowermost level                       
        pfull_rev, thli_rev,          &
        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp

  real, dimension(size(tt,1),size(tt,2),size(tt,3)) :: &  ! dimension (nlon,nlat,nlay)
        qt,       & ! total water mixing ratio (kg/kg)
        th,       & ! potential temperature (K)
        thv,      & ! virtual potential temperature (K)
        thli,     & ! ice-liquid water potential temperature (K)
        tv,       & ! virtual temperature (K)
        rho_full, & ! air density at full levels (kg/m3)
        ape         ! (P/P0)^(-Rd/cp), factor to compute potential temperature
  
  real, dimension(size(tt,1),size(tt,2),size(tt,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
        rho_half,   &    ! air densivty at half levels
        w1_u1, w1_v1, w1_q1, w1_qt1, w1_thv1, w1_thli1, &
        up_z, up_rho, &
        sum_up_aqt, sum_up_awq, avg_up_qt, sum_up_aqc, avg_up_qc

  !--- updraft surface condition variables
  real ::       & 
        w_star1, qt_star1, thv_star1, &
        w_sigma, qt_sigma, thv_sigma, &
        w1_thv1_surf0, w1_qt1_surf0,  &
        wmin, wmax, wlower, wupper

  logical, dimension(up_num, size(tt,1),size(tt,2)) :: &             ! dimension (up_num, nlon,nlat)
        is_moist_updraft

  real, dimension(size(tt,1),size(tt,2)) :: &     ! dimension (nlon,nlat)
        w1_thv1_surf,                       &     ! surface heat flux, w'theta_v' (K m/s)
        w1_th1_surf,                        &     ! surface heat flux, w'theta'   (K m/s)
        w1_th1_surf_in_tend,                &     ! surface heat flux used in tendency calculation  (K m/s)
        w1_qt1_surf_in_tend,                &     ! surface moisture flux used in tendency calculation  (kg/m2/s)
        w1_qt1_surf,                        &     ! surface moisture flux, w'qt'  (kg/kg m/s)
        shflx_star,                         &     ! sensible heat flux retrieved from star values (W/m2)
        evap_star,                          &     ! evaporation   flux retrieved from star values (kg/m2/s)
        tend_ratio,                         &     ! ratio by which tracer MF tendencies need to 
                                                  !   be reduced to permit realizability (i.e., to prevent
                                                  !   negative tracer mixing ratios) 
        is_moist_massflux                         ! 0: dry mass flux (no condensed cloud water)
                                                  ! 1: moist mass flux with condensed cloud water

  !      The vertical indexing of up_* is NOT as the same as the input variables and sum_up_*.
  !      The indexing of up_* is counted from the surface, i.e. k=1 is the lowermost model level, 
  !      while the indexing of input variables (ex: uu,vv) is counted from the top, i.e. k=1 is the uppermost level 
   
  real, dimension(up_num,size(tt,3)+1) ::  &  ! dimension (up_num, nlay+1)
        up_u, up_v, up_w, up_w2,           &  ! updraft zonal, meridional, vertical velocity (m/s), and vertical kinetic energy (m^2/s^2)
        up_a, up_thv, up_thli,             &  ! updraft fractional area (0-1, unitless) and virtual potential temperature (K)
        up_qt, up_qq,                      &  ! updraft total specific humidity, i.e. water vapor + condensended water (kg/kg)
        up_qc, up_ql, up_qi                   ! updraft cloud water(qc), cloud liquid(ql), and cloud ice(qi) specific humidity (kg/kg)  

  real, dimension(up_num,size(tt,3)) ::    &  ! dimension (up_num, nlay)
        ent                                   ! updraft entrainment rate (1/m)

  real, dimension(size(tt,1),size(tt,2),size(tt,3)) :: &  ! dimension (nlon,nlat,nlay)
        ent_mean, ent_min, ent_max

  real ::  &
        qt_src, thli_src,                  &  ! source terms for qt and thv
        ent_bw, ent_bw_EXP, entExp, buoy           
 
  integer ent_stoch                           ! stochastic factor for entrainment

  !integer, dimension(up_num,size(tt,3)) ::    &  ! dimension (up_num, nlay)
  !      ent_stoch_2d

  real, dimension(size(tt,3),up_num) ::    &  ! dimension (nlay, up_num)
     ENTf
  integer, dimension(size(tt,3),up_num) ::    &  ! dimension (nlay, up_num)
     ENTi

  real (kind = 4), dimension(size(tt,3),up_num) ::    &  ! dimension (nlay, up_num)
     ENTf_k4

  integer, dimension(2) :: seedmf

  real :: water_frac ! liquid water fraction in updraft condensed water (0-1)

  !--- parameters
  real, parameter :: &
      p00 = 1000.0E2,      & ! 1000 hPa
      p00inv = 1./p00,     & ! 1/1000hPa 
      g = grav               ! gravity acceleration, 9.8 m/s^2

  character*20 :: varname

  !--- index variables & dimension
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
  logical used

  !--- variables for check
  character*100 :: data_source
  real, dimension(size(tt,3)+1) ::    &  ! dimension (nlay+1)
        phi_half
  logical do_printout_ncl
  logical do_check_consrv
  character*30, dimension(10) :: do_check_printouts
  real tt1,tt2,tt3
  integer ii1,ii2,ii3

  type(randomNumberStream), dimension(size(tt,1),size(tt,2)) :: &     ! dimension (nlon,nlat)
    streams
  real :: randomNumbers

!--------------------------------------------

!--- set dimensions
  ix  = size( tt, 1 )
  jx  = size( tt, 2 )
  kx  = size( tt, 3 )
  nx  = up_num
  kxp = kx + 1
  kxm = kx - 1
  ism = is - 1
  jsm = js - 1

!--- compute potential temperature, th
!            virtual potential temperature, thv
!            ice-liquid water potential temperature, thli
  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)  ! ape = (P/P0)^(-Rd/cp)
  th(:,:,:)=tt(:,:,:)*ape(:,:,:)  

  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

  thli(:,:,:)=th(:,:,:)   ! no cloud liquid/ice water from input, so thli equals to th
  !full expression of thli, thli(:,:,:)=th(:,:,:) - (hlv*qc(:,:,:)+hlf*qi(:,:,:)) /cp_air * ape(:,:,:)

!--- set total water mixing ratio  
  qt(:,:,:) = qq(:,:,:)  

!  !flag111 - set specific humidity at the lowest level
!  if (rh_flag111.gt.0.) then
!    if (rh_flag111_layer.eq."lowest_atm") then
!      call compute_qs(tt(1,1,kx), p_full(1,1,kx), tt1)
!      qt(1,1,kx) = tt1 * rh_flag111
!    else if (rh_flag111_layer.eq."column") then
!      do k=1,kx
!        call compute_qs(tt(1,1,k), p_full(1,1,k), tt1)
!        qt(1,1,k) = tt1 * rh_flag111
!      enddo
!    end if
!  end if
!  tv (:,:,:)=tt(:,:,:)*(qt(:,:,:)*d608+1.0)  ! because qq is changed, recompute thv
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

!--- compute air density at full and half levels
  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)

  do i=1,ix
  do j=1,jx
  do k=1,kx-1
    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
  enddo
  enddo
  enddo
  rho_half(:,:,1)    = rho_full(:,:,1)  
  !rho_half(:,:,kx+1) = 0.               ! no air at the surface level
  rho_half(:,:,kxp) = p_half(:,:,kxp)/(rdgas*tv(:,:,kx))  ! though rho_half(kx+1) should not be used,
                                                            ! set to a value to prevent something divided by rho_half

!--- set the z coordinate and conrresponding air density for 
!      for updraft levels
  if (option_updraft_level.eq."full") then
    up_z  (:,:,1:kx) = z_full(:,:,1:kx)
    up_z  (:,:,kxp ) = z_half(:,:,kxp)

    up_rho(:,:,1:kx) = rho_full(:,:,1:kx)
    up_rho(:,:,kxp ) = rho_half(:,:,kxp)

  else
    up_z  (:,:,:) = z_half(:,:,:)
    up_rho(:,:,:) = rho_half(:,:,:)
  end if

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho

!--- initialize return variables
  is_mass_flux      = 0. 
  is_moist_massflux = 0.

  sum_up_a        = 0.
  sum_up_aw       = 0.
  sum_up_awu      = 0.
  sum_up_awv      = 0.
  sum_up_awthv    = 0.
  sum_up_awthli   = 0.
  sum_up_awq      = 0.
  sum_up_awqt     = 0.
  sum_up_massflux = 0.

  avg_up_w        = 0.
  avg_up_qt       = 0.
  sum_up_aqt      = 0.
  avg_up_qc       = 0.
  sum_up_aqc      = 0.

  udt_mf          = 0.
  vdt_mf          = 0.
  tdt_mf          = 0.
  qdt_mf          = 0.
  thvdt_mf        = 0.
  thlidt_mf       = 0.
  qtdt_mf         = 0.

  !--- initialize work variables
  each_up_a        = 0.
  each_up_aw       = 0.
  each_up_awu      = 0.
  each_up_awv      = 0.
  each_up_awthv    = 0.
  each_up_awqt     = 0.
  each_up_massflux = 0.

  each_up_w        = 0.
  each_up_u        = 0.
  each_up_v        = 0.
  each_up_thv      = 0.
  each_up_qt       = 0.

  is_moist_updraft = .false.

!=====================================
!
!   compute the updraft mass flux
!
!=====================================

!-------------------------------------
! loop for each (i,j) point
do i=1,ix
do j=1,jx

! If the buoyancy flux (b_star*u_star) is positive,
!   there are updrafts. Otherwise, there is no any updraft.
if (b_star(i,j) .gt. 0.) then   ! use b_star here because u_star is always positive
!-------------------------------------

      !--- initialize working variables
      uu_rev    = 0.
      vv_rev    = 0.
      qt_rev    = 0.
      thv_rev   = 0.
      dz_rev    = 0.
      pfull_rev = 0.
      up_u      = 0.
      up_v      = 0.
      up_w      = 0.
      up_w2     = 0.
      up_a      = 0.
      up_thv    = 0.
      up_thli   = 0.
      up_qq     = 0.
      up_qc     = 0.
      up_qt     = 0.
      ent       = 0.

      !--- reverse grid-mean variables so that the vertical index counting from the surface
      !      upward, i.e. k=1 is the lowermost model level
      do k=1,kx
        kk=kx-k+1
        uu_rev   (kk) = uu  (i,j,k)
        vv_rev   (kk) = vv  (i,j,k)
        qt_rev   (kk) = qt  (i,j,k)
        thv_rev  (kk) = thv (i,j,k)
        thli_rev (kk) = thli(i,j,k)
        pfull_rev(kk) = p_full(i,j,k)
        dz_rev   (kk) = up_z(i,j,k) - up_z(i,j,k+1)
      enddo 

!------------------------------------------
!   compute the mass flux of each updraft
!------------------------------------------

      !------ set entrainment coefficients for each updraft ------
      !         ref: Eq (14), Suselj et al. (2019b)  

      !--- use stochastic entrainment rate
      !if (do_stoch_entrain) then

        !--- use subroutine random_Poisson
        if (option_stoch_entrain.eq."random_Poisson") then
          do n=1,nx
            do k=1,kx
              !**************************************************
              !*** the subroutine random_Poisson is taken from Kay's EDMF package in WRF
              !*** the original random_Poisson caused AMIP run stall at the first time step.
              !*** Strangely, the mass_flux ran successfully, but the flux_down_from_atmos stalled.
              !*** More strangely, the 8-day and 30-day regression tests ran successfully
              !**************************************************
              ENTf(k,n) = dz_rev(k)/ent_length
              ENTf(k,n) = max( ENTf(k,n), 0.)
              call random_Poisson(ENTf(k,n), .true., ent_stoch)  
              ent(n,k)  = (ent0 / dz_rev(k)) * real(ent_stoch)
              !prpint*,'n,k,ent_stoch,ent',n,k,ent_stoch,ent(n,k)

            end do 
          end do

        !--- use subroutine Poisson
        elseif (option_stoch_entrain.eq."Poisson") then
            !------ set entrainment coefficients for each updraft ------
            !         ref: Eq (14), Suselj et al. (2019b)  
            !         The random number generator that Kay Suselj used in the GEOS model.
            do n=1,nx
              do k=1,kx
                ENTf(k,n) = dz_rev(k)/ent_length
                ENTf(k,n) = max( ENTf(k,n), 0.)
              end do 
            end do
    
            seedmf(1) = 1000000 * ( 100*thli(i,j,kx)   - INT(100*thli(i,j,kx)  )) 
            seedmf(2) = 1000000 * ( 100*thli(i,j,kx-1) - INT(100*thli(i,j,kx-1)))
            call Poisson(1,nx,1,kx, ENTf, ENTi, seedmf)
    
            do n=1,nx
              do k=1,kx
                ent(n,k)  = (ent0 / dz_rev(k)) * real(ENTi(k,n))
         !print*,'n,k,ENTi,ent,ent0/dz',n,k,ENTi(k,n),ent(n,k),ent0 / dz_rev(k)
              end do 
            end do

        !--- use mean of the Poisson distribution
        elseif (option_stoch_entrain.eq."Poisson_mean") then
            do n=1,nx
              do k=1,kx
                ENTf(k,n) = dz_rev(k)/ent_length
                ENTi(k,n) = int(ENTf(k,n))
              end do 
            end do
    
            do n=1,nx
              do k=1,kx
                ent(n,k)  = (ent0 / dz_rev(k)) * real(ENTi(k,n))
             !print*,'n,k,ENTi,ent,ent0/dz',n,k,ENTi(k,n),ent(n,k),ent0 / dz_rev(k)
              end do 
            end do

        elseif (option_stoch_entrain.eq."ignpoi") then
            do n=1,nx
              do k=1,kx
                !ENTf(k,n) = dz_rev(k)/ent_length
                !ENTi(k,n) = ignpoi(ENTf(k,n))
                ENTf_k4(k,n) = dz_rev(k)/ent_length
                ENTf_k4(k,n) = max( ENTf_k4(k,n), 0.)
                ENTi   (k,n) = ignpoi(ENTf_k4(k,n))

!print*,'n,k,ENTf,ENTi',n,k,ENTf_k4(k,n),ENTi(k,n)
                ent(n,k)  = (ent0 / dz_rev(k)) * real(ENTi(k,n))
              end do
            end do

        elseif (option_stoch_entrain.eq."fixed") then
          ent(1:nx,1:kx) = ent_fixed

        !--- unsupported option_stoch_entrain
        else

          call error_mesg(' mass_flux_mod',  &
                          ' unsupported option_stoch_entrain', &
                          FATAL )
        end if  ! option_stoch_entrain


        !--- unsupported option_stoch_entrain
        !else
      
        !  call error_mesg(' mass_flux_mod',  &
        !                  ' unsupported option_stoch_entrain', &
        !                  FATAL )

        !--- end if of option_stoch_entrain
        !endif

      !--- fixed entrainment rate for every updraft
      !else
      !  ent(1:nx,1:kx) = ent_fixed

      !endif  ! end if of do_stoch_entrain

  !--- set the upper/lower boundaries of entrainment rate
  do n=1,nx
    do k=1,kx
      ent(n,k) = min(ent_mf_max, max(ent(n,k), ent_mf_min) )
    enddo
  enddo

!-------------------------
! save entrainment rates
!-------------------------
  do k=1,kx
    kk=kx-k+1
    ent_min (i,j,kk) = 1000. * minval(ent(:,k))              ! change unit from 1/m to 1/km
    ent_max (i,j,kk) = 1000. * maxval(ent(:,k))              ! change unit from 1/m to 1/km
    ent_mean(i,j,kk) = 1000. * sum(ent(:,k)) / real(up_num)  ! change unit from 1/m to 1/km
  enddo

!--- print out entrainment rates
if (do_writeout_profile) then
  do k=1,kx
    kk=kx-k+1
    write(6,*),'-----------'
    write(6,*),'k=',k
    write(6,*),'ent0 / dz_rev(k), ',ent0 / dz_rev(k)
    write(6,*),'option_stoch_entrain, ',option_stoch_entrain
    write(6,*),'dz_rev(k)/ent_length', dz_rev(k)/ent_length
    write(6,*),'ENTi, ',ENTi(k,:)
    write(6,*),''
    write(6,*),'ent(:,k)',ent(:,k)
    write(6,*),'ent_min(:,k)' ,ent_min(i,j,kk)
    write(6,*),'ent_max(:,k)' ,ent_max(i,j,kk)
    write(6,*),'ent_mean(:,k)',ent_mean(i,j,kk)
  enddo
endif
!  call get_random_number_streams ( is, js, Time_next, tt(:,:,1), streams)
!write(6,*) 'qqq, streams',streams
!  call getRandomNumbers (streams(1,1),randomNumbers)
!write(6,*) 'qqq, randomNumbers',randomNumbers

!--------------------------------------
! set initial conditions for updrafts
!      Ref: Suselj et al. (2019a, JAS), Appendix A
!
! Although the vertical index of the updraft base is 1, which is at the surface, 
! this does not mean the updrafts start right at the surface.
! Conceptually, the updrafts start a bit above the surface, say, delta_z above the surface.
! Assuming delta_z is small, the distance between delta_z to the lowest half level is 
! approximately the distance between the surface to the lowest half level.
! That is why the vertical index of updraft base is set to 1.
!--------------------------------------

      !--- get surface buoyancy flux, <w'thv'>, and moisture flux <w'qt1>, < > means average.
      !      buoyancy flux = (g/thv) * (w'thv' + 0.61*theta*(w'q'))  .... Eq (4.4.5d) in Stull 1988
      w1_thv1_surf (i,j) = u_star(i,j) * b_star(i,j) * thv(i,j,kx)/g  &
                           - d608*th(i,j,kx)* u_star(i,j)*q_star(i,j)
      w1_th1_surf  (i,j) = w1_thv1_surf (i,j) / (1+d608*qq(i,j,kx))
      w1_qt1_surf  (i,j) = u_star(i,j) * q_star(i,j)

      shflx_star   (i,j) = w1_thv1_surf (i,j) / (1.+d608*qq(i,j,kx)) * rho_full(i,j,kx) * cp_air
      evap_star    (i,j) = u_star(i,j) * q_star(i,j) * rho_full(i,j,kx)

      w1_thv1_surf0 = w1_thv1_surf (i,j) 
      w1_qt1_surf0  = w1_qt1_surf  (i,j)

      !--- compute scale variables of vertical velocity             (w_star1  , m/s  )
      !                               specific humidity             (qt_start , kg/kg)
      !                               virtual potential temperature (thv_star1, K    )
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_star1   = u_star(i,j)*b_star(i,j)*max(z_pbl_min,z_pbl(i,j))  ! note that u_star*b_star = (g/theta_v) * <w'theta_v'>|surface
                                                                     ! set z_pbl_min in order to avoid w_star1=0 
                                                                     ! that would cause unrealistically large thv at the bottom of the updrafts
      w_star1   = max(w_star_min, w_star1**(1./3.))                  ! get convetive velocity scale, w*
      qt_star1  = w1_qt1_surf0 /w_star1
      thv_star1 = w1_thv1_surf0/w_star1

      !--- compute variances of vertical velocity (w_sigma)
      !                         specific humidity (qt_sigma)
      !                         virtual potential temperature (thv_sigma)
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_sigma    = 1.34 * w_star1    * (z0_over_z_pbl)**(1./3.) * (1.-0.8*z0_over_z_pbl) 
      qt_sigma   = 1.34 * qt_star1   * (z0_over_z_pbl)**(-1./3.)
      thv_sigma  = 1.34 * thv_star1  * (z0_over_z_pbl)**(-1./3.)

      !--- set the upper and lower boundaries of surface vertical velocity for updraft ensemble
      wmin = w_sigma * pwmin
      wmax = w_sigma * pwmax

      !--- The surface vertical velocity is assumed to exhibit a normal distribution, bounding by wmin and wmax.
      !      The range of (wmax-wmin) is discretized into N bins and the mean of each bin is then assigned to each updraft. 
      do n=1,nx
        wlower = wmin + real(n-1)*(wmax-wmin)/real(nx)
        wupper = wmin + real(n)  *(wmax-wmin)/real(nx)
        
        up_u  (n,1) = uu_rev(1)
        up_v  (n,1) = vv_rev(1)
        up_w  (n,1) = min(w_max, 0.5*(wlower+wupper))
        up_w2 (n,1) = up_w(n,1)**2

        up_a   (n,1) = 0.5*erf(wupper/(sqrt(2.)*w_sigma))-0.5*erf(wlower/(sqrt(2.)*w_sigma)) ! ref: Eq (A15), Suselj et al. (2019a)
        up_thv (n,1) = thv_rev(1) + min(thv_excess_max, 0.58*up_w(n,1)*thv_sigma/w_sigma)    ! ref: Eq (A17), Suselj et al. (2019a)
        up_qt  (n,1) = qt_rev (1) + min(qt_excess_max , 0.58*up_w(n,1)*qt_sigma /w_sigma)    ! ref: Eq (A18), Suselj et al. (2019a)
        up_qc  (n,1) = 0.
        up_qq  (n,1) = up_qt(n,1) - up_qc(n,1)
        up_thli(n,1) = up_thv(n,1)/(up_qt(n,1)*d608+1.0)   ! no ice/liquid water so up_thli = up_theta

      enddo ! end loop of n

!-------------------------------------------
! compute the properties of each updraft
!-------------------------------------------

      !--- loop for each updraft
      do n=1,nx
        do k=1,kx

          !--- do microphysics processes (or not) in updrafts, 
          !      such as condensation, precipitation, etc
          if (do_mf_micro) then
            qt_src  = 0.         
            thli_src = 0. 
            !call compute_src_thli_qt        
          else
            qt_src  = 0.         
            thli_src = 0.         
          endif

          !--- set updraft area, updraft area does not change with height
          up_a (n,k+1) = up_a (n,k)

          !--- compute updraft thli,qt,u,v. Ref: Eq (A3), Suselj et al. (2014)
          entEXP = exp(-ent(n,k)*dz_rev(k))

          up_thli(n,k+1) = thli_rev(k)*(1.-entEXP) + up_thli(n,k)*entEXP + thli_src
          up_qt  (n,k+1) = qt_rev  (k)*(1.-entEXP) + up_qt  (n,k)*entEXP + qt_src
          up_u   (n,k+1) = uu_rev  (k)*(1.-entEXP) + up_u   (n,k)*entEXP
          up_v   (n,k+1) = vv_rev  (k)*(1.-entEXP) + up_v   (n,k)*entEXP

!if (n.eq.5) then
!print*,'----------------'
!print*,'updraft n',n
!print*,'----------------'
!  print*,'k,extEXP',k,entEXP
!  print*,'k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)'
!  print*,'  ',k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)
!  print*,'k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)'
!  print*,'  ',k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)
!endif

          !up_thv (n,k+1) = up_thli (n,k+1)  ! this will be replaced when moist processes are in

          !--- obtain updraft thv and qc
          !flag111 - set water_frac=1 at this moment
          water_frac = 1. 
          call compute_thv_qc( up_qt(n,k+1), up_thli(n,k+1), pfull_rev(k+1), water_frac, &
                               up_thv(n,k+1),up_qq(n,k+1), up_qc(n,k+1), up_ql(n,k+1), up_qi(n,k+1))

          !--- compute updraft vertical kinetic energy. Ref: Eq (B12), Suselj et al. (2019b)
          if (option_updraft_level.eq."full") then
            buoy = g * (up_thv(n,k+1)/thv_rev(k) - 1.)
            !print*,'k,up_thv(n,k+1)/thv_rev(k)',k,up_thv(n,k+1),thv_rev(k)
          else
            buoy = g * (0.5*(up_thv(n,k)+up_thv(n,k+1))/thv_rev(k) - 1.)
          end if
          ent_bw = bw*ent(n,k)
          ent_bw_EXP = exp(-2.*ent_bw*dz_rev(k))

          if (ent_bw.eq.0.) then
            up_w2(n,k+1) = up_w2(n,k) + 2.*aw*buoy*dz_rev(k)
          else
            up_w2(n,k+1) = up_w2(n,k)*ent_bw_EXP + aw*buoy/ent_bw * (1.-ent_bw_EXP)
          end if

          !--- compute vertical velocity
          if (up_w2(n,k+1) .gt. 0.) then
            up_w (n,k+1) = min(w_max, sqrt(up_w2(n,k+1)))
          else
            up_w (n,k+1) = 0.
          end if

          !--- if w^2 is less than zero then the updraft terminates
          if (up_w2(n,k+1) .le. 0.) then
            up_thv (n,k+1) = 0.
            up_thli(n,k+1) = 0.
            up_qq  (n,k+1) = 0.
            up_qt  (n,k+1) = 0.
            up_qc  (n,k+1) = 0.
            up_u   (n,k+1) = 0.
            up_v   (n,k+1) = 0.
            up_w2  (n,k+1) = 0.
            up_w   (n,k+1) = 0.
            up_a   (n,k+1) = 0.
            exit
          endif
        enddo  ! end loop of k
      enddo    ! end loop of n

!     !print out values
!     do n=1,nx
!     do k=1,kx
!       !print*,n,k,up_w2(n,k),up_w(n,k)
!       print*,n,k,'w,w2,u,thv',up_w(n,k),up_w2(n,k),up_u(n,k),up_thv(n,k)
!     enddo
!     print*,'------------'
!     enddo

!----------------------------------------------
!  filer moist mass flux if moist convection is handled by other schemes
!----------------------------------------------
     !--- search moist updraft
     do n=1,nx
       if (any(up_qc(n,:) .gt. 0.)) then
         is_moist_updraft(n,i,j) = .true.
       end if
     enddo

     !--- if any moist mass flux is present, mass_flux tendencies will be set to zero,
     !      i.e. no mass flux effects because these effects will be treated in other schemes.
     if (filter_massflux .eq. "if_moist_allmf_off") then
       if (any(up_qc(:,:) .gt. 0.)) then
         up_a(:,:) = 0.
       end if

     !--- if any moist mass flux is present, mass_flux tendencies only include the contribution from dry mass fluxes,
     !      i.e. mass flux program only handle dry mass flux, while moist mass flux are handled by other schemes.
     else if (filter_massflux .eq. "if_moist_allmoist_off") then
       do n=1,nx
         if (any(up_qc(n,:) .gt. 0.)) then
           up_a(n,:) = 0.
         end if
       enddo

     !--- do not set any filter
     else if (filter_massflux .eq. "none") then
       n=1

     !--- do not set any filter
     else
       !n=1
       call error_mesg(' mass_flux_mod',  &
                       ' unsupported filter_massflux value. It must be [if_moist_allmf_off] or [if_moist_allmoist_off] or [none]', &
                       FATAL )

     endif  ! end if of filter_massflux

!------------------------------
! summation of all updrafts
!   note that the vertical indexing is reversed in sum_up_*,
!   in order to be consistent with the CM4 vertical indexing
!------------------------------
      do k=1,kxp
        kk=kxp-k+1
        do n=1,nx
          sum_up_a     (i,j,kk) = sum_up_a     (i,j,kk) + up_a(n,k)
          sum_up_aw    (i,j,kk) = sum_up_aw    (i,j,kk) + up_a(n,k)*up_w(n,k)
          sum_up_awu   (i,j,kk) = sum_up_awu   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_u   (n,k)
          sum_up_awv   (i,j,kk) = sum_up_awv   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_v   (n,k)
          sum_up_awq   (i,j,kk) = sum_up_awq   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qq  (n,k)
          sum_up_awthv (i,j,kk) = sum_up_awthv (i,j,kk) + up_a(n,k)*up_w(n,k)*up_thv (n,k)
          sum_up_awthli(i,j,kk) = sum_up_awthli(i,j,kk) + up_a(n,k)*up_w(n,k)*up_thli(n,k)
          sum_up_awqt  (i,j,kk) = sum_up_awqt  (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qt  (n,k)
          sum_up_aqt   (i,j,kk) = sum_up_aqt   (i,j,kk) + up_a(n,k)          *up_qt(n,k)
          sum_up_aqc   (i,j,kk) = sum_up_aqc   (i,j,kk) + up_a(n,k)          *up_qc(n,k)

          each_up_a       (n,i,j,kk) = up_a   (n,k)
          each_up_w       (n,i,j,kk) = up_w   (n,k)
          each_up_aw      (n,i,j,kk) = up_a   (n,k)*up_w(n,k)
          each_up_u       (n,i,j,kk) = up_u   (n,k)
          each_up_v       (n,i,j,kk) = up_v   (n,k)
          each_up_thv     (n,i,j,kk) = up_thv (n,k)
          each_up_thli    (n,i,j,kk) = up_thli(n,k)
          each_up_qt      (n,i,j,kk) = up_qt  (n,k)
          each_up_qc      (n,i,j,kk) = up_qc  (n,k)
          each_up_massflux(n,i,j,kk) = up_rho (i,j,kk) * up_a(n,k)*up_w(n,k)
          each_up_awu     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_u   (n,k)
          each_up_awv     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_v   (n,k)
          each_up_awthv   (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thv (n,k)
          each_up_awthli  (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thli(n,k)
          each_up_awqt    (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_qt  (n,k)

        enddo  ! end loop of n
      enddo    ! end loop of k

      ! compute averaged vertical velocity of updradts
      do k=1,kxp
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aw (i,j,k) > 0.) then
          avg_up_w    (i,j,k) = sum_up_aw   (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_w    (i,j,k) = 0.
        endif
      enddo  

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqt (i,j,k) > 0.) then
          avg_up_qt    (i,j,k) = sum_up_aqt  (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_qt    (i,j,k) = 0.
        endif
      enddo

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqc (i,j,k) > 0.) then
          avg_up_qc    (i,j,k) = sum_up_aqc  (i,j,k) / sum_up_a (i,j,k)
          is_moist_massflux(i,j)   = 1.
        else
          avg_up_qc    (i,j,k) = 0.
        endif
      enddo

      ! get updraft mass flux, air density * updraft area * vertical velocity
      do k=1,kxp
        sum_up_massflux(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k)
      enddo

      if (any(sum_up_massflux(i,j,:) .gt. 0.)) then
        is_mass_flux(i,j) = 1. 
      else
        is_mass_flux(i,j) = 0.
      end if

!--------------------------------
!  end of updraft compuation
! 
endif  ! end of b_star(i,j)

enddo  ! end of loop j
enddo  ! end of loop i
!--------------------------------
 
  !i=1
  !j=1
!  do n=1,nx
!    print*,'-------------------'
!  do k=25,kx
!    print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
!  enddo
!  enddo
     
!==============================
!
!  compute tendencies for entire (i,j)
!    MF numerics, ED numerics, and surface flux are set in namelist
!
!==============================

        !if (do_use_updated_shflx) then
        if (option_surface_flux.eq."updated") then
          w1_th1_surf_in_tend(:,:) = shflx_updated / rho_full(:,:,kx) / cp_air
          w1_qt1_surf_in_tend(:,:) = qflx_updated  / rho_full(:,:,kx) / cp_air
        else
          w1_th1_surf_in_tend(:,:) = w1_th1_surf(:,:)
          w1_qt1_surf_in_tend(:,:) = w1_qt1_surf(:,:)
        endif

        !--- compute tendency of zonal wind, uu
        varname = "uu" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   uu, sum_up_awu, udt_mf, w1_u1, varname)
  
        !--- compute tendency of meridional wind, vv
        varname = "vv" 
        call mass_flux_tendencies (dt,  is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   vv, sum_up_awv, vdt_mf, w1_v1, varname)
  
        !--- compute tendency of total water mixing ratio, qt 
        varname = "qt" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qt, sum_up_awqt, qtdt_mf, w1_qt1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_qt1_surf_in_tend)
  
        !--- compute tendency of specific humidity, qq
        varname = "qq" 
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qq, sum_up_awq, qdt_mf, w1_q1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_qt1_surf_in_tend)
  
        !varname = "" 
        !call mass_flux_tendencies (dt, &
        !                           up_z, rho_full, up_rho, sum_up_aw, &
        !                           thv, sum_up_awthv, thvdt_mf, w1_thv1, varname)
  
        !--- compute tendency of ice-liquid water potential temperature, thli
        varname = "thli" 

!print*,'shflx_updated',shflx_updated
!print*,'w1_th1_surf_in_tend',w1_th1_surf_in_tend
        call mass_flux_tendencies (dt, is_mass_flux, &
                                   z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   thli, sum_up_awthli, thlidt_mf, w1_thli1, varname, &
                                   diff_phi = diff_t, w1_phi1_surf = w1_th1_surf_in_tend)
  
        !--- compute temperature tendency tdt_mf. Because thli_env = theta_env. Convert tdt from theta_env
        tdt_mf(:,:,:) = thlidt_mf(:,:,:)/ape(:,:,:)


!====================================
!
! Check for tracer realizability. If MF tendencies would
!  produce negative tracer mixing ratios, scale down tracer tendency
!  terms uniformly for this tracer throughout convective column.
!
!====================================

!--- initialze tend_ratio
tend_ratio = 1.

if (do_check_trc_rlzbility) then

  call check_trc_rlzbility (dt, qq, qdt_mf, &
                                tend_ratio)

  !print*,'before tdt_mf',tdt_mf*86400.
  !print*,'tend_ratio',tend_ratio

  do i=1,ix
  do j=1,jx
    if (tend_ratio(i,j) /= 1.) then
      udt_mf   (i,j,:) = udt_mf   (i,j,:) * tend_ratio(i,j)
      vdt_mf   (i,j,:) = vdt_mf   (i,j,:) * tend_ratio(i,j)
      qtdt_mf  (i,j,:) = qtdt_mf  (i,j,:) * tend_ratio(i,j)
      qdt_mf   (i,j,:) = qdt_mf   (i,j,:) * tend_ratio(i,j)
      thlidt_mf(i,j,:) = thlidt_mf(i,j,:) * tend_ratio(i,j)
      tdt_mf   (i,j,:) = tdt_mf   (i,j,:) * tend_ratio(i,j)
    endif
  enddo    ! end loop of j
  enddo    ! end loop of i

  !print*,'after tdt_mf',tdt_mf*86400.
endif ! end if of do_check_trc_rlzbility

!==============================
!
! write out to history files
!
!==============================

!------- zonal wind (units: m/s) at full level -------
  if ( id_uu > 0) then
    used = send_data (id_uu, uu, Time_next, is, js, 1 )
  endif

!------- meridional wind (units: m/s) at full level -------
  if ( id_vv > 0) then
    used = send_data (id_vv, vv, Time_next, is, js, 1 )
  endif

!------- temperature (units: K) at full level -------
  if ( id_tt > 0) then
    used = send_data (id_tt, tt, Time_next, is, js, 1 )
  endif

!------- speficic humidity (units: kg/kg) at full level -------
  if ( id_qq > 0) then
    used = send_data (id_qq, qq, Time_next, is, js, 1 )
  endif

!------- averaged vertical velocity (units: m/s) at half level -------
  if ( id_up_w > 0) then
    used = send_data (id_up_w, avg_up_w, Time_next, is, js, 1 )
  endif

!------- updraft area (units: none) at half level -------
  if ( id_up_a > 0) then
    used = send_data (id_up_a, sum_up_a, Time_next, is, js, 1 )
  endif

!------- updraft area*w (units: m/s) at half level -------
  if ( id_up_aw > 0) then
    used = send_data (id_up_aw, sum_up_aw, Time_next, is, js, 1 )
  endif

!------- updraft area*w*u (units: m2/s2) at half level -------
  if ( id_up_awu > 0) then
    used = send_data (id_up_awu, sum_up_awu, Time_next, is, js, 1 )
  endif

!------- updraft area*w*v (units: m2/s2) at half level -------
  if ( id_up_awv > 0) then
    used = send_data (id_up_awv, sum_up_awv, Time_next, is, js, 1 )
  endif

!------- updraft area*w*theta_v (units: K m/s) at half level -------
  if ( id_up_awthv > 0) then
    used = send_data (id_up_awthv, sum_up_awthv, Time_next, is, js, 1 )
  endif

!------- updraft area*w*qt (units: kg/kg m/s) at half level -------
  if ( id_up_awqt > 0) then
    used = send_data (id_up_awqt, sum_up_awqt, Time_next, is, js, 1 )
  endif

!------- updraft mass flux (units: kg/m2/s) at half level -------
  if ( id_up_massflux > 0) then
    used = send_data (id_up_massflux, sum_up_massflux, Time_next, is, js, 1 )
  endif

!------- u tendency from mass flux (units: m/s2) at full level -------
  if ( id_udt_mf > 0) then
    used = send_data (id_udt_mf, udt_mf, Time_next, is, js, 1 )
  endif

!------- v tendency from mass flux (units: m/s2) at full level -------
  if ( id_vdt_mf > 0) then
    used = send_data (id_vdt_mf, vdt_mf, Time_next, is, js, 1 )
  endif

!------- t tendency from mass flux (units: K/s) at full level -------
  if ( id_tdt_mf > 0) then
    used = send_data (id_tdt_mf, tdt_mf, Time_next, is, js, 1 )
  endif

!------- q tendency from mass flux (units: kg/kg/s) at full level -------
  if ( id_qdt_mf > 0) then
    used = send_data (id_qdt_mf, qdt_mf, Time_next, is, js, 1 )
  endif

!------- thv tendency from mass flux (units: K/s) at full level -------
  if ( id_thvdt_mf > 0) then
    used = send_data (id_thvdt_mf, thvdt_mf, Time_next, is, js, 1 )
  endif

!------- thli tendency from mass flux (units: K/s) at full level -------
  if ( id_thlidt_mf > 0) then
    used = send_data (id_thlidt_mf, thlidt_mf, Time_next, is, js, 1 )
  endif

!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
  if ( id_qtdt_mf > 0) then
    used = send_data (id_qtdt_mf, qtdt_mf, Time_next, is, js, 1 )
  endif

!------- w'thli' from mass flux (units: kg/kg/s) at half level -------
  if ( id_w1_thli1_mf > 0) then
    used = send_data (id_w1_thli1_mf, w1_thli1, Time_next, is, js, 1 )
  endif

!------- updraft averaged in-cloud total water (units: kg/kg) at half level -------
  if ( id_up_qt > 0) then
    used = send_data (id_up_qt, avg_up_qt, Time_next, is, js, 1 )
  endif

!------- updraft averaged in-cloud cloud water (units: kg/kg) at half level -------
  if ( id_up_qc > 0) then
    used = send_data (id_up_qc, avg_up_qc, Time_next, is, js, 1 )
  endif

!------- whether moist mass flux is present --- 
  if ( id_moist_massflux > 0) then
    used = send_data (id_moist_massflux, is_moist_massflux, Time_next, is, js)
  endif

!------- whether moist mass flux is present --- 
  if ( id_is_massflux > 0) then
    used = send_data (id_is_massflux, is_mass_flux, Time_next, is, js)
  endif

!------- MF tendency ratio due to tracer stability --- 
  if ( id_tend_ratio > 0) then
    used = send_data (id_tend_ratio, tend_ratio, Time_next, is, js)
  endif

!------- MF entrainment rate minimum (units: 1/m) at full level -------
  if ( id_ent_min > 0) then
    used = send_data (id_ent_min, ent_min, Time_next, is, js, 1 )
  endif

!------- MF entrainment rate maximum (units: 1/m) at full level -------
  if ( id_ent_max > 0) then
    used = send_data (id_ent_max, ent_max, Time_next, is, js, 1 )
  endif

!------- MF entrainment rate mean (units: 1/m) at full level -------
  if ( id_ent_mean > 0) then
    used = send_data (id_ent_mean, ent_mean, Time_next, is, js, 1 )
  endif

!------------------------------
! write out profiles into the log file, fms.out
!------------------------------
  !--- write out profiles that have issues
  if (do_writeout_profile) then
    !--- loop for all i,j
    do i=1,ix
    do j=1,jx

      !--- write out the profile where tdt_mf > 2000 K/day
      !tt1 = maxval(abs(tdt_mf(i,j,:)))*86400.
      !if (tt1.gt.2000.) then   ! if tdt_mf > 2000 K/day

      tt1 = 0.             ! write out all
      if (tt1.eq.0.) then   

        write(6,*)    '!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
        write(6,*)    '! is,ie,js,je',is,ie,js,je 
        write(6,*)    '! i,j,',i,j
        write(6,*)    '! is_mass_flux',is_mass_flux(i,j)
        write(6,*)    '! is_moist_updraft',is_moist_updraft(:,i,j)
        write(6,*)    '!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
        write(6,*)    '' 
        write(6,*)    '' 
        !write(6,*)    'Time_next,days,seconds'
        !write(6,*)    Time_next%days, Time_next%seconds   ! compiler error when I want to write Time_next
        !write(6,*)    'i,j,',i,j
        write(6,*)    '! tdt_mf,',tdt_mf(i,j,:)*86400.
        write(6,*)    '! sum_up_massflux,',sum_up_massflux(i,j,:)
        write(6,*)    '! w1_thli1', w1_thli1(i,j,:)
        write(6,*)    ''
        write(6,*)    '!================='
        write(6,*)    '! Description'
        write(6,*)    '! A profile taken from GFDL CM4 AMIP run that the mass flux program has trouble'
        write(6,*)    '!'
        write(6,*)    '! Yi-Hsuan Chen'
        write(6,*)    '!================='
        write(6,*)    ''
        write(6,*)    '!==================='
        write(6,*)    '!==================='
        write(6,*)    '!  Input profiles'
        write(6,*)    '!==================='
        write(6,*)    '!==================='
        write(6,*)    ''
        write(6,*)    '! pressure at half level (Pa)'
        write(6,3001) 'data p_half/',p_half(i,j,:)
        write(6,*)    ''
        write(6,*)    '! height at half level above the surface (m)'
        write(6,3001) 'data z_half/',z_half(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! pressure at full level (Pa)'
        write(6,3001) 'data p_full/',p_full(i,j,:)
        write(6,*)    ''
        write(6,*)    '! height at full level above the surface (m)'
        write(6,3001) 'data z_full/',z_full(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! actual height at half level (m)'
        write(6,3001) 'data z_half_actual/',z_half(i,j,:)
        write(6,*)    ''
        write(6,*)    '! actual height at full level (m)'
        write(6,3001) 'data z_full_actual/',z_full(i,j,:)
        write(6,*)    ''
        write(6,*)    '! zonal wind velocity at full levels (m/s)'
        write(6,3001) 'data uu/'    ,uu(i,j,:)
        write(6,*)    ''
        write(6,*)    '! meridional wind velocity at full levels (m/s)'
        write(6,3001) 'data vv/'    ,vv(i,j,:)
        write(6,*)    ''
        write(6,*)    '! temperatur at full levels (K)'
        write(6,3001) 'data tt/'    ,tt(i,j,:)
        write(6,*)    ''
        write(6,*)    '! specific humidity at full levels (kg/kg)'
        write(6,3002) 'data qq/'    ,qq(i,j,:)
        write(6,*)    ''
        write(6,*)    '! potential temperature at full levels (K)'
        write(6,3001) 'data th/'    ,th(i,j,:)
        write(6,*)    ''
        if (present(diff_t)) then
          write(6,*)    ''
          write(6,*)    '! diffusion coefficient of heat (m2/s) at half levels'
          write(6,3004) 'data diff_t/', diff_t(i,j,:),'0,'
        endif
        if (present(diff_m)) then 
          write(6,*)    ''
          write(6,*)    '! diffusion coefficient of momentum (m2/s) at half levels'
          write(6,3004) 'data diff_m/', diff_m(i,j,:),'0,'
        endif
        write(6,*)    ''
        write(6,*)    '! PBL depth (m)'
        write(6,3000) 'data z_pbl/' ,z_pbl(i,j)
        write(6,*)    ''
        write(6,*)    '! buoyancy flux (m2/s3)'
        write(6,3003) 'data buoy_flux/',u_star(i,j)*b_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface heat flux, w1_thv1 (K m/s)'
        write(6,3003) 'data w1_thv1_surf/',w1_thv1_surf(i,j)  !u_star(i,j) * b_star(i,j) * thv(i,j,kx)/g
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux (K m/s)'
        write(6,3003) 'data w1_th1_surf/',w1_th1_surf(i,j)  
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux used in tend calculation (K m/s)'
        write(6,3003) 'data w1_th1_surf_in_tend/',w1_th1_surf_in_tend(i,j)  
        write(6,*)    ''
        write(6,*)    '! surface moisture flux (kg/kg m/s'
        write(6,3003) 'data w1_qt1_surf/',w1_qt1_surf(i,j) !u_star(i,j) * q_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface sensible heat flux diagnosed from star values (W/m2)'
        write(6,3003) 'data shflx_star/',shflx_star(i,j)
        write(6,*)    ''
        write(6,*)    '! surface evaporation flux diagnosed from star values (kg/m2/s)'
        write(6,3003) 'data evap_star/',evap_star(i,j)
        write(6,*)    ''
        write(6,3000) 'data u_star/',u_star(i,j)
        write(6,3003) 'data b_star/',b_star(i,j)
        write(6,3003) 'data q_star/',q_star(i,j)
        write(6,*)    ''
        write(6,*)    '!======================================='
        write(6,*)    '!======================================='
        write(6,*)    '!  Output from the mass flux program'
        write(6,*)    '!======================================='
        write(6,*)    '!======================================='
        write(6,*)    ''
        write(6,*)    '! ------------------------------------'
        !write(6,*)    '! option_solver  : ',option_solver
       ! write(6,*)    '!  do_IMPtend_MF : ',do_IMPtend_MF
       ! write(6,*)    '!  do_IMPtend_ED : ',do_IMPtend_ED
       ! write(6,*)    '!  do_IMPtend_include_surf_flux: ',do_IMPtend_include_surf_flux
        !write(6,*)    '! do_MF_explicit        : ',do_MF_explicit
        !write(6,*)    '! do_MF_implicit        : ',do_MF_implicit
        !write(6,*)    '! do_ED_explicit        : ',do_ED_explicit
        !write(6,*)    '! do_ED_implicit        : ',do_ED_implicit
        write(6,*)    '! option_MF_numerics    : ',option_MF_numerics
        write(6,*)    '! option_ED_numerics    : ',option_ED_numerics
        write(6,*)    '! do_include_surf_flux  : ',do_include_surf_flux
        write(6,*)    '! option_surface_flux   : ',option_surface_flux
        !write(6,*)    '! do_use_updated_shflx  : ',do_use_updated_shflx
        write(6,*)    '! option_MF_env_half    : ',option_MF_env_half
        write(6,*)    '! do_check_trc_rlzbility: ',do_check_trc_rlzbility
        write(6,*)    '!   tend_ratio          : ',tend_ratio(i,j) 
        write(6,*)    '! dt                    : ',dt
        write(6,*)    '! ------------------------------------'
        write(6,*)    ''
        write(6,*)    '! height level of updraft (m)'
        write(6,3001) 'data up_z/',up_z(i,j,:) - z_half(i,j,kxp)
        write(6,*)    ''
        write(6,*)    '! sum of updraft mass flux (kg/m2/s) at half level'
        write(6,3002) 'data sum_up_massflux /'    ,sum_up_massflux(i,j,:)
        write(6,*)    ''
        write(6,*)    '! averaged updraft velocity (m/s) at half levels'
        write(6,3001) 'data avg_up_w /'    ,avg_up_w(i,j,:)
        write(6,*)    ''
        write(6,*)    '! heat flux w1_theta_li1 (K m/s) at half level'
        write(6,3002) 'data w1_thli1 /'    ,w1_thli1(i,j,:)
        write(6,*)    ''
        write(6,*)    '! ice-liquid potential temperature tendency (K/day) at full level'
        write(6,3001) 'data thlidt_mf /'    ,thlidt_mf(i,j,:)*86400.
        write(6,*)    ''
        write(6,*)    '! temperature tendency (K/day) at full level'
        write(6,3001) 'data tdt_mf /'    ,tdt_mf(i,j,:)*86400.
        write(6,*)    ''
        write(6,*)    '! specific humidity tendency (kg/kg/s) at full level'
        write(6,3002) 'data qdt_mf /'    ,qdt_mf(i,j,:)
        write(6,*)    ''
        write(6,*)    '! averaged updraft specific humidity (kg/kg) at half level'
        write(6,3002) 'data avg_up_qt /'    ,avg_up_qt(i,j,:)
        write(6,*)    ''
        write(6,*)    '! ratio from check_tracer_realizability'
        write(6,3003) 'data tend_ratio /',tend_ratio(i,j)

        write(6,*)    ''
        write(6,*)    '!-----------------------------'
        write(6,*)    '!  Some vi commands'
        write(6,*)    '!-----------------------------'
        write(6,*)    ''
        write(6,*)    '!*** Fortran'
        write(6,*)    '! remove the space at the beginning       : [1,$s/^ */  /g]'
        write(6,*)    '! replace ",$" to "/" at the end          : [1,$s/,$/\//g]'
        write(6,*)    ''
        write(6,*)    '!*** NCL '
        write(6,*)    '! remove the space at the beginning       : [1,$s/^ */  /g]'
        write(6,*)    '! remove data                             : [1,$s/data //g]'
        write(6,*)    '! replace "/" to "=(/"                    : [1,$s/\/  / = (\//g]'
        write(6,*)    '! replace "," to "/" at the end           : [1,$s/,$/\/)/g]'
        write(6,*)    '! replace "!" to ";"                      : [1,$s/!/;/g]'
        write(6,*)    ''

      endif  ! end if of tt1
    enddo
    enddo

    if (do_stop_run) then
      call error_mesg(' mass_flux_mod',' end do_writeout_profile: stop', FATAL )
    end if
  end if  ! end if of do_writeout_profile

!**********************************************************
!**********************************************************
!****   check part   **************************************
!**********************************************************
!**********************************************************

  if ( do_printouts ) then

      !  write out to the log file, fms.out
       write(6,*) 'Tend_mf tendencies'
       write(6,*) ''
      !i=is
      !j=js
      i=11
      j=5
      write(6,*) 'i,j,tt',tt(i,j,:)
      write(6,*) 'i,j,qq',qq(i,j,:)

       write(6,*) '------------------------------------'
       write(6,*) 'i,j,u*,b*,q*,z_pbl',i,j,u_star(i,j),b_star(i,j),q_star(i,j),z_pbl(i,j)
       write(6,*) 'i,j,u*',i,j,u_star(i,j)
       write(6,*) 'i,j,b*',i,j,b_star(i,j)
       write(6,*) 'i,j,q*',i,j,q_star(i,j)
       write(6,*) 'i,j,z_pbl',i,j,z_pbl(i,j)
       write(6,*) '------------------------------------'
      do kk=1,kxp
         write(6,*) 'kk,z',kk,z_half(i,j,kk)
         write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
         write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,kk)
         write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,kk)
         write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,kk)
         write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,kk)
         write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,kk)
         write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

      do kk=1,kx
         write(6,*) 'kk,z',kk,z_full(i,j,kk)
         write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,kk)
         write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,kk)
         write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,kk)
         write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,kk)
         write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,kk)
         write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,kk)
         write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

    !call error_mesg(' mass_flux_mod',' end do_mass_flux: stop', FATAL )

  endif  ! end if of do_printouts

!------------------
! printout 
!------------------
do_check_printouts = ""
!do_check_printouts(1) = "up_qt_qc"
!do_check_printouts(2) = "qtdt_mf"
!do_check_printouts(1) = "sum_up"
!do_check_printouts(6) = "each_up"
!do_check_printouts(2) = "sum_up"
!do_check_printouts(3) = "dt_mf"
!do_check_printouts(4) = "w1_phi1"
!do_check_printouts(5) = "is_mass_flux"
!do_check_printouts = ""

kk=22  ! smallest k index
i=is  ! i index
j=js  ! j index

do ii1=1,10
  !-----------
  if (do_check_printouts(ii1).eq."is_mass_flux") then
    print*,''
    print*,'================================'
    print*,'is_mass_flux',is_mass_flux(i,j)
    print*,'is_moist_updraft',is_moist_updraft(:,i,j)
  endif

  !-----------
  if (do_check_printouts(ii1).eq."up_qt_qc") then
    print*,''
    print*,'================================'
    ! print out qt,qc
    do n=1,nx
      print*,'----- updraft ',n,' -----'
      do k=kk,kx
        print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
      enddo
    enddo
  
    !print*,'**********************'
    !print*,'base RH',rh_flag111
    !print*,'is_moist_massflux',is_moist_massflux
    !print*,'avg_up_qc',avg_up_qc
  endif 

  !-----------
  if (do_check_printouts(ii1).eq."qtdt_mf") then
    print*,''
    print*,'================================'
    print*,'qtdt_mf',qtdt_mf
  endif

  !-----------
  if (do_check_printouts(ii1).eq."sum_up") then
    print*,''
    print*,'================================'
    do k=kk,kxp
       write(6,*) 'k,z',k,z_half(i,j,k)
       write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
       write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,k)
       write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,k)
       write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,k)
       write(6,*) '   sum_up_awq,      ', sum_up_awq  (i,j,k)
       write(6,*) '   sum_up_awqt,     ', sum_up_awqt (i,j,k)
       write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,k)
       write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,k)
       write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,k)
       write(6,*) '   w1_thli1,        ', w1_thli1(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."dt_mf") then
    print*,''
    print*,'================================'
    do k=kk,kx
       write(6,*) 'k,z',k,z_full(i,j,k)
       write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,k)
       write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,k)
       write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,k)
      ! write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,k)
       write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,k)
       write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,k)
       write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."each_up") then
    print*,''
    print*,'================================'
    do n=1,nx
      print*,''
      !print*,'----- updraft ',n,' -----'
      print*,'***************************'
      print*,'*****   updraft ',n,' *****'
      print*,'***************************'
      !do k=1,kxp
      do k=kk,kxp
         write(6,*) 'n,k,z',n,k,z_half(i,j,k)
         write(6,*) '   ent              ', ent(n,k)
         write(6,*) '   each_up_thli     ', each_up_thli(n,i,j,k)
         write(6,*) '   each_up_qt       ', each_up_qt  (n,i,j,k)
         write(6,*) '   each_up_qc       ', each_up_qc  (n,i,j,k)
         write(6,*) '------------------------------------'
      enddo
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."w1_phi1") then
    print*,''
    print*,'================================'
      do k=kk,kxp
         write(6,*) 'k,z',k,z_half(i,j,k)
         write(6,*) '   w1_qt1           ', w1_qt1  (i,j,k)
         write(6,*) '   w1_q1            ', w1_q1  (i,j,k)
         write(6,*) '   w1_thli1            ', w1_thli1  (i,j,k)
         write(6,*) '------------------------------------'
      enddo
  endif
enddo  ! end do of ii1


!print*,'filter_massflux,',filter_massflux
!print*,'is_moist_updraft',is_moist_updraft
!print*,'is_moist_massflux',is_moist_massflux

!    print*,''
!    print*,'**********************'
!    print*,'base RH',rh_flag111
!    print*,'is_moist_massflux',is_moist_massflux
!    print*,'**********************'
!    print*,''

!------------------
!check mass/energy conservation
!------------------
!do_check_consrv = .true.
do_check_consrv = .false.

if (do_check_consrv) then
  !*** check qt ***
  tt1 = 0.
  tt2 = 0.

  i=1
  j=1 
  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + qt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (qtdt_mf(i,j,k)*dt+qt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_qt, new_qt, rho, dz',qt(i,j,k),(qtdt_mf(i,j,k)*dt+qt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  qtdt_mf',qtdt_mf(i,j,k)
  enddo

  print*,''
  !print*,'option_solver: ',option_solver
  print*,'old qt (kg/m2), ',tt1
  print*,'new qt (kg/m2), ',tt2
  print*,'-----------------------------------------'

!*** check dry static energy ***
  tt1 = 0.
  tt2 = 0.

  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_tt, new_tt, rho, dz',tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  tdt_mf',tdt_mf(i,j,k)
  enddo

  print*,''
  !print*,'option_solver: ',option_solver
  print*,'column old energy, integral(rho*T*dz), ',tt1,', (times Cp to convert to J)'
  print*,'column new energy, integral(rho*T*dz), ',tt2,', (times Cp to convert to J)'
end if ! end if of do_check_consrv

!-----------------------------------------------------------
!  write out values of each updraft for NCL plotting use
!-----------------------------------------------------------

do_printout_ncl = .false.
!do_printout_ncl = .true.

if (do_printout_ncl) then
  print*,''
  print*,';---------------------------'
  print*,'; data source: '
  print*,';   ',data_source
  print*,';   dt=',dt
  print*,''
  print*,';    remove the space at the beginning	: [1,$s/^ */  /g]'
  print*,';    add "/)" at the end              	: [1,$s/$/\/)/g]'
  print*,';    add comma            		: [1,$s/   /,  /g]'
  print*,';    replace (/, with (/  		: [1,$s/\/,/\//g]'
  print*,';    replace ", ," to "," 		: [1,$s/, *,/,/g]'
  print*,';    replan then/) to then		: [1,$s/then\/)/then/g]'
  print*,';    replan end if/) to end if	: [1,$s/end if\/)/end if/g]'
  print*,';---------------------------'
  print*,''
  print*,';  wks_name = ""'
  print*,';  data_source = ""'
  print*,''
  
  write(*,2001) 'p_half = (/',p_half/100.
  write(*,2001) 'z_half = (/',z_half
  write(*,2001) 'p_full = (/',p_full/100.
  write(*,2001) 'z_full = (/',z_full
  write(*,1001) 'tt = (/',tt
  write(*,1001) 'thli = (/',thli
  write(*,1001) 'uu = (/',uu
  write(*,1001) 'vv = (/',vv
  write(*,1000) 'qq = (/',qq
  
  i=1
  j=1
  phi_half(1) = thli(i,j,1)
  do k=2,kx
    phi_half(k) = 0.5* (thli(i,j,k) + thli(i,j,k-1))
  enddo
  !write(*,1001) 'thli_env_half = (/',phi_half
  
!  do n=1,nx
!    write(*,1002) 'each_up_thv (',n-1,',:) = (/',each_up_thv(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1002) 'each_up_w (',n-1,',:) = (/',each_up_w(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_a (',n-1,',:) = (/',each_up_a(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_massflux (',n-1,',:) = (/',each_up_massflux(n,i,j,:)
!  enddo
  
  !write(*,1000) 'sum_up_aw = (/',sum_up_aw
  !write(*,1000) 'sum_up_awthv = (/',sum_up_awthv
  write(*,1001) 'avg_up_w = (/',avg_up_w
  write(*,1000) 'sum_up_massflux = (/',sum_up_massflux
  write(*,1000) 'w1_thli1 = (/',w1_thli1
  write(*,1000) 'tdt_mf = (/',tdt_mf*86400.  ! K/day
end if ! end if of do_printout_ncl
!
!*** check sum and each updraft ***
!  i=1
!  j=1
!  do k=1,kxp
!    !print*,'k=',k,', sum_up_a,',sum_up_a(i,j,k),', each_up_a,',each_up_a(:,i,j,k)
!    !print*,'k=',k,', avg_up_w,',avg_up_w(i,j,k),', each_up_w,',each_up_w(:,i,j,k)
!    !print*,'k=',k,', sum_up_massflux,',sum_up_massflux(i,j,k),', each_up_massflux,',each_up_massflux(:,i,j,k)
!    print*,'k=',k,', sum_up_awthv,',sum_up_awthv(i,j,k),', each_up_awthv,',each_up_awthv(:,i,j,k)
!  enddo
!
1000 format (A25,40(E12.4,2X))
1001 format (A25,40(F8.3,2X))
1002 format (A25,I2,A10,40(F8.3,2X))
1003 format (A25,I2,A10,40(E12.4,2X))
2001 format (A25,40(F12.3,2X))
3000 format (A25,2X,F8.2,',')
3001 format (A25,2X,34(F10.3,2X,','))
3002 format (A25,2X,34(E12.4,2X,','))
3003 format (A25,2X,E12.4,',')
3004 format (A25,2X,33(F10.3,2X,','),A5)

end subroutine mass_flux

!#######################################################################
! subroutine mass_flux_tendencies
!
!*************
! Purpose:
!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, <w'phi'>.
!
!*************
! Numerical discretation:
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
!*************
! Equation:
!
!   The tendency equation is Eq (1) in Suselj et al. (2019b)
!
!         mean_phi(t+dt,k) - mean_phi(t,k)       w'phi'(t+dt/t,k+1) - w'phi'(t+dt/t,k)
!      -------------------------------------- = ---------------------------------------
!                      dt                                  dz
!
!   The treatment of <w'phi'> is Eq (7) in Suselj et al. (2019b)
!
!       mean_phi = uu, vv, tt, or qt
!       mean_w   = 0.
!
!       w'phi'(t/t+dt,k) = sum [ up_area * (up_phi-mean_phi) * (up_w-0) ]
!                        = sum [ up_area(t,k) * ( up_phi(t,k) - 0.5(mean_phi(t+dt/t,k-1)+mean_phi(t+dt/t,k) ) * up_w(t,k) ]
!
!*************
! Solver for time-difference scheme:
!
!   The updraft properties are treated explicitly, i.e. evaluated at time=t.
!   The grid-scale phi can be treated explicitly or implicitly (evaluated at time=t+dt). If done implicitly, it can be called
!   semi-implicit scheme, 
!      "In this solver, the large-scale horizontal advection and source terms are
!      treated explicitly (i.e., they are taken at the time, t), whereas the
!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!      subgrid fluxes are treated semi-implicitly." (Appendix A, Suselj et al., 2019b)
!
!   There are two solver options in this subroutine: "explicit" and "implicit". 
!     "Explicit" option evaluates all terms on the right-hand side of Eq (1) at time t, which are known. The only unknown term is
!     mean_phi(t+dt,k), which can be then solved directly.
!
!     "Implicit" evaluates all terms on the right-hand side of Eq (1) at time t except the mean_phi terms, which are evaluated at
!     t+dt. As a result, a set of linear euqations of unknown variables, mean_phi(t+dt,k), will show up. 
!     These equations are solved by the Tridiagonal matrix algorithm. Wiki has a detailed explanation about this algorithm: 
!     https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm 
!
!      --- Tridiagonal matrix algorithm ---
!      a,b,c - are coefficients on the LHS
!      d     - is initially RHS on the output becomes a solution vector
!
!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!      [ a1,  0, an, bn   ]   [xn]    [dn]
!
!      a1=0 and cn=0
!
!*************
! History:
!   2020/06/21 Copy from the subroutine OUTDATED_massflux_tendencies and modify
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
!*************
! References:
!   Suselj et al. (2014, WAF):
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS):
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1
!
!-------------------------------------------------------------------- 

subroutine mass_flux_tendencies (dt, is_mass_flux, &
                                 z_half, z_full, rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                 phi, sum_up_awphi, phidt_return, w1_phi1, varname, &
                                 diff_phi, w1_phi1_surf)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    option_solver -  solver to obtain the tendency. 'explicit' or 'implicit' only
!    varname       -  variable name for reference 
!    dt            -  Time step               (sec)
!    is_mass_flux  -  whether compute MF tendencies  (0: no, 1: yes) , dimension (nlon, nlat) 
!    z_half        -  Height at half levels   (meter)                , dimension (nlon, nlat, nlay+1)
!    z_full        -  Height at full levels   (meter)                , dimension (nlon, nlat, nlay)
!    rho_half      -  Air density at half levels (kg/m3)             , dimension (nlon, nlat, nlay+1)
!    rho_full      -  Air density at full levels   (kg/m3)           , dimension (nlon, nlat, nlay)
!    up_z          -  Updraft height levels   (meter)                , dimension (nlon, nlat, nlay+1)
!    up_rho        -  Air density at updraft levels (kg/m3)          , dimension (nlon, nlat, nlay+1)
!    sum_up_aw     - sum of the product of fractional area and vertical velocity for individual updraft
!                      i.e. a*w   (unit: m/s),                       , dimension (nlon, nlat, nlay+1)
!    phi           - a grid-mean variable (units_phi), e.g. u,v,t,q, , dimension (nlon, nlat, nlay)
!    sum_up_awphi  - sum of the product of fractional area, vertical velocity, and the variable phi for individual updraft
!                      i.e. a*w*phi (unit: m/s * units_phi)          , dimension (nlon, nlat, nlay+1)
!
!    diff_phi      - eddy-diffusion coefficients for phi (m2/s)      , dimension (nlon, nlat, nlay)
!                      note that this should be (nlon, nlat, nlay+1), but CM4 set it to (nlay), 
!                      though it doesn't matter in code and calculation
!    w1_phi1_surf  - surface flux of phi (phi_unit * m/s)            , dimension (nlon, nlat)
!---------------------------------------------------------------------

  character*20, intent(in)            :: varname
  real,  intent(in)                   :: dt

  real,  intent(in), dimension(:,:)   :: &  ! dimension (nlon, nlat)
    is_mass_flux

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
    z_full, rho_full, phi

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay+1)
    z_half, rho_half

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay+1)
    up_z, up_rho, sum_up_aw, sum_up_awphi

  real,  intent(in), optional, dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
    diff_phi

  real,  intent(in), optional, dimension(:,:) :: &  ! dimension (nlon, nlat)
    w1_phi1_surf

!---------------------------------------------------------------------
! Arguments (Intent out)
!
!    phidt_return  -  the tendency term of phi, i.e. dphi/dt,   dimension (nlon, nlat, nlay)
!    w1_phi1   -  the subgrid-scale flux  , i.e. w'phi'_bar
!---------------------------------------------------------------------
  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay)
    phidt_return

  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay+1)
    w1_phi1

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- working variables
  real, dimension(size(z_half,1),size(z_half,2),size(z_half,3)) :: &  ! dimension (nlon, nlat, nlay+1) 
    nu_phi,          &  ! nu term in eddy-diffusivity calculation. Ref: Eq (11) in GFDL vertical diffusion technical note 
    rho_flux_ED         ! air density * eddy flux (units: kg/m3 m/s unit_phi)

  real, dimension(size(up_z,1),size(up_z,2),size(up_z,3)) :: &  ! dimension (nlon, nlat, nlay+1) 
    rho_w1_phi1   ,  &    ! air density (kg/m3) * w'phi'
    rho_flux_MF   ,  &    ! air density * MF flux (units: kg/m3 m/s unit_phi)
    sum_up_raw    ,  &    ! air density (kg/m3) * sum_up_aw            , 'r' represents 'rho'
    sum_up_rawphi ,  &    ! air density (kg/m3) * sum_up_awphi         , 'r' represents 'rho'
    sum_env_rawphi        ! air density (kg/m3) * sum_up_aw * mean_phi , 'r' represents 'rho'

  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: &    ! dimension (nlon, nlat, nlay) 
    phidt_MF, phidt_ED, phidt_surf_flux, &
    env_rho               ! the air density between two adjacent updraft levels (kg/m3)

  real :: phidt_negative_max

  !--- working variables that the vertical indexing are reversed, i.e. k=1 becomes the lowermost level
  real, dimension(size(phi,3)) ::    &      ! dimension (nlay)
        phi_work, dz_work, rho_work, &
        mu_work, mu_prime_work      

  real, dimension(size(phi,3)+1) ::    &    ! dimension (nlay+1)
        nu_phi_work, &
        sum_up_raw_work, sum_up_rawphi_work

  real :: &
        w1_phi1_surf_work, rho_w1_phi1_surf_work

  !--- variables for the tridiag solver
  real, dimension(size(phi,3)) :: &  ! dimension (nlay)
        a_ED, b_ED, c_ED, d_ED,     &                 ! arrays for the tridiag solver
        a_impMF_cd, b_impMF_cd, c_impMF_cd, d_impMF_cd, &                   ! arrays for the tridiag solver
        a_impMF_uw_up, b_impMF_uw_up, c_impMF_uw_up, d_impMF_uw_up, &                   ! arrays for the tridiag solver
        a_impMF_uw_env, b_impMF_uw_env, c_impMF_uw_env, d_impMF_uw_env, &                   ! arrays for the tridiag solver
        a_expMF_cd, b_expMF_cd, c_expMF_cd, d_expMF_cd, &                   ! arrays for the tridiag solver
        a_expMF_uw, b_expMF_uw, c_expMF_uw, d_expMF_uw, &                   ! arrays for the tridiag solver
        a_work, b_work, c_work, d_work, &                   ! arrays for the tridiag solver
        a, b, c, d                   ! arrays for the tridiag solver

  !--- index variables 
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm

  !--- variables for check
  logical do_check_lhs_rhs
  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: & 
    phi_new
  real lhs, rhs

!---------------------------

!--- set dimensions
  ix  = size( phi, 1 )
  jx  = size( phi, 2 )
  kx  = size( phi, 3 )
  kxp = kx + 1
  kxm = kx - 1

!--- initialize output variables
  phidt_return = 0.
  w1_phi1  = 0.

!--- initialize work variables 
  sum_up_raw   (:,:,:) = up_rho(:,:,:) * sum_up_aw   (:,:,:)
  sum_up_rawphi(:,:,:) = up_rho(:,:,:) * sum_up_awphi(:,:,:)
  sum_env_rawphi = 0.
  rho_flux_ed    = 0.

  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring
  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
  sum_up_raw   (:,:,kxp) = 0.
  sum_up_rawphi(:,:,kxp) = 0.

!--- set env_rho
  if (option_updraft_level.eq."full") then
    env_rho(:,:,1:kx) = rho_half(:,:,2:kxp)
  else
    env_rho(:,:,1:kx) = rho_full(:,:,1:kx)
  endif

!--- compute eddy-diffusivity term, nu_phi
  nu_phi = 0.           ! initialize to 0
  nu_phi(:,:,1)   = 0.  ! zero at model top
  nu_phi(:,:,kxp) = 0.  ! zero at the surface

  if (present(diff_phi)) then
    do i=1,ix
    do j=1,jx
    do k=2,kx
      nu_phi(i,j,k) = -diff_phi(i,j,k) * rho_half(i,j,k) / (z_full(i,j,k)-z_full(i,j,k-1))
    enddo
    enddo
    enddo
  else
    nu_phi = 0.
  end if

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho
!print*,'env_rho',env_rho
!stop

!***************************
!
!   solve the tendencies
!
!***************************

!---  loop of i,j
do i=1,ix
do j=1,jx

!===============================================
! explicit MF, no ED, surface flux can be included.
!
  !if (do_MF_explicit) then   
  if (option_MF_numerics .eq. "explicit") then   
!
!===============================================
      ! compute environmental flux in MF term, rho * a * w * mean_phi_at_half_levels
      sum_env_rawphi = 0.
      do k=2,kx
        if (option_MF_env_half.eq."upwind_env") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k-1)
        else if (option_MF_env_half.eq."upwind_updraft") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
        else if (option_MF_env_half.eq."centered-diff") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * 0.5*(phi(i,j,k-1)+phi(i,j,k))
        else
          call error_mesg(' mass_flux_mod',' option_MF_env_half must be : stop', FATAL )
        endif
  
        if (option_updraft_level.eq."full") then
          sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
        endif
      enddo

    !--- compute MF flux
    phidt_MF = 0.
    rho_flux_MF(:,:,1:kx) = sum_up_rawphi(:,:,1:kx) - sum_env_rawphi(:,:,1:kx)

    rho_w1_phi1 = 0.
    rho_w1_phi1(:,:,1:kx) = rho_flux_MF(:,:,1:kx)
    w1_phi1    (:,:,1:kx) = rho_flux_MF(:,:,1:kx)/up_rho  (:,:,1:kx) 

    !--- set surface flux 
    if (do_include_surf_flux .and. present(w1_phi1_surf)) then
      w1_phi1    (:,:,kxp) = w1_phi1_surf(:,:)
      rho_w1_phi1(:,:,kxp) = rho_half(:,:,kxp) * w1_phi1_surf(:,:)
    else
      w1_phi1    (:,:,kxp) = 0. 
      rho_w1_phi1(:,:,kxp) = 0. 
    end if

    !--- compute MF tendency
    do k=kx,1,-1
      phidt_MF    (i,j,k) = -1./env_rho(i,j,k) * (rho_flux_MF(i,j,k)-rho_flux_MF(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))
      phidt_return(i,j,k) = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))
    enddo

    !--- return MF tendency
    !phidt_return(:,:,:) = phidt_MF(:,:,:)

!    print*,'explicit MF'
!    print*,'w1_phi1_surf',w1_phi1_surf
!    write(6,3002) 'data phidt_MF/',phidt_MF
!    write(6,3002) 'data phidt_return/',phidt_return
!    write(6,3002) 'data phidt_MF/',phidt_MF*86400.

!===============================================
  endif  ! end if of do_MF_explicit
!===============================================

!===============================================
! explicit MF, explicit ED, surface flux can be included.
!
  !if (do_MF_explicit .and. do_ED_explicit) then   
  if (option_MF_numerics.eq."explicit" .and. option_ED_numerics.eq."explicit") then

!
!===============================================

    !--- intialize working arrays
    phidt_ED        = 0.
    phidt_MF        = 0.
    phidt_surf_flux = 0.

    !--- compute ED flux
    rho_flux_ED = 0.
    !if (do_ED_explicit .and. present(diff_phi)) then
    if (option_ED_numerics.eq."explicit" .and. present(diff_phi)) then
      do k=2,kx
        rho_flux_ED(i,j,k) = -diff_phi(i,j,k) * rho_half(i,j,k) / (z_full(i,j,k)-z_full(i,j,k-1)) &
                         * (phi(i,j,k)-phi(i,j,k-1))
      enddo
    endif

    !--- compute the ED+MF flux
    rho_w1_phi1 = 0.
    rho_w1_phi1(i,j,1:kx) =   rho_flux_ED(i,j,1:kx)   &
                            + rho_flux_MF(i,j,1:kx) 

    w1_phi1    (i,j,1:kx) =   rho_flux_ED(i,j,1:kx)/rho_half(i,j,1:kx)  &
                            + rho_flux_MF(i,j,1:kx)/up_rho  (i,j,1:kx) 

!print*,'z_half',z_half
!print*,'z_full',z_full
!print*,'rho_half',rho_half
!print*,'rho_full',rho_full
!print*,'rho_flux_ED',rho_flux_ED
!print*,'rho_flux_MF',rho_flux_MF
!print*,'sum_up_aw',sum_up_aw
!print*,'sum_env_rawphi',sum_env_rawphi
!print*,'sum_up_rawphi',sum_up_rawphi
!stop

    !--- set surface flux 
    if (do_include_surf_flux .and. present(w1_phi1_surf)) then
      w1_phi1    (i,j,kxp) = w1_phi1_surf(i,j)
      rho_w1_phi1(i,j,kxp) = rho_half(i,j,kxp) * w1_phi1_surf(i,j)
    else
      w1_phi1    (i,j,kxp) = 0. 
      rho_w1_phi1(i,j,kxp) = 0. 
    end if
!
    !--- compute dphi/dt
    phidt_surf_flux(i,j,kx) = -1./env_rho(i,j,kx) * (0.-rho_w1_phi1(i,j,kxp))   &
                                            / (up_z(i,j,kx) - up_z(i,j,kxp))

    do k=kx,1,-1
      phidt_ED    (i,j,k) = -1./rho_full(i,j,k) * (rho_flux_ED(i,j,k)-rho_flux_ED(i,j,k+1))  &
                                            / (z_half(i,j,k) - z_half(i,j,k+1))
      phidt_MF    (i,j,k) = -1./env_rho(i,j,k) * (rho_flux_MF(i,j,k)-rho_flux_MF(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))

      phidt_return(i,j,k) = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))

      !***************
      !***************
      !***************
      !***************
      ! NEED TO FIX. Need to think about how to avoid negative tracer concentration
      !***************
      !***************
      !***************
      !***************
      !--- compute the most negative dphi/dt so that phi isn't less than zero (e.g. total water specific humidity must be positive)
!      if (varname.eq."qt" .or. varname.eq."thli") then
!        phidt_negative_max = -phi(i,j,k)/dt
!
!        !--- if phidt_return < phidt_negative_max, modity phidt_return & rho_w1_phi1 at the top 
!        if (phidt_return(i,j,k) .le. phidt_negative_max) then
!          phidt_return(i,j,k) = phidt_negative_max
!  
!          !print*,'-----  ',varname,'-----'
!          !print*,'k,rho_w1_phi1(i,j,k),old',k,rho_w1_phi1(i,j,k)
!          rho_w1_phi1(i,j,k) = -phidt_return(i,j,k)*rho_env(i,j,k)*(up_z(i,j,k) - up_z(i,j,k+1)) & 
!                              + rho_w1_phi1(i,j,k+1)
!          !print*,'k,rho_w1_phi1(i,j,k),new',k,rho_w1_phi1(i,j,k)
!        end if  ! end if of phidt_return
!      endif     ! end if of varaname
    enddo

!    write(6,3002) 'data phidt_MF/',phidt_MF
!    write(6,3002) 'data phidt_ED/',phidt_ED
!    write(6,3002) 'data phidt_surf_flux/',phidt_surf_flux
!    write(6,3002) 'data phidt_return/',phidt_return
!    write(6,3002) 'data phidt_sum/',phidt_MF+phidt_ED+phidt_surf_flux
!stop

!===============================================
  endif  ! end if of do_MF_explicit .and. .not.do_ED_implicit
!===============================================

  !===============================================
  ! implicit ED, implicit or explicit MF, surface flux can be included
  !   note that if both do_ED_explicit and do_ED_implicit are .false., ED terms are zeros,
  !   which means this would be the same as implicit or explicit MF
  !
  !if (.not.do_ED_explicit) then  ! Implicit solver
  !if (.not.option_ED_numerics.eq."explicit") then  ! Implicit solver
  if (option_ED_numerics.eq."implicit") then  ! Implicit solver
  !
  !===============================================
  
      !--- set working variables for the solver 
      do k=1,kx
        !kk=kx-k+1
        kk=k
        phi_work (kk) = phi(i,j,k)
        dz_work  (kk) = up_z(i,j,k+1) - up_z(i,j,k)
        rho_work (kk) = env_rho(i,j,k)
        mu_work  (kk) = -1./ rho_work(kk) / dz_work(kk)
        mu_prime_work(kk) = dt * mu_work  (kk)      ! = dt * g/dp if hydrostatic approximation is valid
      enddo
 
      !--- whether including MF in the solver
      !if (do_MF_implicit .or. do_MF_explicit) then
      if (option_MF_numerics.eq."explicit" .or. option_MF_numerics.eq."implicit") then
        sum_up_raw_work   (:) = sum_up_raw   (i,j,:)
        sum_up_rawphi_work(:) = sum_up_rawphi(i,j,:)
      else
        sum_up_raw_work   (:) = 0. 
        sum_up_rawphi_work(:) = 0. 
      endif
  
      !--- whether including ED in the solver
      !if (do_ED_implicit) then
      if (option_ED_numerics.eq."implicit") then
        nu_phi_work (:) = nu_phi (i,j,:)
      else
        nu_phi_work (:) = 0.
      endif
 
!print*,'do_ED_implicit',do_ED_implicit
!print*,'nu_phi',nu_phi
!print*,'yaya1'
!stop

 
      !--- whether including surface flux in the solver
      if (do_include_surf_flux .and. present(w1_phi1_surf)) then
        w1_phi1_surf_work     = w1_phi1_surf(i,j)
        rho_w1_phi1_surf_work = rho_half(i,j,kxp) * w1_phi1_surf(i,j)
      else
        w1_phi1_surf_work     = 0.
        rho_w1_phi1_surf_work = 0.
      endif
      w1_phi1    (i,j,kxp) = w1_phi1_surf_work
      rho_w1_phi1(i,j,kxp) = rho_w1_phi1_surf_work
  
     !*******************************************************
     !*******************************************************
     !
     ! set tridiag matrix coefficients for the ED part: 
     !   a_ED, b_ED, c_ED
     ! 
     !*******************************************************
     !*******************************************************
     a_ED = 0.
     b_ED = 1.
     c_ED = 0.
  
     !if (do_ED_implicit) then
     if (option_ED_numerics.eq."implicit") then
  
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(1) =   1.   &
                    + mu_prime_work(k)*nu_phi_work(k+1)         ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(1) = - mu_prime_work(k)*nu_phi_work(k+1)            ! ED term
  
        !--- other levels
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(k) = - mu_prime_work(k)*nu_phi_work(k)            ! ED term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(k) =   1.   &
                    + mu_prime_work(k)*nu_phi_work(k+1) + mu_prime_work(k)*nu_phi_work(k)     ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(k) = - mu_prime_work(k)*nu_phi_work(k+1)            ! ED term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_ED(kx) = - mu_prime_work(k)*nu_phi_work(k)           ! ED term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_ED(kx) =   1. &
                    +  mu_prime_work(k)*nu_phi_work(k)           ! ED term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_ED(kx) = 0.

!print*,'mu_prime_work',mu_prime_work 
!print*,'nu_phi_work', nu_phi_work
!print*,'a_ED',a_ED
!print*,'b_ED',b_ED
!print*,'c_ED',c_ED
!stop 

     endif  ! end if of do_ED_implicit
  
     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, centered-difference
     !    a_impMF_cd, b_impMF_cd, c_impMF_cd
     !
     !*******************************************************
     !*******************************************************
     a_impMF_cd = 0.
     b_impMF_cd = 0.
     c_impMF_cd = 0.
     d_impMF_cd = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."centered-diff") then 
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."centered-diff") then 
       !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(1) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1))       ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(1) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
    
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(k) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)     ! MF term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(k) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(k) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_cd(kx) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)    ! MF term 
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_cd(kx) = - 0.5*mu_prime_work(k)*sum_up_raw_work(k)    ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_cd(kx) = 0.
  
        !************************
        ! solve ED + implicit MF_centered-difference
        !************************

        !--- set tridiagnoal matrxi coefficients
        a_work(:) = a_ED(:) + a_impMF_cd(:)
        b_work(:) = b_ED(:) + b_impMF_cd(:)
        c_work(:) = c_ED(:) + c_impMF_cd(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work   ! surface flux term
  
!  print*,'phi_work(k)',phi_work(k)
!  print*,'mu_prime_work(k)*sum_up_rawphi_work(k)',mu_prime_work(k)*sum_up_rawphi_work(k)
!  print*,'mu_prime_work(k)*rho_w1_phi1_surf_work',mu_prime_work(k)*rho_w1_phi1_surf_work
!  print*,'mu_prime_work(k)',mu_prime_work(k)
!  print*,'rho_w1_phi1_surf_work',rho_w1_phi1_surf_work
!  print*,'a_work',a_work
!  print*,'b_work',b_work
!  print*,'c_work',c_work
!  print*,'d_work',d_work
  !stop
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
       !--- get phi_new and phidt_return
       do k=1,kx
         phi_new  (i,j,k) = d_work(k)
         phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
       enddo
   
       !--- retrieve fluxes
       rho_w1_phi1(:,:,1) = 0.
       w1_phi1    (:,:,1) = 0.
    
       do k=2,kx
         sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * 0.5 * (phi_new(i,j,k)+phi_new(i,j,k-1))
         rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
         rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                 + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
    
         w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                 + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
       enddo
    
     endif  ! end if of do_MF_implicit .and. option_MF_env_half.eq."centered-diff"

     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, upwind_env-difference
     !    a_impMF_uw_env, b_impMF_uw_env, c_impMF_uw_env, d_impMF_uw_env
     !
     !*******************************************************
     !*******************************************************
     a_impMF_uw_env = 0.
     b_impMF_uw_env = 0.
     c_impMF_uw_env = 0.
     d_impMF_uw_env = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."upwind_env") then
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."upwind_env") then
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(1) = mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(1) = 0.       ! MF term
    
          !! a, the coefficient of phi_bar(t+dt,k-1)
          !a_impMF_cd(k) = - mu_prime_work(k)*0.5*sum_up_raw_work(k)     ! MF term
  
          ! b, the coefficient of phi_bar(t+dt,k)
          !b_impMF_cd(k) = 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          !c_impMF_cd(k) = mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(k) = - mu_prime_work(k)*sum_up_raw_work(k)
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(k) = mu_prime_work(k)*sum_up_raw_work(k+1)                                      ! MF term
                 !+ 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(k) = 0.
                 !+ mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_env(kx) = - mu_prime_work(k)*sum_up_raw_work(k)
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_env(kx) = 0.                                     ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_env(kx) = 0.
  
        !-----------------------------------
        ! set tridiag matrix coefficients: a,b,c,d
        !-----------------------------------
        a_work(:) = a_ED(:) + a_impMF_uw_env(:)
        b_work(:) = b_ED(:) + b_impMF_uw_env(:)
        c_work(:) = c_ED(:) + c_impMF_uw_env(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels 
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work
  
  !print*,'a_work',a_work
  !print*,'b_work',b_work
  !print*,'c_work',c_work
  !print*,'d_work',d_work
  !stop
  
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
     
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.
     
        do k=2,kx
          sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * phi_new(i,j,k-1)
          rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
          rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                  + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
          w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                  + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
        enddo
  
     endif ! end if of do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft"
    

     !*******************************************************
     !*******************************************************
     !
     !  set tridiag matrix coefficients for the implicit MF, upwind_updraft-difference
     !    a_impMF_uw_up, b_impMF_uw_up, c_impMF_uw_up, d_impMF_uw_up
     !
     !*******************************************************
     !*******************************************************
     a_impMF_uw_up = 0.
     b_impMF_uw_up = 0.
     c_impMF_uw_up = 0.
     d_impMF_uw_up = 0.
  
     !if (do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft") then
     if (option_MF_numerics.eq."implicit" .and. option_MF_env_half.eq."upwind_updraft") then
        !--- k=1, the uppermost level of the model
        k=1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(1) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(1) = - mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(1) = mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
    
        !--- other levels 
        do k=2,kx-1
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(k) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(k) = - mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
                 !+ 0.5*mu_prime_work(k)*(sum_up_raw_work(k+1)-sum_up_raw_work(k))           ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(k) = + mu_prime_work(k)*sum_up_raw_work(k+1)     ! MF term
                 !+ mu_prime_work(k)*0.5*sum_up_raw_work(k+1)     ! MF term
        enddo
    
        !--- k=kx, the lowewrmost level of the model
        k=kx
  
          ! a, the coefficient of phi_bar(t+dt,k-1)
          a_impMF_uw_up(kx) = 0.
  
          ! b, the coefficient of phi_bar(t+dt,k)
          b_impMF_uw_up(kx) = -  mu_prime_work(k)*sum_up_raw_work(k)                                      ! MF term
  
          ! c, the coefficient of phi_bar(t+dt,k+1)
          c_impMF_uw_up(kx) = 0.
  
        !-----------------------------------
        ! set tridiag matrix coefficients: a,b,c,d
        !-----------------------------------
        a_work(:) = a_ED(:) + a_impMF_uw_up(:)
        b_work(:) = b_ED(:) + b_impMF_uw_up(:)
        c_work(:) = c_ED(:) + c_impMF_uw_up(:)
        d_work(:) = 0 ! initialze working array
  
        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*sum_up_rawphi_work(k+1)
  
        !--- other levels 
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo
  
        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*sum_up_rawphi_work(k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work
  
  !print*,'a_work',a_work
  !print*,'b_work',b_work
  !print*,'c_work',c_work
  !print*,'d_work',d_work
  !stop
  
        !-----------------------------------------
        ! call tridiag matrix and compute w'phi' 
        !-----------------------------------------
        call tridiag(kx,a_work,b_work,c_work,d_work)
  
        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
     
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.
     
        do k=2,kx
          sum_env_rawphi(i,j,k) = sum_up_raw_work(k) * phi_new(i,j,k)
          rho_flux_ed   (i,j,k) = nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
          rho_w1_phi1   (i,j,k) =   rho_flux_ed(i,j,k) &
                                  + sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k)
          w1_phi1       (i,j,k) =   rho_flux_ed(i,j,k)/rho_half(i,j,k) &
                                  + (sum_up_rawphi_work(k) - sum_env_rawphi(i,j,k))/up_rho(i,j,k)
        enddo
  
     endif ! end if of do_MF_implicit .and. option_MF_env_half.eq."upwind_updraft"
  
     !*******************************************************
     !*******************************************************
     ! 
     !  set tridiag matrix coefficients for the explicit MF, 
     !    rho_flux_MF is calculated in previous do_explicit_MF, 
     !    which already used centered-difference or upwind_updraft-difference 
     ! 
     !*******************************************************
     !*******************************************************
  
     !if (do_MF_explicit .and. .not.do_MF_implicit) then
     !if (.not.do_MF_implicit) then
     if (.not. option_MF_numerics.eq."implicit") then

        !--- no MF, i.e. ED only
        !if (.not.do_MF_explicit) then
        if (.not. option_MF_numerics.eq."explicit") then
          rho_flux_MF = 0.
        endif

        !--- set tridiagnoal matrxi coefficients
        a_work(:) = a_ED(:) 
        b_work(:) = b_ED(:) 
        c_work(:) = c_ED(:) 
        d_work(:) = 0 ! initialze working array       

        !--- k=1, the uppermost level of the model
        k=1
          d_work(1) = phi_work(k) + mu_prime_work(k)*rho_flux_MF(i,j,k+1)

        !--- other levels
        do k=2,kx-1
          d_work(k) =   phi_work(k)   &
                      + mu_prime_work(k) * (rho_flux_MF(i,j,k+1) - rho_flux_MF(i,j,k))
                      !+ mu_prime_work(k)*sum_up_rawphi_work(k+1) - mu_prime_work(k)*sum_up_rawphi_work(k)  ! MF term
        enddo

        !--- k=kx, the lowewrmost level of the model
        k=kx
          d_work(kx) =    phi_work(k) &
                        - mu_prime_work(k)*rho_flux_MF(i,j,k)            &      ! MF term
                        + mu_prime_work(k)*rho_w1_phi1_surf_work   ! surface flux term

        !-----------------------------------------
        ! call tridiag matrix and compute w'phi'
        !-----------------------------------------
!  print*,'a_work',a_work
!  print*,'b_work',b_work
!  print*,'c_work',c_work
!  print*,'d_work',d_work
!  stop
        call tridiag(kx,a_work,b_work,c_work,d_work)

        !--- get phi_new and phidt_return
        do k=1,kx
          phi_new  (i,j,k) = d_work(k)
          phidt_return (i,j,k) = (d_work(k) - phi_work(k))/dt
        enddo
  
        !--- retrieve fluxes
        rho_w1_phi1(i,j,1) = 0.
        w1_phi1    (i,j,1) = 0.

        do k=2,kx
          rho_flux_ED   (i,j,k) =  nu_phi_work(k) * (phi_new(i,j,k)-phi_new(i,j,k-1))
        enddo

        rho_w1_phi1(i,j,1:kx) =  rho_flux_ED(i,j,1:kx) + rho_flux_MF(i,j,1:kx)
        w1_phi1    (i,j,1:kx) =  rho_flux_ED(i,j,1:kx)/rho_half(i,j,1:kx) &
                               + rho_flux_MF(i,j,1:kx)/up_rho  (i,j,1:kx)

!print*,'yaya'
!print*,'rho_w1_phi1',rho_w1_phi1
!print*,'w1_phi1',w1_phi1
!print*,'phidt_return',phidt_return
!stop
     endif  ! end if of do_MF_explicit .and. .not.do_MF_implicit
  
 !========================== 
  
!===============================================
  end if  ! end if of .not.do_ED_explicit
!===============================================

!---
enddo    ! end do of j
enddo    ! end do of i

!**********************************************************
!**********************************************************
!****   check part   ******
!**********************************************************
!**********************************************************

do_check_lhs_rhs = .false.
!do_check_lhs_rhs = .true.

!-----------------------------------
! check part - flux divergence calculation
!   check whether the lhs, dphi/dt, equals to the rhs, -1/rho * d/dz(rho*w'phi')
!-----------------------------------
if (do_check_lhs_rhs) then
  
  i=1
  if (i.eq.1) then
  !if (varname.eq."qt") then
  ! compute left-hand side, dphi/dt, and right-hand side, 1/rho * d/dz (w'phi')
  do i=1,ix
  do j=1,jx
  do k=1,kx
    lhs = phidt_return(i,j,k)
    rhs = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                              / (up_z(i,j,k) - up_z(i,j,k+1))

    !print*,'---------  solver = ',option_solver,'  ---------'
    print*,'i,j,k,',i,j,k
    print*,'lhs (dphi/dt), rhs (-1/rho * d/dz (w1phi1), lhs-rhs'
    print*,'  ',lhs,rhs,lhs-rhs
  enddo
  enddo
  enddo

  end if

  !stop
  !print*,'up_z',up_z
!  print*,''
!        write(6,*)    '! ------------------------------------'
!        write(6,*)    '! do_MF_explicit      : ',do_MF_explicit
!        write(6,*)    '! do_MF_implicit      : ',do_MF_implicit
!        write(6,*)    '! do_ED_explicit      : ',do_ED_explicit
!        write(6,*)    '! do_ED_implicit      : ',do_ED_implicit
!        write(6,*)    '! do_include_surf_flux: ',do_include_surf_flux
!        write(6,*)    '! option_MF_env_half  : ',option_MF_env_half
!        write(6,*)    '! dt                  : ',dt
!        write(6,*)    '! ------------------------------------'
!
!  print*,''
!  print*,'w1_phi1',w1_phi1
!  print*,''
!  print*,'phidt_return',phidt_return*86400.
  stop

  !write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/up_rho(:,:,:)
  !write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf
end if ! end if of do_check_lhs_rhs

101 format ("(40f5.2)")
2000 format (A25,40(E12.4,2X))
2001 format (A25,40(F8.3,2X))
2002 format (A25,I2,A10,40(F8.3,2X))
2003 format (A25,I2,A10,40(E12.4,2X))
3000 format (A25,2X,F8.2)
3001 format (A25,2X,33(F9.3,2X,','))
3002 format (A25,2X,33(E12.4,2X,','))
3003 format (A25,2X,E12.4)

end subroutine mass_flux_tendencies

!#######################################################################

!subroutine compute_src_thli_qt_prec (dt, p, rho, dz, &
!                                     up_a, up_w, up_qc, water_frac, tau0, &
!                                     qt_src, thli_src, qc_src, qi_src, rr, ri)
!  !---------------------------------------
!  ! Description:
!  !   compute the source terms for ice-liquid water potential temperature and total water mixing ratio  
!  !
!  !   copy from the subroutine cmassflux_precip in WRF, written by Dr, Kay Suselj, 
!  !   and then modified by Yi-Hsuan Chen
!  !---------------------------------------
!
!  !--- input argument
!  real, intent(in)  :: &
!      dt,              &  ! time step, 				units: sec
!      p,               &  ! pressure, 				units: Pa
!      rho,             &  ! air density, 			units: kg/m3
!      dz,              &  ! delta_z, 				units: m 
!      up_a,            &  ! updraft area, 			units: fraction
!      up_w,            &  ! updraft vertical velocity, 		units: m/s
!      up_qc,           &  ! updraft cloud water content,	units: kg/kg
!      water_frac,      &  ! 
!      tau0                !
!
!  !--- output argument
!  real, intent(out) :: &
!      qt_src,          &  ! source term for total water mixing ratio, 			units: kg/kg/s
!      thli_src,        &  ! source term for ice-liquid water potential temperature,	units: K/s
!      qc_src,          &  ! source term for cloud liquid water, 			units: kg/kg/s
!      qi_src,          &  ! source term for cloud ice    water,				units: kg/kg/s
!      rr,              &  ! liquid precipitation rate, 					units: m/s
!      ri                  ! ice    precipitation rate, 					units: m/s
!
!  !--- local varialbes 
!  real, parameter ::        &
!      p00 = 1000.0E2,       & ! 1000 hPa
!      p00inv = 1./p00,      & ! 1/1000hPa 
!      hlv_cp = hlv/cp_air,  & ! L_l/cp, L_l is the latent heat of evaporation 
!      hlf_cp = hlf/cp_air,  & ! L_f/cp, L_l is the latent heat of fusion
!      g = grav                ! gravity acceleration, 9.8 m/s^2    
!
!  real ::       &
!      exn,      &  ! Exner function, (P/P0)^(Rd/cp)
!      hlvf_cp,  &  ! 
!      q0,       &  ! qc threshold of autoconversion, units: kg/kg
!      q0_liq,   &  ! 
!      q0_ice       !
!
!!----------------------------------
!
!! initialize output variables
!  qt_src = 0. 
!  thli_src = 0. 
!  qc_src = 0.    
!  qi_src = 0.   
!  rr = 0.  
!  ri = 0.
!
!  ! compute the threshold for autoconversion, q0
!  q0=water_frac*q0_liq+(1.-water_frac)*q0_ice
!
!  if (up_qc .gt. q0) then
!
!    ! compute Exner function, (P/P0)^(Rd/cp)     
!    exn=(p*p00inv)**kappa
!
!    ! compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
!    hlvf_cp = hlv_cp*water_frac + hlf_cp*(1.-water_frac)
!
!    ! source term for qt
!    qt_src=-(up_qc-q0)*(1.-exp(-dz/(up_w*tau0)))      
!
!    ! source term for theta_li
!    thli_src=-qt_src*hlvf_cp/exn
!
!    ! source term for qc, qi
!    qc_src=(up_qc-q0)/dt*(exp(-dt/tau0)-1.)*up_a    
!    qi_src=qc_src*(1.-water_frac)
!    qc_src=qc_src*water_frac
!
!    ! compute precipitation flux, m/s
!    rr=-rho*qc_src*up_a*dz/dens_h2o
!    ri=-rho*qi_src*up_a*dz/dens_h2o
!
!  end if
!
!end subroutine compute_src_thli_qt_prec
!
!!#######################################################################
!
subroutine compute_thv_qc (qt, thli, p, water_frac, &
                           thv, qq, qc, ql, qi,         &
                           qsat)
  !---------------------------------------
  ! Description:
  !   compute virtual potential temperature and cloud water specific humidity 
  !   based on ice-liquid water potential temperature and total water specific humidity
  !
  !   copy from the subroutine condensation_edmf in WRF, written by Dr, Kay Suselj, 
  !   and then modified by Yi-Hsuan Chen
  !---------------------------------------

  !--- input argument
  real, intent(in)  :: &
      qt,              &   ! total water specific humidity (vapor + cloud liquid + cloud ice), units: kg/kg
      thli,            &   ! ice-liquid water potential temperature  	                     , units: K
      p,               &   ! pressure                                       	             , units: Pa
      water_frac           ! cloud liquid water fraction                         	     , units: fraction

  real, intent(in), optional :: & 
      qsat                 ! optional: the saturation specific humidity can be an input      , units: kg/kg
                           !   This helps to debug in an offline code

  !--- output argument
  real, intent(out) :: &
      thv,             &   ! virtual potential temperature 	    , units: K
      qq,              &   ! specific humidity, units: kg/kg
      qc,              &   ! cloud water (liq+ice) specific humidity, units: kg/kg
      ql,              &   ! cloud liquid water specific humidity   , units: kg/kg
      qi                   ! cloud ice    water specific humidity   , units: kg/kg
 
  !--- local varialbes 
  real, parameter ::        &
      p00 = 1000.0E2,       & ! 1000 hPa
      p00inv = 1./p00,      & ! 1/1000hPa 
      g = grav,             & ! gravity acceleration, 9.8 m/s^2    
      rv_rd = rvgas/rdgas,  & ! rv/rd = 1.6
      hlv_cp = hlv/cp_air,  & ! hlv/cp, hlv is the latent heat of evaporation 
      hlf_cp = hlf/cp_air,  & ! hlf/cp, hlf is the latent heat of fusion
      niter = 50,           & ! number of iterations
      diff  = 1.e-4           ! minimum difference for iteration

  real ::         &
      t,          &    ! temperature (K)
      tv,         &    ! temperature (K)
      qs,         &    ! saturation vapor specific humidity (kg/kg)
      exn,        &    ! Exner function, (P/P0)^(Rd/cp)
      hlvf_cp,    &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_hlvf_cp, &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_old           ! 
   
  real :: tt1

  integer i
!------------------------------------

  !--- initialize return variables
  thv = 0.
  qc  = 0.
  qc  = 0.
  ql  = 0.
  qi  = 0.
  
 !--- compute Exner function, (P/P0)^(Rd/cp) 
  exn=(p*p00inv)**kappa  

  !--- iterate to get qc
  do i=1,niter

    !--- compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
    hlvf_cp = (hlv_cp*water_frac + hlf_cp*(1.-water_frac))
    qc_hlvf_cp = qc * hlvf_cp

    !--- compute temperature
    t  = exn*(thli+qc_hlvf_cp)     

    !--- compute saturation specific humidity
    if (present(qsat)) then
      qs = qsat
    else
      qs = qs_edmf(t,p,water_frac)   
    endif

    !--- compute qc, and qc_old
    qc_old = qc
    qc    = max(0.5*qc+0.5*(qt-qs),0.)
    if (abs(qc-qc_old)<diff) exit   ! compare previous qc and current qc values
  end do

  !--- get the final value of t, qs, qc, and thv
  qc_hlvf_cp = qc * hlvf_cp
  t = exn*(thli+qc_hlvf_cp)

  qq  = max(qt-qc,0.)    ! note that qq is very close to qs(t), but not exactly the same due to numerics
  ql  = qc * water_frac
  qi  = qc * (1.-water_frac)

  thv = (thli+qc_hlvf_cp/exn)*(1.+qt*(rv_rd-1.)-rv_rd*qc)  ! Kay's formula, but I don't understand why
  !tt1 = t*(qq*d608+1.0)/exn                                ! standard virtual potential temperature formula
  !print*,'thv_Kay,thv_d608,diff',thv,tt1,thv-tt1  ! the difference is very small

  !print*,'aa, thv= ',thv
  !print*,'aa, qc=  ',qc
  !print*,'thli,qt,p,',thli,qt,p,', thv,qc',thv,qc
  !print*,'-----------------'
  !print*,'t,p',t,p
  !print*,'thli,thv,',thli,thv
  !print*,'qt,qq,qc',qt,qq,qc

!  if (qc.gt.0.) then
!    ! write(6,*) '--------------------------'
!    !! write(6,*),'ggg1, thli,thv,qt',thli,thv,qt
!    ! write(6,*),'ggg1, thli,thv',thli,thv
!    ! write(6,*),'ggg2, qt,qc',qt,qc
!    qs = qs_edmf(t,p,water_frac)
!    ! write(6,*),'ggg3, qq,rh',qq,qq/qs*100.
!  end if

end subroutine compute_thv_qc

!#######################################################################

subroutine check_trc_rlzbility (dt, tracer, tracer_tend, &
                                tend_ratio)

!---------------------------------------------------------------------
!  Check for tracer realizability. If tracer tendencies would
!  produce negative tracer mixing ratios, scale down tracer tendency
!  terms uniformly for this tracer throughout convective column. 
!
!  Reference: subroutine don_d_check_trc_rlzbility, src/atmos_param/donner_deep/donner_deep_k.F90
!---------------------------------------------------------------------

!---------------------------------------------------------------------
! Arguments (Intent in)
!     dt             physics time step               , [ sec ]
!     tracer         tracer mixing ratios            , [ kg(tracer) / kg (dry air) ]
!     tracer_tend    tendency of tracer mixing ratios, [ kg(tracer) / kg (dry air) / sec ]
!---------------------------------------------------------------------
  real,    intent(in)                   :: dt
  real,    intent(in), dimension(:,:,:) :: tracer, tracer_tend

!---------------------------------------------------------------------
! Arguments (Intent out)
!     tend_ratio     ratio by which tracer tendencies need to 
!                    be reduced to permit realizability (i.e., to prevent
!                    negative tracer mixing ratios)
!---------------------------------------------------------------------
  real, intent(out), dimension(:,:)     :: tend_ratio
  
!---------------------------------------------------------------------
! Arguments (Intent local)
!     tracer0        column tracer mixing ratios before MF
!     tracer1        column tracer mixing ratios after  MF transport only
!     trtend         column tracer mixing ratio tendencies due to convective transport [ (tracer units) / s ]
!     tracer_min     minimum of tracer0
!     tracer_max     maximum of tracer0
!---------------------------------------------------------------------

  real, dimension(size(tracer,3)) ::    &  ! dimension (nlay)
    tracer0, trtend, tracer1

  real :: &
    tracer_min, tracer_max, ratio

  character*40 cause

  !--- index variables & dimension
  integer i,j,k
  integer ix,jx,kx  

!--------------------------

!--- set dimensions
  ix  = size( tracer, 1 )
  jx  = size( tracer, 2 )
  kx  = size( tracer, 3 )

!--- initialze return variable
  tend_ratio = 1.

!---------------------
! compute tend_ratio
!   Updated tracer concentation must be 
!   (1) not negative, 
!   (2) in the range of max/min of tracer0
!---------------------
  do i=1,ix
  do j=1,jx

    !--- set column tracer concentration
    tracer0(:)  = tracer(i,j,:)
    trtend (:)  = tracer_tend(i,j,:)
    tracer1(:)  = tracer0(:) + dt * trtend(:)

!write(6,*),'tracer0',tracer0
!write(6,*),'tracer1',tracer1
!write(6,*),'trtend',trtend

    !--- get max/min of tracer0
    tracer_min = 1.e20
    tracer_max = -1.e20

    do k = 1,kx
       if (trtend(k) /= 0.) then
          tracer_max = max(tracer0(k),tracer_max)
          tracer_min = min(tracer0(k),tracer_min)
       end if
    end do

!print*,'tracer_max',tracer_max
!print*,'tracer_min',tracer_min

    !--- compute ratio
    ratio = 1.
    do k = 1,kx

       !--- if tracer1 is less than zero
       if (tracer0(k) > 0. .and. tracer1(k)<0.) then
          ratio = MIN( ratio,tracer0(k)/(-trtend(k)*dt) )
          cause = "tracer1 is less than zero"
          !write(6,*),'-------'
          !write(6,*),'aa1, less than zero, k,ratio',k,ratio
          !write(6,*),'  tracer0(k), tracer1(k), ',tracer0(k), tracer1(k)
       end if

       !--- if tracer1 is less than tracer_min
       if (tracer1(k)<tracer_min .and. trtend(k) /= 0.0 ) then
          ratio = MIN( ratio,(tracer0(k)-tracer_min)/(-trtend(k)*dt) )
          cause = "tracer1 is less than tracer_min"
          !write(6,*),'-------'
          !write(6,*),'aa2, less than min, k,ratio',k,ratio
          !write(6,*),'  tracer1(k), tracer_min, ',tracer1(k), tracer_min
       end if

       !--- if tracer1 is larger than tracer_max
       if (tracer1(k)>tracer_max  .and. trtend(k) /= 0.0 ) then
          ratio = MIN( ratio,(tracer_max-tracer0(k))/(trtend(k)*dt) )
          cause = "tracer1 is larger than tracer_max"
          !write(6,*),'-------'
          !write(6,*),'aa3, larger than max, k,ratio',k,ratio
          !write(6,*),'  tracer1(k), tracer_max, ',tracer1(k), tracer_max
       end if

    end do

    !--- make sure 1 > ratio > 0
    ratio = MAX(0.,MIN(1.,ratio))

    tend_ratio(i,j) = ratio

  enddo   ! end do of j
  enddo   ! end do of i

end subroutine check_trc_rlzbility

!#######################################################################

function qs_edmf(t,p,water_frac)
  real, intent(in)  :: &
      t, &
      p, &
      water_frac
  real qsat, qs_edmf
!  real :: &
!      esl, esi, es
!--------------------------
  !esl = 
  !esi = 

  !es = 
  !es = esl*water_frac + esi*(1.-water_frac)

  call compute_qs(t, p, qsat)

  qs_edmf = qsat

end function

!!#######################################################################
!! subroutine OUTDATED_massflux_tendencies
!!   ****  This subroutine is no longer used after June 20, 2020. ****
!!
!! Purpose:
!!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, i.e. <w'phi'>
!!
!!   According to Appendix A in Suselj et al. (2019b): 
!!     "In this solver, the large-scale horizontal advection and source terms are
!!      treated explicitly (i.e., they are taken at the time, t), whereas the
!!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!!      subgrid fluxes are treated semi-implicitly."
!!
!! Numerical discretation:
!!
!!   --------- 1   (top of the atmospheric model)
!!     * 1    
!!   --------- 2
!!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!!   --------- k-1
!!     * k-1
!!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!!     * k               as well as subgrid mixing terms <w'phi'>
!!   --------- k+1
!!     * k+1
!!   --------- ...
!!     ....
!!   --------- kx
!!     * kx
!!   --------- kxp=kx+1
!!
!!    SURFACE
!!
!!=== Equation: Eq (7) in Suselj et al. (2019b)
!!
!!   mean_PHI = uu, vv, tt, or qt
!!   mean_w   = 0.
!!
!!   w'PHI'(t,k) = sum [ up_area * (up_PHI-mean_PHI) * (up_w-0) ]
!!               = sum [ up_area(t,k) * ( up_PHI(t,k) - 0.5(mean_PHI(t,k-1)+mean_PHI(t,k) ) * up_w(t,k) ]
!!
!!=== Equation: Eq (1) in Suselj et al. (2019b)
!!
!!   mean_PHI(k,t+dt) - mean_PHI(k,t+dt)      w'PHI'(t+dt,k+1) - w'PHI'(t+dt,k)
!!  -------------------------------------- = ---------------------------------------
!!                  dt                                  dz
!!
!!  To compute <w'PHI'>, mean_PHI are taken at time (t+dt) and up_* are taken at time (t)
!!
!!  These will result in a set of linear euqations of unknown variables, mean_PHI(t+dt,k), 
!!  and these equations are solved by the Tridiagonal matrix algorithm.
!!
!!
!! History:
!!   2020/05/17  Make the input sum_up_**_input variables have the same vertical indexing with the CM4, i.e. k=1 at the uppermost.
!!   2020/06/04  Make updraft fluxes at the surface to zero, to avoid updraft bringing energy/tracer from
!!               the surface to the atmosphere that will cause  additional energy/tracer adding to the atmosphere
!!   2020/06/07  Add check part
!!   2020/06/20  Stop updating this subroutine because it is replaced by another subroutine, mass_flux_tendencies
!!
!! Author:
!!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!!
!! Notes:
!!   1. Solver, subroutine tridiag
!!      This program uses the "Tridiagonal matrix algorithm" to compute the tendency terms.
!!      Wiki has a detailed explanation about this algorithm: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm
!!
!!      a,b,c - are coefficients on the LHS
!!      d     - is initially RHS on the output becomes a solution vector
!!
!!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!!      [ a1,  0, an, bn   ]   [xn]    [dn]
!!
!!      a1=0 and cn=0
!!
!! References:
!!   Suselj et al. (2014, WAF):
!!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!!     https://doi.org/10.1175/WAF-D-14-00043.1
!!   Suselj et al. (2019a, JAS):
!!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!!     https://doi.org/10.1175/JAS-D-18-0121.1
!!   Suselj et al. (2019b, JAS):
!!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!!     https://doi.org/10.1175/JAS-D-18-0239.1
!!-----------------------
!
!subroutine OUTDATED_massflux_tendencies ( is, js, dt, time,                   &
!                                 p_half, p_full, z_half, z_full,     &
!                                 uu, vv, tt, qq,                     &
!                                 is_mass_flux,                       & 
!                                 sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!                                 sum_up_awthv_input, sum_up_awqt_input,  &
!                                 udt_mf, vdt_mf, tdt_mf, qdt_mf,     & 
!                                 thvdt_mf, qtdt_mf)
!
!!---------------------------------------------------------------------
!! Arguments (Intent in)
!!    dt           -  Time step               (sec)
!!    time         -  variables needed for netcdf diagnostics
!!    p_half       -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!!    p_full       -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!!    z_half       -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!!    z_full       -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!!    uu           -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!!    vv           -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!!    tt           -  Potential temperature   (K)     , dimension (nlon, nlat, nlay)
!!    qq           -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)
!!
!!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!!                                                        dimension (nlon,nlat)
!!
!!    sum_up_aw_input     - sum of the product of fractional area and vertical velocity for individual updraft
!!                      i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!!    sum_up_awu_input    - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!!                      i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awv_input    - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!!                      i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awthv_input  - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!!                      i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!!    sum_up_awqt_input   - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!!                      i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!!
!! Note:
!!   1. All updraft variables are at half level, i.e. the number of levels is nlay+1
!!---------------------------------
!
!  integer, intent(in)                 :: is, js
!  real,  intent(in)                   :: dt
!  type(time_type),      intent(in)    :: time
!  real,  intent(in), dimension(:,:,:) :: p_full, z_full   ! dimension (nlon, nlat, nlay)
!  real,  intent(in), dimension(:,:,:) :: p_half, z_half   ! dimension (nlon, nlat, nlay+1)
!  real,  intent(in), dimension(:,:,:) :: uu, vv, tt, qq   ! dimension (nlon, nlat, nlay)
!
!  real,  intent(in), dimension(:,:,:) ::             &    ! dimension (nlon, nlat, nlay+1)
!         sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!         sum_up_awthv_input, sum_up_awqt_input
!
!  logical, intent(in), dimension(:,:) :: is_mass_flux     ! dimension (nlon, nlat)
!
!!---------------------------------------------------------------------
!! Arguments (Intent out)
!!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!!   thvdt_mf - virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!!   qtdt_mf  - total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!!
!! Note:
!!   1. The vertical indexing of d*_dt terms is the same as the input variables such as uu,vv,tt,etc.
!!        i.e. k=1 is the uppermost level
!!---------------------------------------------------------------------
!
!  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
!      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
!      thvdt_mf, qtdt_mf
!
!!---------------------------------------------------------------------
!!  (Intent local)
!!---------------------------------------------------------------------
!
!  !--- updraft variables for work
!  !      times the input sum_up_* by air density (rho, abbreviated as 'r')
!  !      note that the vertical indexing is reversed from sum_up_*_input. The new indexing is counted upward from the surface,
!  !      i.e. k=1 is the lowermost model level
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!         sum_up_raw, sum_up_rawu, sum_up_rawv,              &
!         sum_up_rawthv, sum_up_rawqt
!
!  !--- grid-mean variables for work
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        uu_rev, vv_rev, thv_rev,    &  ! reverse indexing so that they are counted from surface upward
!        qt_rev, dz_rev, rho_rev, dt_rhodz  !   i.e. k=1 is the lowermost level
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)) :: &  ! dimension (nlon,nlat,nlay)
!        qt,   & ! total specific humidity (vapor+condensed), (kg/kg)
!        tv,   & ! virtual temperature                        (K)
!        thv,  & ! virtual potential temperature              (K)
!        rho_full,  & ! air density at full levels                               (kg/m3)
!        ape     ! factor to compute potential temperature
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!        rho_half    ! air density at half levels (kg/m3)
!
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp
!
!  !--- variables for the tridiag solver
!  real, dimension(size(uu,3)) :: &  ! dimension (nlay)
!        a, b, c, d                  ! arrays for the tridiag solver
!
!
!  !*** parameters ***
!  real, parameter :: &
!      p00 = 1000.0E2,     & ! 1000 hPa
!      p00inv = 1./p00,    & ! 1/1000hPa
!      g = grav              ! gravity acceleration
!
!  !*** index variables ***
!  integer i,j,k,kk,n
!  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
!
!  !*** use for netCDF output ***
!  logical used
!
!  !*** variables for result checking ***
!  real tt1,tt2,tt3,tt4,tt5
!  real awphi_k, awphi_kp
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: sum_up_rawphi, sum_env_rawphi, w1phi1
!  real, dimension(size(uu,1),size(uu,2),size(uu,3))   :: phi, dphi_dt, phi_new
!  real, dimension(size(uu,3)) :: phi_rev, phi_d
!  character*5, phi_name
!  logical use_explicit_solver   ! use explicit solver to obtain tendency terms. For check use only
!
!!---------------------------------------------------------------
!
!!--- set dimensions
!  ix  = size( uu, 1 )
!  jx  = size( uu, 2 )
!  kx  = size( uu, 3 )
!  kxp = kx + 1
!  kxm = kx - 1
!  ism = is - 1
!  jsm = js - 1
!
!!--- compute virtual potential temperature, thv
!  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)
!  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  
!  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)
!
!!--- compute air density at full and half levels
!  do i=1,ix
!  do j=1,jx
!  do k=1,kx-1
!    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
!  enddo
!  enddo
!  enddo
!  rho_half(:,:,1)    = rho_full(:,:,1)  
!  rho_half(:,:,kx+1) = rho_full(:,:,kx)
!
!!--- set updraft working variables, in which the vertical indexing is reversed 
!!      so that k=1 is at the lowermost model level
!  do i=1,ix
!  do j=1,jx
!  do k=1,kxp
!    kk=kxp-k+1
!    sum_up_raw   (i,j,kk) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,kk) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,kk) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,kk) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,kk) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo
!  enddo
!  enddo
!
!  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring 
!  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
!  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
!  sum_up_raw   (:,:,1) = 0.
!  sum_up_rawu  (:,:,1) = 0.
!  sum_up_rawv  (:,:,1) = 0.
!  sum_up_rawthv(:,:,1) = 0.
!  sum_up_rawqt (:,:,1) = 0.
!
!!--- initialize return and working variables 
!  udt_mf   = 0.
!  vdt_mf   = 0.
!  tdt_mf   = 0.
!  qdt_mf   = 0.
!  thvdt_mf = 0.
!  qtdt_mf  = 0.
!
!  qt(:,:,:) = qq(:,:,:)
!
!  a = 0.
!  b = 0.
!  c = 0.
!  d = 0.
!
!!----------------------
!! compute tendencies 
!!----------------------
!
!  !--- loop for each (i,j) point
!  do i=1,ix
!  do j=1,jx
!
!!------------------------
!! if there are updrafts
!!------------------------
!    if (is_mass_flux(i,j)) then
!
!    !--- reverse variables so that the vertical index counting from the surface
!    !    upward, i.e. k=1 is the lowermost model level
!    do k=1,kx
!      kk=kx-k+1
!      uu_rev  (kk) = uu (i,j,k)
!      vv_rev  (kk) = vv (i,j,k)
!      qt_rev  (kk) = qt (i,j,k)
!      thv_rev (kk) = thv(i,j,k)
!      dz_rev  (kk) = z_half(i,j,k) - z_half(i,j,k+1)
!      rho_rev (kk) = rho_full(i,j,k)
!      dt_rhodz(kk) = dt / rho_rev(kk) / dz_rev(kk)
!    enddo
!
!!-----------------------------------
!! set tridiag matrix coefficients: a,b,c, 
!!   which are the same for the all variables such as uu,vv,tt,qq,etc.
!!-----------------------------------
!
!    !--- the lowermost level of the model
!    k=1
!    a(1) = 0.
!    b(1) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!    c(1) =    - 0.5 * dt_rhodz(k) *  sum_up_raw(i,j,k+1)
!
!    !--- other levels 
!    do k=2,kx-1
!      a(k) = dt_rhodz(k)      * 0.5 *  sum_up_raw(i,j,k)
!      b(k) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!      c(k) =    - dt_rhodz(k) * 0.5 *  sum_up_raw(i,j,k+1)
!    enddo
!
!    !--- the uppermost level of the model
!    a(kx) = 0.
!    b(kx) = 1.
!    c(kx) = 0.
!
!!-----------------------
!! compute uu tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )  
!    enddo
!
!    d(kx) = uu_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      udt_mf (i,j,kk) = (d(k) - uu_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute vv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!    enddo
!
!    d(kx) = vv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      vdt_mf (i,j,kk) = (d(k) - vv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute thv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!    enddo
!
!    d(kx) = thv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      thvdt_mf (i,j,kk) = (d(k) - thv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute qt tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!    enddo
!
!    d(kx) = qt_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      qtdt_mf (i,j,kk) = (d(k) - qt_rev(k))/dt
!    enddo
!
!!----------------------
!! compute qq tendency
!!----------------------
!
!    ! Set to qtdt at this moment
!    qdt_mf(i,j,:) = qtdt_mf(i,j,:)
!
!!------------------------------------
!! compute tt tendency 
!!  based on thv and qt tendencies
!!------------------------------------
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!
!!------------------------
!! end if of is_mass_flux
!!------------------------
!    endif 
!
!
!!*********************
!!*********************
!!  check part
!!*********************
!!*********************
!
!!-------------------------------
!! check part - flux divergence
!!   check whether dphi/dt = -1/rho * d/dz(rho*w'phi') for the implicit solver
!!-------------------------------
!  !phi_name = "uu"
!  !phi_name = "vv"
!  phi_name = "thv"
!  !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi    (:,:,:) = uu   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi    (:,:,:) = vv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi    (:,:,:) = thv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi    (:,:,:) = qt   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  print*,'sum_up_awthv,',sum_up_awthv_input
!  print*,'sum_up_rawphi',sum_up_rawphi 
!!  print*,'sum_env_rawphi',sum_env_rawphi 
!!  print*,'sum_env_awphi',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!!  print*,'rho*w1phi1',w1phi1
!!  print*,'phi_name,',phi_name
!!  print*,'dphi_dt',dphi_dt
!!  print*,'thvdt_mf',thvdt_mf
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf
! 
!!-----------------------------------------
!! check part - use explicit solver to compute tendency
!!-----------------------------------------
!
!use_explicit_solver = .true.
!!use_explicit_solver = .false.
!if (use_explicit_solver) then
!
!    !phi_name = "uu"
!    !phi_name = "vv"
!    phi_name = "thv"
!    !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      phi    (:,:,:) = uu   (:,:,:)
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi_rev(:) = uu_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      phi    (:,:,:) = vv   (:,:,:)
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi_rev(:) = vv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      phi    (:,:,:) = thv   (:,:,:)
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi_rev(:) = thv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      phi_name = "qt"
!      phi    (:,:,:) = qt   (:,:,:)
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi_rev(:) = qt_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  !print*,'sum_up_rawphi',sum_up_rawphi 
!  !print*,'sum_env_rawphi',sum_env_rawphi 
!  !print*,'rho*w1phi1',w1phi1
!  !print*,'phi_name,dphi_dt',phi_name,dphi_dt
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_explicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_explicit = (/',dphi_dt
!
!  ! replace tendency terms
!    thvdt_mf(:,:,:) = dphi_dt(:,:,:)
!    qdt_mf(:,:,:)   = 0.
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!end if ! end if of use_explicit_solver
!!
!!!------------------
!!!check part - mass/energy conservation
!!!------------------
!!
!!!*** check qq ***
!!  tt1 = 0.
!!  tt2 = 0.
!! 
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + qq(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (qdt_mf(i,j,k)*dt+qq(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_qq, new_qq, rho, dz',k,qq(i,j,k),(qdt_mf(i,j,k)*dt+qq(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   qdt_mf',qdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'old qq (kg/m2), ',tt1
!!  print*,'new qq (kg/m2), ',tt2
!!  print*,'-----------------------------------------'
!!
!!!*** check tt ***
!!  tt1 = 0.
!!  tt2 = 0.
!!
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_tt, new_tt, rho, dz',k,tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   tdt_mf',tdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'column old energy (J), ',tt1,'*Cp'
!!  print*,'column new energy (J), ',tt2,'*Cp'
!!  print*,'-----------------------------------------'
!!   
!!  tt1=0.
!!  tt2=0.
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tdt_mf(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + tt1
!!    print*,'k,tdt_mf,  heat_mf(J/s),',k,tdt_mf(i,j,k), tt1,'*Cp'
!!  enddo
!!
!!  print*,'sum of heat_mf (J/s), should cloase to zero,',tt2,'*Cp'
!!
!!!------------------
!!!check part - tridiagnol solver 
!!!------------------
!!  if (is_mass_flux(i,j)) then
!!    !phi_name = "uu"
!!    !phi_name = "vv"
!!    phi_name = "thv"
!!    !phi_name = "qt"
!! 
!!    !*** set phi ***
!!    if (phi_name == "uu") then
!!      phi    (:,:,:) = uu   (:,:,:)
!!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!!      phi_rev(:) = uu_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!!
!!    elseif (phi_name == "vv") then
!!      phi    (:,:,:) = vv   (:,:,:)
!!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!!      phi_rev(:) = vv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!!  
!!    elseif (phi_name == "thv") then
!!      phi    (:,:,:) = thv   (:,:,:)
!!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!!      phi_rev(:) = thv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!!  
!!    elseif (phi_name == "qt") then
!!      phi_name = "qt"
!!      phi    (:,:,:) = qt   (:,:,:)
!!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!!      phi_rev(:) = qt_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!!
!!    endif
!!
!!    !*** check program ***
!!    do k=1,kx
!!      kk=kx-k+1
!!      phi_d(kk) = phi (i,j,k) + dphi_dt(i,j,k)*dt  ! reverse 
!!    enddo
!!
!!    do k=1,kx
!!      print*,'i,j,k,phi(t),dphi,',i,j,k,phi(i,j,k),dphi_dt(i,j,k)*dt,' ',phi_name
!!    enddo
!!    print*,'-------------------------'
!!
!!    k=1
!!    !tt1 = phi_d(k) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!    tt2 = phi_d(k) * (1. - 0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt4 = phi_rev(k) - dt_rhodz(k)*sum_up_rawphi(i,j,k+1)
!!    print*,'k,lhs,rhs,lhs-rhs',k,tt2+tt3,tt4,tt2+tt3-tt4
!!
!!    do k=2,kx
!!      tt1 = phi_d(k-1) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!      tt2 = phi_d(k) * (1. + 0.5*dt_rhodz(k)*(sum_up_raw(i,j,k)-sum_up_raw(i,j,k+1)))
!!      tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!      tt4 = phi_rev(k) + dt_rhodz(k)*(sum_up_rawphi(i,j,k)-sum_up_rawphi(i,j,k+1))
!!      print*,'k,lhs,rhs,lhs-rhs',k,tt1+tt2+tt3,tt4,tt1+tt2+tt3-tt4
!!    enddo
!!
!!    end if ! end if of is_mass_flux
!!!------------------
!!!check part end
!!!------------------
!
!  enddo  ! end loop of j
!  enddo  ! end loop of i
!
!!!------------------------------
!!! write out to history files
!!!------------------------------
!!
!!!------- u tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_udt_mf > 0) then
!!    used = send_data (id_udt_mf, udt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- v tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_vdt_mf > 0) then
!!    used = send_data (id_vdt_mf, vdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- t tendency from mass flux (units: K/s) at full level -------
!!  if ( id_tdt_mf > 0) then
!!    used = send_data (id_tdt_mf, tdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- q tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qdt_mf > 0) then
!!    used = send_data (id_qdt_mf, qdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- thv tendency from mass flux (units: K/s) at full level -------
!!  if ( id_thvdt_mf > 0) then
!!    used = send_data (id_thvdt_mf, thvdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qtdt_mf > 0) then
!!    used = send_data (id_qtdt_mf, qtdt_mf, time, is, js, 1 )
!!  endif
!
!1000 format (A35,40(E12.4,2X))
!1001 format (A25,40(F8.3,2X))
!1002 format (A25,I2,A10,40(F8.3,2X))
!1003 format (A25,I2,A10,40(E12.4,2X))
!
!end subroutine OUTDATED_massflux_tendencies

!#######################################################################

subroutine random_Poisson(mu,first,ival) 
!**********************************************************************
!     Translated to Fortran 90 by Alan Miller from:
!                           RANLIB
!
!     Library of Fortran Routines for Random Number Generation
!
!                    Compiled and Written by:
!
!                         Barry W. Brown
!                          James Lovato
!
!             Department of Biomathematics, Box 237
!             The University of Texas, M.D. Anderson Cancer Center
!             1515 Holcombe Boulevard
!             Houston, TX      77030
!
! This work was supported by grant CA-16672 from the National Cancer Institute.

!                    GENerate POIsson random deviate
!                            Function
! Generates a single random deviate from a Poisson distribution with mean mu.
!                            Arguments
!     mu --> The mean of the Poisson distribution from which
!            a random deviate is to be generated.
!                              REAL mu
!                              Method
!     For details see:
!               Ahrens, J.H. and Dieter, U.
!               Computer Generation of Poisson Deviates
!               From Modified Normal Distributions.
!               ACM Trans. Math. Software, 8, 2
!               (June 1982),163-179
!     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT
!     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL
!     SEPARATION OF CASES A AND B

!     .. Scalar Arguments ..
	REAL, INTENT(IN)    :: mu
	LOGICAL, INTENT(IN) :: first
INTEGER             :: ival
!     ..
!     .. Local Scalars ..
	REAL          :: b1, b2, c, c0, c1, c2, c3, del, difmuk, e, fk, fx, fy, g,  &
                    omega, px, py, t, u, v, x, xx
	REAL, SAVE    :: s, d, p, q, p0
        INTEGER       :: j, k, kflag
	LOGICAL, SAVE :: full_init
        INTEGER, SAVE :: l, m
!     ..
!     .. Local Arrays ..
	REAL, SAVE    :: pp(35)
!     ..
!     .. Data statements ..
	REAL, PARAMETER :: a0 = -.5, a1 = .3333333, a2 = -.2500068, a3 = .2000118,  &
                a4 = -.1661269, a5 = .1421878, a6 = -.1384794,   &
                 a7 = .1250060

	REAL, PARAMETER :: fact(10) = (/ 1., 1., 2., 6., 24., 120., 720., 5040.,  &
            40320., 362880. /)

        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

!     ..
!     .. Executable Statements ..
   IF (mu > 10.0) THEN
!     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED)

  IF (first) THEN
s = SQRT(mu)
d = 6.0*mu*mu

!             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL
!             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484)
!             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 .

l = mu - 1.1484
full_init = .false.
  END IF


!     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE

	  g = mu + s*random_normal()
	  IF (g > 0.0) THEN
		ival = g

	!     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH

		IF (ival>=l) RETURN

	!     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U

		fk = ival
		difmuk = mu - fk
		CALL RANDOM_NUMBER(u)
		IF (d*u >= difmuk*difmuk*difmuk) RETURN
	  END IF

	!     STEP P. PREPARATIONS FOR STEPS Q AND H.
	!             (RECALCULATIONS OF PARAMETERS IF NECESSARY)
	!             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7.
	!             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE
	!             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK.
	!             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION.

	  IF (.NOT. full_init) THEN
		omega = .3989423/s
		b1 = .4166667E-1/mu
		b2 = .3*b1*b1
		c3 = .1428571*b1*b2
		c2 = b2 - 15.*c3
		c1 = b1 - 6.*b2 + 45.*c3
		c0 = 1. - b1 + 3.*b2 - 15.*c3
		c = .1069/mu
		full_init = .true.
	  END IF

	  IF (g < 0.0) GO TO 50

	!             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN)

	  kflag = 0
	  GO TO 70

	!     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE)

	  40 IF (fy-u*fy <= py*EXP(px-fx)) RETURN

	!     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL
	!             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT'
	!             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.)

	  50 e = random_exponential()
	  CALL RANDOM_NUMBER(u)
	  u = u + u - one
	  t = 1.8 + SIGN(e, u)
	  IF (t <= (-.6744)) GO TO 50
	  ival = mu + s*t
	  fk = ival
	  difmuk = mu - fk

	!             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN)

	  kflag = 1
	  GO TO 70

	!     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION)

	  60 IF (c*ABS(u) > py*EXP(px+e) - fy*EXP(fx+e)) GO TO 50
	  RETURN

	!     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY.
	!             CASE ival < 10 USES FACTORIALS FROM TABLE FACT

	  70 IF (ival>=10) GO TO 80
	  px = -mu
	  py = mu**ival/fact(ival+1)
	  GO TO 110

	!             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION
	!             A0-A7 FOR ACCURACY WHEN ADVISABLE
	!             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5)

	  80 del = .8333333E-1/fk
	  del = del - 4.8*del*del*del
	  v = difmuk/fk
	  IF (ABS(v)>0.25) THEN
		px = fk*LOG(one + v) - difmuk - del
	  ELSE
		px = fk*v*v* (((((((a7*v+a6)*v+a5)*v+a4)*v+a3)*v+a2)*v+a1)*v+a0) - del
	  END IF
	  py = .3989423/SQRT(fk)
	  110 x = (half - difmuk)/s
	  xx = x*x
	  fx = -half*xx
	  fy = omega* (((c3*xx + c2)*xx + c1)*xx + c0)
	  IF (kflag <= 0) GO TO 40
	  GO TO 60

	!---------------------------------------------------------------------------
	!     C A S E  B.    mu < 10
	!     START NEW TABLE AND CALCULATE P0 IF NECESSARY

	ELSE
	  IF (first) THEN
		m = MAX(1, INT(mu))
		l = 0
		p = EXP(-mu)
		q = p
		p0 = p
	  END IF

	!     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD

	  DO
		CALL RANDOM_NUMBER(u)
		ival = 0
		IF (u <= p0) RETURN

	!     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE
	!             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES
	!             (0.458=PP(9) FOR MU=10)

		IF (l == 0) GO TO 150
		j = 1
		IF (u > 0.458) j = MIN(l, m)
		DO k = j, l
		  IF (u <= pp(k)) GO TO 180
		END DO
		IF (l == 35) CYCLE

	!     STEP C. CREATION OF NEW POISSON PROBABILITIES P
	!             AND THEIR CUMULATIVES Q=PP(K)

		150 l = l + 1
		DO k = l, 35
		  p = p*mu / k
		  q = q + p
		  pp(k) = q
		  IF (u <= q) GO TO 170
		END DO
		l = 35
	  END DO

	  170 l = k
	  180 ival = k
	  RETURN
	END IF

	RETURN
	END subroutine random_Poisson

!#######################################################################
	FUNCTION random_normal() RESULT(fn_val)

	! Adapted from the following Fortran 77 code
	!      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM.
	!      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
	!      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435.

	!  The function random_normal() returns a normally distributed pseudo-random
	!  number with zero mean and unit variance.

	!  The algorithm uses the ratio of uniforms method of A.J. Kinderman
	!  and J.F. Monahan augmented with quadratic bounding curves.

	REAL :: fn_val

	!     Local variables
	REAL     :: s = 0.449871, t = -0.386595, a = 0.19600, b = 0.25472,           &
				r1 = 0.27597, r2 = 0.27846, u, v, x, y, q
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	!     Generate P = (u,v) uniform in rectangle enclosing acceptance region

	DO
	  CALL RANDOM_NUMBER(u)
	  CALL RANDOM_NUMBER(v)
	  v = 1.7156 * (v - half)

	!     Evaluate the quadratic form
	  x = u - s
	  y = ABS(v) - t
	  q = x**2 + y*(a*y - b*x)

	!     Accept P if inside inner ellipse
	  IF (q < r1) EXIT
	!     Reject P if outside outer ellipse
	  IF (q > r2) CYCLE
	!     Reject P if outside acceptance region
	  IF (v**2 < -4.0*LOG(u)*u**2) EXIT
	END DO

	!     Return ratio of P's coordinates as the normal deviate
	fn_val = v/u
	RETURN

	END FUNCTION random_normal

!#######################################################################
	FUNCTION random_exponential() RESULT(fn_val)

	! Adapted from Fortran 77 code from the book:
	!     Dagpunar, J. 'Principles of random variate generation'
	!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9

	! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM
	! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL
	! TO EXP(-random_exponential), USING INVERSION.

	REAL  :: fn_val

	!     Local variable
	REAL  :: r
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	DO
	  CALL RANDOM_NUMBER(r)
	  IF (r > zero) EXIT
	END DO

	fn_val = -LOG(r)
	RETURN

	END FUNCTION random_exponential

!#######################################################################
  SUBROUTINE tridiag(n,a,b,c,d)

!! to solve system of linear eqs on tridiagonal matrix n times n
!! after Peaceman and Rachford, 1955
!! a,b,c,d - are vectors of order n 
!! a,b,c - are coefficients on the LHS
!! d - is initially RHS on the output becomes a solution vector
    
!-------------------------------------------------------------------

    INTEGER, INTENT(in):: n
    REAL, DIMENSION(n), INTENT(in) :: a,b
    REAL, DIMENSION(n), INTENT(inout) :: c,d
    
    INTEGER :: i
    REAL :: p
    REAL, DIMENSION(n) :: q
    
    c(n)=0.
    q(1)=-c(1)/b(1)
    d(1)=d(1)/b(1)
    
    DO i=2,n
       p=1./(b(i)+a(i)*q(i-1))
       q(i)=-c(i)*p
       d(i)=(d(i)-a(i)*d(i-1))*p
    ENDDO
    
    DO i=n-1,1,-1
       d(i)=d(i)+q(i)*d(i+1)
    ENDDO

  END SUBROUTINE tridiag


!#######################################################################
subroutine Poisson(istart,iend,jstart,jend,mu,POI,seed)
implicit none
integer, intent(in) :: istart,iend,jstart,jend
real,dimension(istart:iend,jstart:jend),intent(in) :: MU
integer, dimension(istart:iend,jstart:jend), intent(out) :: POI
integer,dimension(2),intent(in) :: seed
integer :: seed_len,i,j
integer,allocatable:: the_seed(:)

!if (seed .le. 0) then seed=max(-seed,1)


call random_seed(SIZE=seed_len)
allocate(the_seed(seed_len))
the_seed(1:2)=seed
! Gfortran uses longer seeds, so fill the rest with zero
if (seed_len > 2) the_seed(3:) = seed(2)
 
 
!yhc note: if this random_seed is commented out, the dry SCM would produce strange results
call random_seed(put=the_seed)


do i=istart,iend
 do j=jstart,jend
    poi(i,j)=poidev(mu(i,j))
    
enddo
 enddo

deallocate(the_seed)  ! yhc added

end subroutine Poisson

!#######################################################################
FUNCTION poidev(xm)
!USE nrtype
!USE nr, ONLY : gammln,ran1
IMPLICIT NONE
INTEGER, PARAMETER :: SP = KIND(1.0)
REAL(SP), INTENT(IN) :: xm
REAL(SP) :: poidev
REAL(SP), PARAMETER :: PI=3.141592653589793238462643383279502884197_sp
!Returns as a floating-point number an integer value that is a random deviate drawn from a
!Poisson distribution of mean xm, using ran1 as a source of uniform random deviates.
REAL(SP) :: em,harvest,t,y
REAL(SP), SAVE :: alxm,g,oldm=-1.0_sp,sq
REAL(SP) :: tt1
!oldm is a flag for whether xm has changed since last call.
if (xm < 12.0) then !Use direct method.
!write(6,*) 'qq1, direct method'
if (xm /= oldm) then
oldm=xm
g=exp(-xm) !If xm is new, compute the exponential.
end if
em=-1
t=1.0
do
em=em+1.0_sp     !Instead of adding exponential deviates it is
                 !equivalent to multiply uniform deviates.
                 !We never actually have to take the log;
                 !merely compare to the pre-computed exponential.
call random_number(harvest)
!write(6,*) 'qq1, harvest',harvest

t=t*harvest
if (t <= g) exit
end do
!write(6,*) 'qq1, direct method, em',em

else      !    Use rejection method.
!write(6,*) 'qq1, rejection method, em',em
if (xm /= oldm) then  !If xm has changed since the last call, then precompute
                       !some functions that occur below.
oldm=xm
sq=sqrt(2.0_sp*xm)
alxm=log(xm)
g=xm*alxm-gammln_s(xm+1.0_sp) ! The function gammln is the natural log of the
end if                      ! gamma function, as given in §6.1.
do
do
call random_number(harvest)  !y is a deviate from a Lorentzian comparison
y=tan(PI*harvest)   !function.
em=sq*y+xm          !em is y, shifted and scaled.
if (em >= 0.0) exit !Reject if in regime of zero probability.
end do

em=int(em)          ! The trick for integer-valued distributions.
!write(6,*) 'qq1, rejection method, em',em

!<-- yhc
tt1=em+1.0_sp
if (tt1.le.0.) then
  !write(6,*) 'ggg, poidev,1 em,sq,y,xm', em,sq,y,xm
  !if (em.le.0.) em=int(1.)  ! yhc
  !write(6,*) 'ggg, poidev,2 em,sq,y,xm', em,sq,y,xm
  if (do_stop_run) call error_mesg(' mass_flux_mod',' poidev, em+1 is negative', FATAL )
endif
!--> yhc

t=0.9_sp*(1.0_sp+y**2)*exp(em*alxm-gammln_s(em+1.0_sp)-g)
!The ratio of the desired distribution to the comparison function; we accept or reject
!by comparing it to another uniform deviate. The factor 0.9 is chosen so that t never
!exceeds 1.
call random_number(harvest)
if (harvest <= t) exit
end do
end if
poidev=em
END FUNCTION poidev
        
!#######################################################################
FUNCTION arth_d(first,increment,n)
implicit none
INTEGER, PARAMETER :: SP = KIND(1.0)
INTEGER, PARAMETER :: DP = KIND(1.0D0)
INTEGER, PARAMETER :: I4B = SELECTED_INT_KIND(9)
REAL(DP), INTENT(IN) :: first,increment
INTEGER(I4B), PARAMETER :: NPAR_ARTH=16,NPAR2_ARTH=8
INTEGER(I4B), INTENT(IN) :: n
REAL(DP), DIMENSION(n) :: arth_d
INTEGER(I4B) :: k,k2
REAL(DP) :: temp
if (n > 0) arth_d(1)=first
if (n <= NPAR_ARTH) then
do k=2,n
arth_d(k)=arth_d(k-1)+increment
end do
else
do k=2,NPAR2_ARTH
arth_d(k)=arth_d(k-1)+increment
end do
temp=increment*NPAR2_ARTH
k=NPAR2_ARTH
do
if (k >= n) exit
k2=k+k
arth_d(k+1:min(k2,n))=temp+arth_d(1:min(k,n-k))
temp=temp+temp
k=k2
end do
end if
END FUNCTION arth_d
      
!#######################################################################
FUNCTION gammln_s(xx)
IMPLICIT NONE
INTEGER, PARAMETER :: SP = KIND(1.0)
INTEGER, PARAMETER :: DP = KIND(1.0D0)
REAL(SP), INTENT(IN) :: xx
REAL(SP) :: gammln_s
!Returns the value ln[Γ(xx)] for xx > 0.
REAL(DP) :: tmp,x
!Internal arithmetic will be done in double precision, a nicety that you can omit if five-figure
!accuracy is good enough.
REAL(DP) :: stp = 2.5066282746310005_dp
REAL(DP), DIMENSION(6) :: coef = (/76.18009172947146_dp,&
-86.50532032941677_dp,24.01409824083091_dp,&
-1.231739572450155_dp,0.1208650973866179e-2_dp,&
-0.5395239384953e-5_dp/)
!call assert(xx > 0.0, ’gammln_s arg’)
!if (xx .le. 0.) print *,'gammaln fails'

!<-- yhc
!if (xx .le. 0.) then
!  write(6,*),'ggg, gammaln fails, ',xx
!  if (do_stop_run) call error_mesg(' mass_flux_mod',' gammaln fails', FATAL )
!endif
!--> yhc

x=xx
tmp=x+5.5_dp
tmp=(x+0.5_dp)*log(tmp)-tmp
gammln_s=tmp+log(stp*(1.000000000190015_dp+&
sum(coef(:)/arth_d(x+1.0_dp,1.0_dp,size(coef))))/x)
END FUNCTION gammln_s

!#############################

!#############################
! ignpoi relevant programs
!#############################

subroutine advance_state ( k )

!*****************************************************************************80
!
!! ADVANCE_STATE advances the state of the current generator.
!
!  Discussion:
!
!    This procedure advances the state of the current generator by 2^K 
!    values and resets the initial seed to that value.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) K, indicates that the generator is to be 
!    advanced by 2^K values.
!    0 <= K.
!
  implicit none

  integer ( kind = 4 ), parameter :: a1 = 40014
  integer ( kind = 4 ), parameter :: a2 = 40692
  integer ( kind = 4 ) b1
  integer ( kind = 4 ) b2
  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  !logical initialized_get
  integer ( kind = 4 ) k
  integer ( kind = 4 ), parameter :: m1 = 2147483563
  integer ( kind = 4 ), parameter :: m2 = 2147483399
  !integer ( kind = 4 ) multmod

  if ( k < 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'ADVANCE_STATE - Fatal error!'
    write ( *, '(a)' ) '  Input exponent K is out of bounds.'
    stop 1
  end if
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'ADVANCE_STATE - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get the current generator index.
!
  g = cgn_get ( )

  b1 = a1
  b2 = a2

  do i = 1, k
    b1 = multmod ( b1, b1, m1 )
    b2 = multmod ( b2, b2, m2 )
  end do

  call cg_get ( g, cg1, cg2 )
  cg1 = multmod ( b1, cg1, m1 )
  cg2 = multmod ( b2, cg2, m2 )
  call cg_set ( g, cg1, cg2 )

  return
end
function antithetic_get ( )

!*****************************************************************************80
!
!! ANTITHETIC_GET queries the antithetic value for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Output, logical ANTITHETIC_GET, is TRUE if generator G is antithetic.
!
  implicit none

  logical antithetic_get
  integer ( kind = 4 ) i
  logical value

  i = -1
  call antithetic_memory ( i, value )

  antithetic_get = value

  return
end
subroutine antithetic_memory ( i, value )

!*****************************************************************************80
!
!! ANTITHETIC_MEMORY stores the antithetic value for all generators.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get a value.
!    0, initialize all values.
!    1, set a value.
!
!    Input/output, logical VALUE.  For I = -1, VALUE is an output
!    quantity, for I = +1, an input quantity.
!
  implicit none

  integer ( kind = 4 ), parameter :: g_max = 32

  logical a_save(g_max)
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  logical value

  save a_save

  data a_save / 32 * .false. /

  if ( i < 0 ) then
    g = cgn_get ( )
    value = a_save(g)
  else if ( i == 0 ) then
    a_save(1:g_max) = .false.
  else if ( 0 < i ) then
    g = cgn_get ( )
    a_save(g) = value
  end if

  return
end
subroutine antithetic_set ( value )

!*****************************************************************************80
!
!! ANTITHETIC_SET sets the antithetic value for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, logical VALUE, is TRUE if generator G is to be antithetic.
!
  implicit none

  integer ( kind = 4 ) i
  logical value

  i = +1
  call antithetic_memory ( i, value )

  return
end
subroutine cg_get ( g, cg1, cg2 )

!*****************************************************************************80
!
!! CG_GET queries the CG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Output, integer ( kind = 4 ) CG1, CG2, the CG values for generator G.
!
  implicit none

  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i

  i = -1
  call cg_memory ( i, g, cg1, cg2 )

  return
end
subroutine cg_memory ( i, g, cg1, cg2 )

!*****************************************************************************80
!
!! CG_MEMORY stores the CG values for all generators.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get a value.
!    0, initialize all values.
!    1, set a value.
!
!    Input, integer ( kind = 4 ) G, for I = -1 or +1, the index of 
!    the generator, with 1 <= G <= 32.
!
!    Input/output, integer ( kind = 4 ) CG1, CG2.  For I = -1, 
!    these are output, for I = +1, these are input, for I = 0,
!    these arguments are ignored.  When used, the arguments are
!    old or new values of the CG parameter for generator G.
!
  implicit none

  integer ( kind = 4 ), parameter :: g_max = 32

  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg1_save(g_max)
  integer ( kind = 4 ) cg2
  integer ( kind = 4 ) cg2_save(g_max)
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i

  save cg1_save
  save cg2_save

  data cg1_save / 32 * 0 /
  data cg2_save / 32 * 0 /

  if ( g < 1 .or. g_max < g ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'CG_MEMORY - Fatal error!'
    write ( *, '(a)' ) '  Input generator index G is out of bounds.'
    stop 1
  end if

  if ( i < 0 ) then
    cg1 = cg1_save(g)
    cg2 = cg2_save(g)
  else if ( i == 0 ) then
    cg1_save(1:g_max) = 0
    cg2_save(1:g_max) = 0
  else if ( 0 < i ) then
    cg1_save(g) = cg1
    cg2_save(g) = cg2
  end if

  return
end
subroutine cg_set ( g, cg1, cg2 )

!*****************************************************************************80
!
!! CG_SET sets the CG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Input, integer ( kind = 4 ) CG1, CG2, the CG values for generator G.
!
  implicit none

  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i

  i = +1
  call cg_memory ( i, g, cg1, cg2 )

  return
end
function cgn_get ( )

!*****************************************************************************80
!
!! CGN_GET gets the current generator index.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Output, integer ( kind = 4 ) CGN_GET, the current generator index.
!    1 <= CGN_GET <= 32.
!
  implicit none

  integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i

  i = -1
  call cgn_memory ( i, g )

  cgn_get = g

  return
end
subroutine cgn_memory ( i, g )

!*****************************************************************************80
!
!! CGN_MEMORY stores the current generator index.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get the value.
!    0, initialize the value.
!    1, set the value.
!
!    Input/output, integer ( kind = 4 ) G.  For I = -1 or 0,
!    this is output, for I = +1, this is input.
!
  implicit none

  integer ( kind = 4 ), parameter :: g_max = 32

  integer ( kind = 4 ) g
  integer ( kind = 4 ) g_save
  integer ( kind = 4 ) i

  save g_save

  data g_save / 1 /

  if ( i < 0 ) then

    g = g_save

  else if ( i == 0 ) then

    g_save = 1
    g = g_save

  else if ( 0 < i ) then

    if ( g < 1 .or. g_max < g ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'CGN_MEMORY - Fatal error!'
      write ( *, '(a)' ) '  Generator index G is out of bounds.'
      stop 1
    end if

    g_save = g

  end if

  return
end
subroutine cgn_set ( g )

!*****************************************************************************80
!
!! CGN_SET sets the current generator index.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i

  i = +1
  call cgn_memory ( i, g )

  return
end
subroutine get_state ( cg1, cg2 )

!*****************************************************************************80
!
!! GET_STATE returns the state of the current generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Output, integer ( kind = 4 ) CG1, CG2, the CG values for the
!    current generator.
!
  implicit none

  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  !logical initialized_get
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GET_STATE - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get the current generator index.
!
  g = cgn_get ( )
!
!  Retrieve the seed values for this generator.
!
  call cg_get ( g, cg1, cg2 )

  return
end
function i4_uni ( )

!*****************************************************************************80
!
!! I4_UNI generates a random positive integer.
!
!  Discussion:
!
!    This procedure returns a random integer following a uniform distribution 
!    over (1, 2147483562) using the current generator.
!
!    The original name of this function was "random()", but this conflicts
!    with a standard library function name in C.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    05 August 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Output, integer ( kind = 4 ) I4_UNI, the random integer.
!
  implicit none

  integer ( kind = 4 ), parameter :: a1 = 40014
  integer ( kind = 4 ), parameter :: a2 = 40692
  !logical antithetic_get
  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  integer ( kind = 4 ) i4_uni
  !logical initialized_get
  integer ( kind = 4 ) k
  integer ( kind = 4 ), parameter :: m1 = 2147483563
  integer ( kind = 4 ), parameter :: m2 = 2147483399
  logical value
  integer ( kind = 4 ) z
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'I4_UNI - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get the current generator index.
!
  g = cgn_get ( )
!
!  Retrieve the seeds for the current generator.
!
  call cg_get ( g, cg1, cg2 )
!
!  Update the seeds.
!
  k = cg1 / 53668
  cg1 = a1 * ( cg1 - k * 53668 ) - k * 12211

  if ( cg1 < 0 ) then
    cg1 = cg1 + m1
  end if

  k = cg2 / 52774
  cg2 = a2 * ( cg2 - k * 52774 ) - k * 3791

  if ( cg2 < 0 ) then
    cg2 = cg2 + m2
  end if
!
!  Store the updated seeds.
!
  call cg_set ( g, cg1, cg2 )
!
!  Construct the random integer from the seeds.
!
  z = cg1 - cg2

  if ( z < 1 ) then
    z = z + m1 - 1
  end if
!
!  If the generator is in antithetic mode, we must reflect the value.
!
  value = antithetic_get ( )

  if ( value ) then
    z = m1 - z
  end if

  i4_uni = z

  return
end
subroutine ig_get ( g, ig1, ig2 )

!*****************************************************************************80
!
!! IG_GET queries the IG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Output, integer ( kind = 4 ) IG1, IG2, the IG values for generator G.
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig2

  i = -1
  call ig_memory ( i, g, ig1, ig2 )

  return
end
subroutine ig_memory ( i, g, ig1, ig2 )

!*****************************************************************************80
!
!! IG_MEMORY stores the IG values for all generators.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get a value.
!    0, initialize all values.
!    1, set a value.
!
!    Input, integer ( kind = 4 ) G, for I = -1 or +1, the index of 
!    the generator, with 1 <= G <= 32.
!
!    Input/output, integer ( kind = 4 ) IG1, IG2.  For I = -1, 
!    these are output, for I = +1, these are input, for I = 0,
!    these arguments are ignored.  When used, the arguments are
!    old or new values of the IG parameter for generator G.
!
  implicit none

  integer ( kind = 4 ), parameter :: g_max = 32

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig1_save(g_max)
  integer ( kind = 4 ) ig2
  integer ( kind = 4 ) ig2_save(g_max)

  save ig1_save
  save ig2_save

  data ig1_save / 32 * 0 /
  data ig2_save / 32 * 0 /

  if ( g < 1 .or. g_max < g ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IG_MEMORY - Fatal error!'
    write ( *, '(a)' ) '  Input generator index G is out of bounds.'
    stop 1
  end if

  if ( i < 0 ) then
    ig1 = ig1_save(g)
    ig2 = ig2_save(g)
  else if ( i == 0 ) then
    ig1_save(1:g_max) = 0
    ig2_save(1:g_max) = 0
  else if ( 0 < i ) then
    ig1_save(g) = ig1
    ig2_save(g) = ig2
  end if

  return
end
subroutine ig_set ( g, ig1, ig2 )

!*****************************************************************************80
!
!! IG_SET sets the IG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Input, integer ( kind = 4 ) IG1, IG2, the IG values for generator G.
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig2

  i = +1
  call ig_memory ( i, g, ig1, ig2 )

  return
end
subroutine init_generator ( t )

!*****************************************************************************80
!
!! INIT_GENERATOR sets the current generator to initial, last or new seed.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) T, the seed type:
!    0, use the seed chosen at initialization time.
!    1, use the last seed.
!    2, use a new seed set 2^30 values away.
!
  implicit none

  integer ( kind = 4 ), parameter :: a1_w = 1033780774
  integer ( kind = 4 ), parameter :: a2_w = 1494757890
  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig2
  !logical initialized_get
  integer ( kind = 4 ) lg1
  integer ( kind = 4 ) lg2
  integer ( kind = 4 ), parameter :: m1 = 2147483563
  integer ( kind = 4 ), parameter :: m2 = 2147483399
  !integer ( kind = 4 ) multmod
  integer ( kind = 4 ) t
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'INIT_GENERATOR - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get the current generator index.
!
  g = cgn_get ( )
!
!  0: restore the initial seed.
!
  if ( t == 0 ) then

    call ig_get ( g, ig1, ig2 )
    lg1 = ig1
    lg2 = ig2
    call lg_set ( g, lg1, lg2 )
!
!  1: restore the last seed.
!
  else if ( t == 1 ) then

    call lg_get ( g, lg1, lg2 )
!
!  2: advance to a new seed.
!
  else if ( t == 2 ) then

    call lg_get ( g, lg1, lg2 )
    lg1 = multmod ( a1_w, lg1, m1 )
    lg2 = multmod ( a2_w, lg2, m2 )
    call lg_set ( g, lg1, lg2 )

  else

    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'INIT_GENERATOR - Fatal error!'
    write ( *, '(a)' ) '  Input parameter T out of bounds.'
    stop 1

  end if
!
!  Store the new seed.
!
  cg1 = lg1
  cg2 = lg2
  call cg_set ( g, cg1, cg2 )

  return
end
subroutine initialize ( )

!*****************************************************************************80
!
!! INITIALIZE initializes the random number generator library.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    30 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    None
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ), parameter :: g_max = 32
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig2
  logical value
!
!  Remember that we have called INITIALIZE().
!
  call initialized_set ( )
!
!  Initialize all generators to have FALSE antithetic value.
!
  value = .false.
  do g = 1, g_max
    call cgn_set ( g )
    call antithetic_set ( value )
  end do
!
!  Set the initial seeds.
!
  ig1 = 1234567890
  ig2 = 123456789
  call set_initial_seed ( ig1, ig2 )
!
!  Initialize the current generator index to the first one.
!
  g = 1
  call cgn_set ( g )

  !write ( *, '(a)' ) ' '
  !write ( *, '(a)' ) 'INITIALIZE - Note:'
  !write ( *, '(a)' ) '  The RNGLIB package has been initialized.'

  return
end
function initialized_get ( )

!*****************************************************************************80
!
!! INITIALIZED_GET queries the INITIALIZED value.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    28 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Output, logical INITIALIZED_GET, is TRUE if the package has 
!    been initialized.
!
  implicit none

  integer ( kind = 4 ) i
  logical initialized
  logical initialized_get

  i = -1
  call initialized_memory ( i, initialized )

  initialized_get = initialized

  return
end
subroutine initialized_memory ( i, initialized )

!*****************************************************************************80
!
!! INITIALIZED_MEMORY stores the INITIALIZED value for the package.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    28 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get the value.
!    0, initialize the value.
!    1, set the value.
!
!    Input/output, logical INITIALIZED.  For I = -1, 
!    this is output, for I = +1, this is input, for I = 0,
!    this argument is ignored.  
!
  implicit none

  integer ( kind = 4 ) i
  logical initialized
  logical initialized_save

  save initialized_save

  data initialized_save / .false. /

  if ( i < 0 ) then
    initialized = initialized_save
  else if ( i == 0 ) then
    initialized_save = .false.
  else if ( 0 < i ) then
    initialized_save = initialized
  end if

  return
end
subroutine initialized_set ( )

!*****************************************************************************80
!
!! INITIALIZED_SET sets the INITIALIZED value true.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    28 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    None
!
  implicit none

  integer ( kind = 4 ) i
  logical initialized

  i = +1
  initialized = .true.
  call initialized_memory ( i, initialized )

  return
end
subroutine lg_get ( g, lg1, lg2 )

!*****************************************************************************80
!
!! LG_GET queries the LG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Output, integer ( kind = 4 ) LG1, LG2, the LG values for generator G.
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) lg1
  integer ( kind = 4 ) lg2

  i = -1
  call lg_memory ( i, g, lg1, lg2 )

  return
end
subroutine lg_memory ( i, g, lg1, lg2 )

!*****************************************************************************80
!
!! LG_MEMORY stores the LG values for all generators.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) I, the desired action.
!    -1, get a value.
!    0, initialize all values.
!    1, set a value.
!
!    Input, integer ( kind = 4 ) G, for I = -1 or +1, the index of 
!    the generator, with 1 <= G <= 32.
!
!    Input/output, integer ( kind = 4 ) LG1, LG2.  For I = -1, 
!    these are output, for I = +1, these are input, for I = 0,
!    these arguments are ignored.  When used, the arguments are
!    old or new values of the LG parameter for generator G.
!
  implicit none

  integer ( kind = 4 ), parameter :: g_max = 32

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) lg1
  integer ( kind = 4 ) lg1_save(g_max)
  integer ( kind = 4 ) lg2
  integer ( kind = 4 ) lg2_save(g_max)

  save lg1_save
  save lg2_save

  data lg1_save / 32 * 0 /
  data lg2_save / 32 * 0 /

  if ( g < 1 .or. g_max < g ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'LG_MEMORY - Fatal error!'
    write ( *, '(a)' ) '  Input generator index G is out of bounds.'
    stop 1
  end if

  if ( i < 0 ) then
    lg1 = lg1_save(g)
    lg2 = lg2_save(g)
  else if ( i == 0 ) then
    lg1_save(1:g_max) = 0
    lg2_save(1:g_max) = 0
  else if ( 0 < i ) then
    lg1_save(g) = lg1
    lg2_save(g) = lg2
  end if

  return
end
subroutine lg_set ( g, lg1, lg2 )

!*****************************************************************************80
!
!! LG_SET sets the LG values for a given generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) G, the index of the generator.
!    1 <= G <= 32.
!
!    Input, integer ( kind = 4 ) LG1, LG2, the LG values for generator G.
!
  implicit none

  integer ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) lg1
  integer ( kind = 4 ) lg2

  i = +1
  call lg_memory ( i, g, lg1, lg2 )

  return
end
function multmod ( a, s, m )

!*****************************************************************************80
!
!! MULTMOD carries out modular multiplication.
!
!  Discussion:
!
!    This procedure returns 
!
!      ( A * S ) mod M
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    26 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) A, S, M, the arguments.
!
!    Output, integer ( kind = 4 ) MULTMOD, the value of the product of A and S, 
!    modulo M.
!
  implicit none

  integer ( kind = 4 ) a
  integer ( kind = 4 ) a0
  integer ( kind = 4 ) a1
  integer ( kind = 4 ), parameter :: h = 32768
  integer ( kind = 4 ) k
  integer ( kind = 4 ) m
  integer ( kind = 4 ) multmod
  integer ( kind = 4 ) p
  integer ( kind = 4 ) q
  integer ( kind = 4 ) qh
  integer ( kind = 4 ) rh
  integer ( kind = 4 ) s

  if ( a <= 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'MULTMOD - Fatal error!'
    write ( *, '(a)' ) '  A <= 0.'
    stop 1
  end if

  if ( m <= a ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'MULTMOD - Fatal error!'
    write ( *, '(a)' ) '  M <= A.'
    stop 1
  end if

  if ( s <= 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'MULTMOD - Fatal error!'
    write ( *, '(a)' ) '  S <= 0.'
    stop 1
  end if

  if ( m <= s ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'MULTMOD - Fatal error!'
    write ( *, '(a)' ) '  M <= S.'
    stop 1
  end if

  if ( a < h ) then

    a0 = a
    p = 0

  else

    a1 = a / h
    a0 = a - h * a1
    qh = m / h
    rh = m - h * qh

    if ( h <= a1 ) then
   
      a1 = a1 - h
      k = s / qh
      p = h * ( s - k * qh ) - k * rh

      do while ( p < 0 )
        p = p + m
      end do

    else

      p = 0

    end if

    if ( a1 /= 0 ) then

      q = m / a1
      k = s / q
      p = p - k * ( m - a1 * q )

      if ( 0 < p ) then
        p = p - m
      end if

      p = p + a1 * ( s - k * q )

      do while ( p < 0 )
        p = p + m
      end do

    end if

    k = p / qh
    p = h * ( p - k * qh ) - k * rh

    do while ( p < 0 )
      p = p + m
    end do

  end if

  if ( a0 /= 0 ) then

    q = m / a0
    k = s / q
    p = p - k * ( m - a0 * q )

    if ( 0 < p ) then
      p = p - m
    end if

    p = p + a0 * ( s - k * q )

    do while ( p < 0 )
      p = p + m
    end do

  end if

  multmod = p

  return
end
function r4_uni_01 ( )

!*****************************************************************************80
!
!! R4_UNI_01 returns a uniform random real number in [0,1].
!
!  Discussion:
!
!    This procedure returns a random floating point number from a uniform 
!    distribution over (0,1), not including the endpoint values, using the
!    current random number generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    05 August 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Output, real ( kind = 4 ) R4_UNI_01, a uniform random value in [0,1].
!
  implicit none

  integer ( kind = 4 ) i
  !integer ( kind = 4 ) i4_uni
  !logical initialized_get
  real ( kind = 4 ) r4_uni_01
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    !write ( *, '(a)' ) ' '
    !write ( *, '(a)' ) 'R4_UNI_01 - Note:'
    !write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get a random positive integer.
!
  i = i4_uni ( )
!
!  Scale it to a random real in [0,1].
!
  r4_uni_01 = real ( i, kind = 4 ) * 4.656613057E-10

  return
end
function r8_uni_01 ( )

!*****************************************************************************80
!
!! R8_UNI_01 returns a uniform random double precision number in [0,1].
!
!  Discussion:
!
!    This procedure returns a random floating point number from a uniform 
!    distribution over (0,1), not including the endpoint values, using the
!    current random number generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    05 August 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Output, real ( kind = 8 ) R8_UNI_01, a uniform random value in [0,1].
!
  implicit none

  integer ( kind = 4 ) i
  !integer ( kind = 4 ) i4_uni
  !logical initialized_get
  real ( kind = 8 ) r8_uni_01
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'R8_UNI_01 - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Get a random positive integer.
!
  i = i4_uni ( )
!
!  Scale it to a random real in [0,1].
!
  r8_uni_01 = real ( i, kind = 8 ) * 4.656613057D-10

  return
end
subroutine set_initial_seed ( ig1, ig2 )

!*****************************************************************************80
!
!! SET_INITIAL_SEED resets the initial seed and state for all generators.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    28 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) IG1, IG2, the initial seed values 
!    for the first generator.
!    1 <= IG1 < 2147483563
!    1 <= IG2 < 2147483399
!
  implicit none

  integer ( kind = 4 ), parameter :: a1_vw = 2082007225
  integer ( kind = 4 ), parameter :: a2_vw = 784306273
  integer ( kind = 4 ) g
  integer ( kind = 4 ), parameter :: g_max = 32
  integer ( kind = 4 ) ig1
  integer ( kind = 4 ) ig2
  !logical initialized_get
  integer ( kind = 4 ), parameter :: m1 = 2147483563
  integer ( kind = 4 ), parameter :: m2 = 2147483399
  !integer ( kind = 4 ) multmod
  integer ( kind = 4 ) t

  if ( ig1 < 1 .or. m1 <= ig1 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_INITIAL_SEED - Fatal error!'
    write ( *, '(a)' ) '  Input parameter IG1 out of bounds.'
    stop 1
  end if

  if ( ig2 < 1 .or. m2 <= ig2 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_INITIAL_SEED - Fatal error!'
    write ( *, '(a)' ) '  Input parameter IG2 out of bounds.'
    stop 1
  end if
!
!  Because INITIALIZE calls SET_INITIAL_SEED, it's not easy to correct
!  the error that arises if SET_INITIAL_SEED is called before INITIALIZE.
!  So don't bother trying.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_INITIAL_SEED - Fatal error!'
    write ( *, '(a)' ) '  The RNGLIB package has not been initialized.'
    stop 1
  end if
!
!  Set the initial seed, then initialize the first generator.
!
  g = 1
  call cgn_set ( g )

  call ig_set ( g, ig1, ig2 )

  t = 0
  call init_generator ( t )
!
!  Now do similar operations for the other generators.
!
  do g = 2, g_max

    call cgn_set ( g )
    ig1 = multmod ( a1_vw, ig1, m1 )
    ig2 = multmod ( a2_vw, ig2, m2 )
    call ig_set ( g, ig1, ig2 )
    call init_generator ( t )

  end do
!
!  Now choose the first generator.
!
  g = 1
  call cgn_set ( g )

  return
end
subroutine set_seed ( cg1, cg2 )

!*****************************************************************************80
!
!! SET_SEED resets the initial seed and state of the current generator.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original Pascal version by Pierre L'Ecuyer, Serge Cote.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Pierre LEcuyer, Serge Cote,
!    Implementing a Random Number Package with Splitting Facilities,
!    ACM Transactions on Mathematical Software,
!    Volume 17, Number 1, March 1991, pages 98-111.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) CG1, CG2, the CG values for generator G.
!    1 <= CG1 < 2147483563
!    1 <= CG2 < 2147483399
!
  implicit none

  integer ( kind = 4 ) cg1
  integer ( kind = 4 ) cg2
  !integer ( kind = 4 ) cgn_get
  integer ( kind = 4 ) g
  !logical initialized_get
  integer ( kind = 4 ), parameter :: m1 = 2147483563
  integer ( kind = 4 ), parameter :: m2 = 2147483399
  integer ( kind = 4 ) t

  if ( cg1 < 1 .or. m1 <= cg1 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_SEED - Fatal error!'
    write ( *, '(a)' ) '  Input parameter CG1 out of bounds.'
    stop 1
  end if

  if ( cg2 < 1 .or. m2 <= cg2 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_SEED - Fatal error!'
    write ( *, '(a)' ) '  Input parameter CG2 out of bounds.'
    stop 1
  end if
!
!  Check whether the package must be initialized.
!
  if ( .not. initialized_get ( ) ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SET_SEED - Note:'
    write ( *, '(a)' ) '  Initializing RNGLIB package.'
    call initialize ( )
  end if
!
!  Retrieve the current generator index.
!
  g = cgn_get ( )
!
!  Set the seeds.
!
  call cg_set ( g, cg1, cg2 )
!
!  Initialize the generator.
!
  t = 0
  call init_generator ( t )

  return
end
subroutine timestamp ( )

!*****************************************************************************80
!
!! TIMESTAMP prints the current YMDHMS date as a time stamp.
!
!  Example:
!
!    31 May 2001   9:45:54.872 AM
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    18 May 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    None
!
  implicit none

  character ( len = 8 ) ampm
  integer ( kind = 4 ) d
  integer ( kind = 4 ) h
  integer ( kind = 4 ) m
  integer ( kind = 4 ) mm
  character ( len = 9 ), parameter, dimension(12) :: month = (/ &
    'January  ', 'February ', 'March    ', 'April    ', &
    'May      ', 'June     ', 'July     ', 'August   ', &
    'September', 'October  ', 'November ', 'December ' /)
  integer ( kind = 4 ) n
  integer ( kind = 4 ) s
  integer ( kind = 4 ) values(8)
  integer ( kind = 4 ) y

  call date_and_time ( values = values )

  y = values(1)
  m = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if

  write ( *, '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
    d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm )

  return
end

function genbet ( aa, bb )

!*****************************************************************************80
!
!! GENBET generates a beta random deviate.
!
!  Discussion:
!
!    This procedure returns a single random deviate from the beta distribution
!    with parameters A and B.  The density is
!
!      x^(a-1) * (1-x)^(b-1) / Beta(a,b) for 0 < x < 1
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    19 September 2014
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Russell Cheng,
!    Generating Beta Variates with Nonintegral Shape Parameters,
!    Communications of the ACM,
!    Volume 21, Number 4, April 1978, pages 317-322.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) AA, the first parameter of the beta distribution.
!    0.0 < AA.
!
!    Input, real ( kind = 4 ) BB, the second parameter of the beta distribution.
!    0.0 < BB.
!
!    Output, real ( kind = 4 ) GENBET, a beta random variate.
!
  implicit none

  real ( kind = 4 ) a
  real ( kind = 4 ) aa
  real ( kind = 4 ) alpha
  real ( kind = 4 ) b
  real ( kind = 4 ) bb
  real ( kind = 4 ) beta
  real ( kind = 4 ) delta
  real ( kind = 4 ) gamma
  real ( kind = 4 ) genbet
  real ( kind = 4 ) k1
  real ( kind = 4 ) k2
  real ( kind = 4 ), parameter :: log4 = 1.3862943611198906188E+00
  real ( kind = 4 ), parameter :: log5 = 1.6094379124341003746E+00
  real ( kind = 4 ) r
  !real ( kind = 4 ) r4_exp
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) s
  real ( kind = 4 ) t
  real ( kind = 4 ) u1
  real ( kind = 4 ) u2
  real ( kind = 4 ) v
  real ( kind = 4 ) w
  real ( kind = 4 ) y
  real ( kind = 4 ) z

  if ( aa <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENBET - Fatal error!'
    write ( *, '(a)' ) '  AA <= 0.0'
    stop 1
  end if

  if ( bb <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENBET - Fatal error!'
    write ( *, '(a)' ) '  BB <= 0.0'
    stop 1
  end if
!
!  Algorithm BB
!
  if ( 1.0E+00 < aa .and. 1.0E+00 < bb ) then

    a = min ( aa, bb )
    b = max ( aa, bb )
    alpha = a + b
    beta = sqrt ( ( alpha - 2.0E+00 ) / ( 2.0E+00 * a * b - alpha ) )
    gamma = a + 1.0E+00 / beta

    do

      u1 = r4_uni_01 ( )
      u2 = r4_uni_01 ( )
      v = beta * log ( u1 / ( 1.0E+00 - u1 ) )
!
!  exp ( v ) replaced by r4_exp ( v )
!
      w = a * r4_exp ( v )

      z = u1 ** 2 * u2
      r = gamma * v - log4
      s = a + r - w

      if ( 5.0E+00 * z <= s + 1.0E+00 + log5 ) then
        exit
      end if

      t = log ( z )
      if ( t <= s ) then
        exit
      end if

      if ( t <= ( r + alpha * log ( alpha / ( b + w ) ) ) ) then
        exit
      end if

    end do
!
!  Algorithm BC
!
  else

    a = max ( aa, bb )
    b = min ( aa, bb )
    alpha = a + b
    beta = 1.0E+00 / b
    delta = 1.0E+00 + a - b
    k1 = delta * ( 1.0E+00 / 72.0E+00 + b / 24.0E+00 ) &
      / ( a / b - 7.0E+00 / 9.0E+00 )
    k2 = 0.25E+00 + ( 0.5E+00 + 0.25E+00 / delta ) * b

    do

      u1 = r4_uni_01 ( )
      u2 = r4_uni_01 ( )

      if ( u1 < 0.5E+00 ) then

        y = u1 * u2
        z = u1 * y

        if ( k1 <= 0.25E+00 * u2 + z - y ) then
          cycle
        end if

      else

        z = u1 ** 2 * u2

        if ( z <= 0.25E+00 ) then

          v = beta * log ( u1 / ( 1.0E+00 - u1 ) )
          w = a * exp ( v )

          if ( aa == a ) then
            genbet = w / ( b + w )
          else
            genbet = b / ( b + w )
          end if

          return

        end if

        if ( k2 < z ) then
          cycle
        end if

      end if

      v = beta * log ( u1 / ( 1.0E+00 - u1 ) )
      w = a * exp ( v )

      if ( log ( z ) <= alpha * ( log ( alpha / ( b + w ) ) + v ) - log4 ) then
        exit
      end if

    end do

  end if

  if ( aa == a ) then
    genbet = w / ( b + w )
  else
    genbet = b / ( b + w )
  end if

  return
end
function genchi ( df )

!*****************************************************************************80
!
!! GENCHI generates a Chi-Square random deviate.
!
!  Discussion:
!
!    This procedure generates a random deviate from the chi square distribution
!    with DF degrees of freedom random variable.
!
!    The algorithm exploits the relation between chisquare and gamma.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) DF, the degrees of freedom.
!    0.0 < DF.
!
!    Output, real ( kind = 4 ) GENCHI, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) arg1
  real ( kind = 4 ) arg2
  real ( kind = 4 ) df
  real ( kind = 4 ) genchi
  !real ( kind = 4 ) gengam

  if ( df <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENCHI - Fatal error!'
    write ( *, '(a)' ) '  DF <= 0.'
    write ( *, '(a,g14.6)' ) '  Value of DF: ', df
    stop 1
  end if

  arg1 = 1.0E+00
  arg2 = df / 2.0E+00

  genchi = 2.0E+00 * gengam ( arg1, arg2 )

  return
end
function genexp ( av )

!*****************************************************************************80
!
!! GENEXP generates an exponential random deviate.
!
!  Discussion:
!
!    This procedure generates a single random deviate from an exponential
!    distribution with mean AV.
!
!    See also the function R4_EXPONENTIAL_SAMPLE.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Computer Methods for Sampling From the
!    Exponential and Normal Distributions,
!    Communications of the ACM,
!    Volume 15, Number 10, October 1972, pages 873-882.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) AV, the mean of the exponential distribution 
!    from which a random deviate is to be generated.
!
!    Output, real ( kind = 4 ) GENEXP, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) av
  real ( kind = 4 ) genexp
  !real ( kind = 4 ) sexpo

  genexp = sexpo ( ) * av

  return
end
function genf ( dfn, dfd )

!*****************************************************************************80
!
!! GENF generates an F random deviate.
!
!  Discussion:
!
!    This procedure generates a random deviate from the F (variance ratio)
!    distribution with DFN degrees of freedom in the numerator
!    and DFD degrees of freedom in the denominator.
!
!    It directly generates the ratio of chisquare variates
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) DFN, the numerator degrees of freedom.
!    0.0 < DFN.
!
!    Input, real ( kind = 4 ) DFD, the denominator degrees of freedom.
!    0.0 < DFD.
!
!    Output, real ( kind = 4 ) GENF, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) dfd
  real ( kind = 4 ) dfn
  !real ( kind = 4 ) genchi
  real ( kind = 4 ) genf
  real ( kind = 4 ) xden
  real ( kind = 4 ) xnum

  if ( dfn <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENF - Fatal error!'
    write ( *, '(a)' ) '  DFN <= 0.0'
    stop 1
  end if

  if ( dfd <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENF - Fatal error!'
    write ( *, '(a)' ) '  DFD <= 0.0'
    stop 1
  end if

  xnum = genchi ( dfn ) / dfn
  xden = genchi ( dfd ) / dfd
  genf = xnum / xden

  return
end
function gengam ( a, r )

!*****************************************************************************80
!
!! GENGAM generates a Gamma random deviate.
!
!  Discussion:
!
!    This procedure generates random deviates from the gamma distribution whose
!    density is (A^R)/Gamma(R) * X^(R-1) * Exp(-A*X)
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Generating Gamma Variates by a Modified Rejection Technique,
!    Communications of the ACM,
!    Volume 25, Number 1, January 1982, pages 47-54.
!
!    Joachim Ahrens, Ulrich Dieter,
!    Computer Methods for Sampling from Gamma, Beta, Poisson and
!    Binomial Distributions,
!    Computing,
!    Volume 12, Number 3, September 1974, pages 223-246.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) A, the location parameter.
!
!    Input, real ( kind = 4 ) R, the shape parameter.
!
!    Output, real ( kind = 4 ) GENGAM, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) a
  real ( kind = 4 ) gengam
  real ( kind = 4 ) r
  !real ( kind = 4 ) sgamma

  gengam = sgamma ( r ) / a

  return
end
subroutine genmn ( parm, x, work )

!*****************************************************************************80
!
!! GENMN generates a multivariate normal deviate.
!
!  Discussion:
!
!    The method is:
!    1) Generate P independent standard normal deviates - Ei ~ N(0,1)
!    2) Using Cholesky decomposition find A so that A'*A = COVM
!    3) A' * E + MEANV ~ N(MEANV,COVM)
!
!    Note that PARM contains information needed to generate the
!    deviates, and is set up by SETGMN.
!
!    PARM(1) contains the size of the deviates, P
!    PARM(2:P+1) contains the mean vector.
!    PARM(P+2:P*(P+3)/2+1) contains the upper half of the Cholesky
!    decomposition of the covariance matrix.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) PARM(P*(P+3)/2+1), parameters set by SETGMN.
!
!    Output, real ( kind = 4 ) X(P), a random deviate from the distribution.
!
!    Workspace, real ( kind = 4 ) WORK(P).
!
  implicit none

  real ( kind = 4 ) ae
  integer ( kind = 4 ) i
  integer ( kind = 4 ) icount
  integer ( kind = 4 ) j
  integer ( kind = 4 ) p
  real ( kind = 4 ) parm(*)
  !real ( kind = 4 ) snorm
  real ( kind = 4 ) work(*)
  real ( kind = 4 ) x(*)

  p = int ( parm(1) )
!
!  Generate P independent normal deviates.
!
  do i = 1, p
    work(i) = snorm ( )
  end do
!
!  Compute X = MEANV + A' * WORK
!
  do i = 1, p
    icount = 0
    ae = 0.0E+00
    do j = 1, i
      icount = icount + j - 1
      ae = ae + parm(i+(j-1)*p-icount+p+1) * work(j)
    end do

    x(i) = ae + parm(i+1)

  end do

  return
end
subroutine genmul ( n, p, ncat, ix )

!*****************************************************************************80
!
!! GENMUL generates a multinomial random deviate.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Luc Devroye,
!    Non-Uniform Random Variate Generation,
!    Springer, 1986,
!    ISBN: 0387963057,
!    LC: QA274.D48.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the number of events, which will be
!    classified into one of the NCAT categories.
!
!    Input, real ( kind = 4 ) P(NCAT-1).  P(I) is the probability that an event
!    will be classified into category I.  Thus, each P(I) must be between 
!    0.0 and 1.0.  Only the first NCAT-1 values of P must be defined since 
!    P(NCAT) would be 1.0 minus the sum of the first NCAT-1 P's.
!
!    Input, integer ( kind = 4 ) NCAT, the number of categories.
!
!    Output, integer ( kind = 4 ) IX(NCAT), a random observation from 
!    the multinomial distribution.  All IX(i) will be nonnegative and their 
!    sum will be N.
!
  implicit none

  integer ( kind = 4 ) n
  integer ( kind = 4 ) ncat

  integer ( kind = 4 ) i
  integer ( kind = 4 ) icat
  !integer ( kind = 4 ) ignbin
  integer ( kind = 4 ) ix(ncat)
  integer ( kind = 4 ) ntot
  real ( kind = 4 ) p(ncat-1)
  real ( kind = 4 ) prob
  real ( kind = 4 ) ptot

  if ( n < 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENMUL - Fatal error!'
    write ( *, '(a)' ) '  N < 0'
    stop 1
  end if

  if ( ncat <= 1 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENMUL - Fatal error!'
    write ( *, '(a)' ) '  NCAT <= 1'
    stop 1
  end if

  do i = 1, ncat - 1

    if ( p(i) < 0.0E+00 ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'GENMUL - Fatal error!'
      write ( *, '(a)' ) '  Some P(i) < 0.'
      stop 1
    end if

    if ( 1.0E+00 < p(i) ) then
      write ( *, '(a)' ) ' '
      write ( *, '(a)' ) 'GENMUL - Fatal error!'
      write ( *, '(a)' ) '  Some 1 < P(i).'
      stop 1
    end if

  end do

  ptot = 0.0E+00
  do i = 1, ncat - 1
    ptot = ptot + p(i)
  end do

  if ( 0.99999E+00 < ptot ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENMUL - Fatal error!'
    write ( *, '(a)' ) '  1 < Sum of P().'
    stop 1
  end if
!
!  Initialize variables.
!
  ntot = n
  ptot = 1.0E+00
  do i = 1, ncat
    ix(i) = 0
  end do
!
!  Generate the observation.
!
  do icat = 1, ncat - 1
    prob = p(icat) / ptot
    ix(icat) = ignbin ( ntot, prob )
    ntot = ntot - ix(icat)
    if ( ntot <= 0 ) then
      return
    end if
    ptot = ptot - p(icat)
  end do

  ix(ncat) = ntot

  return
end
function gennch ( df, xnonc )

!*****************************************************************************80
!
!! GENNCH generates a noncentral Chi-Square random deviate.
!
!  Discussion:
!
!    This procedure generates a random deviate from the  distribution of a
!    noncentral chisquare with DF degrees of freedom and noncentrality parameter
!    XNONC.
!
!    It uses the fact that the noncentral chisquare is the sum of a chisquare
!    deviate with DF-1 degrees of freedom plus the square of a normal
!    deviate with mean XNONC and standard deviation 1.
!
!    A subtle ambiguity arises in the original formulation:
!
!      gennch = genchi ( arg1 ) + ( gennor ( arg2, arg3 ) ) ^ 2
!
!    because the compiler is free to invoke either genchi or gennor
!    first, both of which alter the random number generator state,
!    resulting in two distinct possible results.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) DF, the degrees of freedom.
!    1.0 < DF.
!
!    Input, real ( kind = 4 ) XNONC, the noncentrality parameter.
!    0.0 <= XNONC.
!
!    Output, real ( kind = 4 ) GENNCH, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) arg1
  real ( kind = 4 ) arg2
  real ( kind = 4 ) arg3
  real ( kind = 4 ) df
  !real ( kind = 4 ) genchi
  real ( kind = 4 ) gennch
  !real ( kind = 4 ) gennor
  real ( kind = 4 ) t1
  real ( kind = 4 ) t2
  real ( kind = 4 ) xnonc

  if ( df <= 1.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENNCH - Fatal error!'
    write ( *, '(a)' ) '  DF <= 1.'
    stop 1
  end if

  if ( xnonc < 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENNCH - Fatal error!'
    write ( *, '(a)' ) '  XNONC < 0.0.'
    stop 1
  end if

  arg1 = df - 1.0E+00
  arg2 = sqrt ( xnonc )
  arg3 = 1.0E+00

  t1 = genchi ( arg1 )
  t2 = gennor ( arg2, arg3 )

  gennch = t1 + t2 * t2

  return
end
function gennf ( dfn, dfd, xnonc )

!*****************************************************************************80
!
!! GENNF generates a noncentral F random deviate.
!
!  Discussion:
!
!    This procedure generates a random deviate from the noncentral F
!    (variance ratio) distribution with DFN degrees of freedom in the
!    numerator, and DFD degrees of freedom in the denominator, and
!    noncentrality parameter XNONC.
!
!    It directly generates the ratio of noncentral numerator chisquare variate
!    to central denominator chisquare variate.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) DFN, the numerator degrees of freedom.
!    1.0 < DFN.
!
!    Input, real ( kind = 4 ) DFD, the denominator degrees of freedom.
!    0.0 < DFD.
!
!    Input, real ( kind = 4 ) XNONC, the noncentrality parameter.
!    0.0 <= XNONC.
!
!    Output, real ( kind = 4 ) GENNF, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) dfd
  real ( kind = 4 ) dfn
  !real ( kind = 4 ) genchi
  !real ( kind = 4 ) gennch
  real ( kind = 4 ) gennf
  real ( kind = 4 ) xden
  real ( kind = 4 ) xnonc
  real ( kind = 4 ) xnum

  if ( dfn <= 1.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENNF - Fatal error!'
    write ( *, '(a)' ) '  DFN <= 1.0'
    stop 1
  end if

  if ( dfd <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENNF - Fatal error!'
    write ( *, '(a)' ) '  DFD <= 0.0'
    stop 1
  end if

  if ( xnonc < 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'GENNF - Fatal error!'
    write ( *, '(a)' ) '  XNONC < 0.0'
    stop 1
  end if

  xnum = gennch ( dfn, xnonc ) / dfn
  xden = genchi ( dfd ) / dfd

  gennf = xnum / xden

  return
end
function gennor ( av, sd )

!*****************************************************************************80
!
!! GENNOR generates a normal random deviate.
!
!  Discussion:
!
!    This procedure generates a single random deviate from a normal distribution
!    with mean AV, and standard deviation SD.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Extensions of Forsythe's Method for Random
!    Sampling from the Normal Distribution,
!    Mathematics of Computation,
!    Volume 27, Number 124, October 1973, page 927-937.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) AV, the mean.
!
!    Input, real ( kind = 4 ) SD, the standard deviation.
!
!    Output, real ( kind = 4 ) GENNOR, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) av
  real ( kind = 4 ) gennor
  real ( kind = 4 ) sd
  !real ( kind = 4 ) snorm

  gennor = sd * snorm ( ) + av

  return
end
subroutine genprm ( iarray, n )

!*****************************************************************************80
!
!! GENPRM generates and applies a random permutation to an array.
!
!  Discussion:
!
!    To see the permutation explicitly, let the input array be
!    1, 2, ..., N.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input/output, integer ( kind = 4 ) IARRAY(N), an array to be permuted.
!
!    Input, integer ( kind = 4 ) N, the number of entries in the array.
!
  implicit none

  integer ( kind = 4 ) n

  integer ( kind = 4 ) i
  integer ( kind = 4 ) iarray(n)
  !integer ( kind = 4 ) ignuin
  integer ( kind = 4 ) itmp
  integer ( kind = 4 ) iwhich

  do i = 1, n
    iwhich = ignuin ( i, n )
    itmp = iarray(iwhich)
    iarray(iwhich) = iarray(i)
    iarray(i) = itmp
  end do

  return
end
function genunf ( low, high )

!*****************************************************************************80
!
!! GENUNF generates a uniform random deviate.
!
!  Discussion:
!
!    This procedure generates a real deviate uniformly distributed between
!    LOW and HIGH.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) LOW, HIGH, the lower and upper bounds.
!
!    Output, real ( kind = 4 ) GENUNF, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) genunf
  real ( kind = 4 ) high
  real ( kind = 4 ) low
  !real ( kind = 4 ) r4_uni_01

  genunf = low + ( high - low ) * r4_uni_01 ( )

  return
end
function ignbin ( n, pp )

!*****************************************************************************80
!
!! IGNBIN generates a binomial random deviate.
!
!  Discussion:
!
!    This procedure generates a single random deviate from a binomial
!    distribution whose number of trials is N and whose
!    probability of an event in each trial is P.
!
!    The previous version of this program relied on the assumption that
!    local memory would be preserved between calls.  It set up data
!    one time to be preserved for use over multiple calls.  In the
!    interests of portability, this assumption has been removed, and
!    the "setup" data is recomputed on every call.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Voratas Kachitvichyanukul, Bruce Schmeiser,
!    Binomial Random Variate Generation,
!    Communications of the ACM,
!    Volume 31, Number 2, February 1988, pages 216-222.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the number of binomial trials, from which a
!    random deviate will be generated.
!    0 < N.
!
!    Input, real ( kind = 4 ) PP, the probability of an event in each trial of
!    the binomial distribution from which a random deviate is to be generated.
!    0.0 < PP < 1.0.
!
!    Output, integer ( kind = 4 ) IGNBIN, a random deviate from the
!    distribution.
!
  implicit none

  real ( kind = 4 ) al
  real ( kind = 4 ) alv
  real ( kind = 4 ) amaxp
  real ( kind = 4 ) c
  real ( kind = 4 ) f
  real ( kind = 4 ) f1
  real ( kind = 4 ) f2
  real ( kind = 4 ) ffm
  real ( kind = 4 ) fm
  real ( kind = 4 ) g
  integer ( kind = 4 ) i
  integer ( kind = 4 ) ignbin
  integer ( kind = 4 ) ix
  integer ( kind = 4 ) ix1
  integer ( kind = 4 ) k
  integer ( kind = 4 ) m
  integer ( kind = 4 ) mp
  real ( kind = 4 ) pp
  integer ( kind = 4 ) n
  real ( kind = 4 ) p
  real ( kind = 4 ) p1
  real ( kind = 4 ) p2
  real ( kind = 4 ) p3
  real ( kind = 4 ) p4
  real ( kind = 4 ) q
  real ( kind = 4 ) qn
  real ( kind = 4 ) r
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) t
  real ( kind = 4 ) u
  real ( kind = 4 ) v
  real ( kind = 4 ) w
  real ( kind = 4 ) w2
  real ( kind = 4 ) x
  real ( kind = 4 ) x1
  real ( kind = 4 ) x2
  real ( kind = 4 ) xl
  real ( kind = 4 ) xll
  real ( kind = 4 ) xlr
  real ( kind = 4 ) xm
  real ( kind = 4 ) xnp
  real ( kind = 4 ) xnpq
  real ( kind = 4 ) xr
  real ( kind = 4 ) ynorm
  real ( kind = 4 ) z
  real ( kind = 4 ) z2

  if ( pp <= 0.0E+00 .or. 1.0E+00 <= pp ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNBIN - Fatal error!'
    write ( *, '(a)' ) '  PP is out of range.'
    stop 1
  end if

  p = min ( pp, 1.0E+00 - pp )
  q = 1.0E+00 - p
  xnp = real ( n, kind = 4 ) * p

  if ( xnp < 30.0E+00 ) then

    qn = q ** n
    r = p / q
    g = r * real ( n + 1, kind = 4 )

    do

      ix = 0
      f = qn
      u = r4_uni_01 ( )

      do

        if ( u < f ) then
          if ( 0.5E+00 < pp ) then
            ix = n - ix
          end if
          ignbin = ix
          return
        end if

        if ( 110 < ix ) then
          exit
        end if

        u = u - f
        ix = ix + 1
        f = f * ( g / real ( ix, kind = 4 ) - r )

      end do

    end do

  end if

  ffm = xnp + p
  m = int ( ffm )
  fm = m
  xnpq = xnp * q
  p1 = int ( 2.195E+00 * sqrt ( xnpq ) - 4.6E+00 * q ) + 0.5E+00
  xm = fm + 0.5E+00
  xl = xm - p1
  xr = xm + p1
  c = 0.134E+00 + 20.5E+00 / ( 15.3E+00 + fm )
  al = ( ffm - xl ) / ( ffm - xl * p )
  xll = al * ( 1.0E+00 + 0.5E+00 * al )
  al = ( xr - ffm ) / ( xr * q )
  xlr = al * ( 1.0E+00 + 0.5E+00 * al )
  p2 = p1 * ( 1.0E+00 + c + c )
  p3 = p2 + c / xll
  p4 = p3 + c / xlr
!
!  Generate a variate.
!
  do

    u = r4_uni_01 ( ) * p4
    v = r4_uni_01 ( )
!
!  Triangle
!
    if ( u < p1 ) then
      ix = int ( xm - p1 * v + u )
      if ( 0.5E+00 < pp ) then
        ix = n - ix
      end if
      ignbin = ix
      return
    end if
!
!  Parallelogram
!
    if ( u <= p2 ) then

      x = xl + ( u - p1 ) / c
      v = v * c + 1.0E+00 - abs ( xm - x ) / p1

      if ( v <= 0.0E+00 .or. 1.0E+00 < v ) then
        cycle
      end if

      ix = int ( x )

    else if ( u <= p3 ) then

      ix = int ( xl + log ( v ) / xll )
      if ( ix < 0 ) then
        cycle
      end if
      v = v * ( u - p2 ) * xll

    else

      ix = int ( xr - log ( v ) / xlr )
      if ( n < ix ) then
        cycle
      end if
      v = v * ( u - p3 ) * xlr

    end if

    k = abs ( ix - m )

    if ( k <= 20 .or. xnpq / 2.0 - 1.0 <= k ) then

      f = 1.0E+00
      r = p / q
      g = ( n + 1 ) * r

      if ( m < ix ) then
        mp = m + 1
        do i = m + 1, ix
          f = f * ( g / i - r )
        end do
      else if ( ix < m ) then
        ix1 = ix + 1
        do i = ix + 1, m
          f = f / ( g / real ( i, kind = 4 ) - r )
        end do
      end if

      if ( v <= f ) then
        if ( 0.5E+00 < pp ) then
          ix = n - ix
        end if
        ignbin = ix
        return
      end if

    else

      amaxp = ( k / xnpq ) * ( ( k * ( k / 3.0E+00 &
        + 0.625E+00 ) + 0.1666666666666E+00 ) / xnpq + 0.5E+00 )
      ynorm = - real ( k * k, kind = 4 ) / ( 2.0E+00 * xnpq )
      alv = log ( v )

      if ( alv < ynorm - amaxp ) then
        if ( 0.5E+00 < pp ) then
          ix = n - ix
        end if
        ignbin = ix
        return
      end if

      if ( ynorm + amaxp < alv ) then
        cycle
      end if

      x1 = real ( ix + 1, kind = 4 )
      f1 = fm + 1.0E+00
      z = real ( n + 1, kind = 4 ) - fm
      w = real ( n - ix + 1, kind = 4 )
      z2 = z * z
      x2 = x1 * x1
      f2 = f1 * f1
      w2 = w * w

      t = xm * log ( f1 / x1 ) + ( n - m + 0.5E+00 ) * log ( z / w ) &
        + real ( ix - m, kind = 4 ) * log ( w * p / ( x1 * q ) ) &
        + ( 13860.0E+00 - ( 462.0E+00 - ( 132.0E+00 - ( 99.0E+00 - 140.0E+00 &
        / f2 ) / f2 ) / f2 ) / f2 ) / f1 / 166320.0E+00 &
        + ( 13860.0E+00 - ( 462.0E+00 - ( 132.0E+00 - ( 99.0E+00 - 140.0E+00 &
        / z2 ) / z2 ) / z2 ) / z2 ) / z / 166320.0E+00 &
        + ( 13860.0E+00 - ( 462.0E+00 - ( 132.0E+00 - ( 99.0E+00 - 140.0E+00 &
        / x2 ) / x2 ) / x2 ) / x2 ) / x1 / 166320.0E+00 &
        + ( 13860.0E+00 - ( 462.0E+00 - ( 132.0E+00 - ( 99.0E+00 - 140.0E+00 &
        / w2 ) / w2 ) / w2 ) / w2 ) / w / 166320.0E+00

      if ( alv <= t ) then
        if ( 0.5E+00 < pp ) then
          ix = n - ix
        end if
        ignbin = ix
        return
      end if

    end if

  end do

  return
end
function ignnbn ( n, p )

!*****************************************************************************80
!
!! IGNNBN generates a negative binomial random deviate.
!
!  Discussion:
!
!    This procedure generates a single random deviate from a negative binomial
!    distribution.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Luc Devroye,
!    Non-Uniform Random Variate Generation,
!    Springer, 1986,
!    ISBN: 0387963057,
!    LC: QA274.D48.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the required number of events.
!    0 <= N.
!
!    Input, real ( kind = 4 ) P, the probability of an event during a 
!    Bernoulli trial.  0.0 < P < 1.0.
!
!    Output, integer ( kind = 4 ) IGNNBN, a random deviate from 
!    the distribution.
!
  implicit none

  real ( kind = 4 ) a
  !real ( kind = 4 ) gengam
  integer ( kind = 4 ) ignnbn
 ! integer ( kind = 4 ) ignpoi
  integer ( kind = 4 ) n
  real ( kind = 4 ) p
  real ( kind = 4 ) r
  real ( kind = 4 ) y

  if ( n < 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNNBN - Fatal error!'
    write ( *, '(a)' ) '  N < 0.'
    stop 1
  end if

  if ( p <= 0.0E+00 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNNBN - Fatal error!'
    write ( *, '(a)' ) '  P <= 0.0'
    stop 1
  end if

  if ( 1.0E+00 <= p ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNNBN - Fatal error!'
    write ( *, '(a)' ) '  1.0 <= P'
    stop 1
  end if
!
!  Generate Y, a random gamma (n,(1-p)/p) variable.
!
  r = real ( n )
  a = p / ( 1.0E+00 - p )
  y = gengam ( a, r )
!
!  Generate a random Poisson ( y ) variable.
!
  ignnbn = ignpoi ( y )

  return
end
function ignpoi ( mu )

!*****************************************************************************80
!
!! IGNPOI generates a Poisson random deviate.
!
!  Discussion:
!
!    This procedure generates a single random deviate from a Poisson
!    distribution with given mean.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    02 September 2018
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Computer Generation of Poisson Deviates
!    From Modified Normal Distributions,
!    ACM Transactions on Mathematical Software,
!    Volume 8, Number 2, June 1982, pages 163-179.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) MU, the mean of the Poisson distribution 
!    from which a random deviate is to be generated.
!
!    Output, integer ( kind = 4 ) IGNPOI, a random deviate from
!    the distribution.
!
  implicit none

  real ( kind = 4 ), parameter :: a0 = -0.5E+00
  real ( kind = 4 ), parameter :: a1 =  0.3333333E+00
  real ( kind = 4 ), parameter :: a2 = -0.2500068E+00
  real ( kind = 4 ), parameter :: a3 =  0.2000118E+00
  real ( kind = 4 ), parameter :: a4 = -0.1661269E+00
  real ( kind = 4 ), parameter :: a5 =  0.1421878E+00
  real ( kind = 4 ), parameter :: a6 = -0.1384794E+00
  real ( kind = 4 ), parameter :: a7 =  0.1250060E+00
  real ( kind = 4 ) b1
  real ( kind = 4 ) b2
  real ( kind = 4 ) c
  real ( kind = 4 ) c0
  real ( kind = 4 ) c1
  real ( kind = 4 ) c2
  real ( kind = 4 ) c3
  real ( kind = 4 ) d
  real ( kind = 4 ) del
  real ( kind = 4 ) difmuk
  real ( kind = 4 ) e
  real ( kind = 4 ) fact(10)
  real ( kind = 4 ) fk
  real ( kind = 4 ) fx
  real ( kind = 4 ) fy
  real ( kind = 4 ) g
  integer ( kind = 4 ) ignpoi
  integer ( kind = 4 ) k
  integer ( kind = 4 ) kflag
  integer ( kind = 4 ) l
  integer ( kind = 4 ) m
  real ( kind = 4 ) mu
  real ( kind = 4 ) omega
  real ( kind = 4 ) p
  real ( kind = 4 ) p0
  real ( kind = 4 ) px
  real ( kind = 4 ) py
  real ( kind = 4 ) q
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) s
  !real ( kind = 4 ) sexpo
  !real ( kind = 4 ) snorm
  real ( kind = 4 ) t
  real ( kind = 4 ) u
  real ( kind = 4 ) v
  real ( kind = 4 ) x
  real ( kind = 4 ) xx

  save fact

  data fact / 1.0E+00, 1.0E+00, 2.0E+00, 6.0E+00, 24.0E+00, &
    120.0E+00, 720.0E+00, 5040.0E+00, 40320.0E+00, 362880.0E+00 /
!
!  MU < 10
!
  if ( mu < 10.0E+00 ) then

    m = max ( 1, int ( mu ) )
    l = 0
    p = exp ( - mu )
    q = p
    p0 = p
!
!  Uniform sample for inversion method.
!
    do

      u = r4_uni_01 ( )
      ignpoi = 0

      if ( u <= p0 ) then
        return
      end if
!
!  Creation of new Poisson probabilities.
!
      do k = 1, 35
        p = p * mu / real ( k )
        q = q + p
        if ( u <= q ) then
          ignpoi = k
          return
        end if
      end do

    end do
!
!  10 <= MU
!
  else

    s = sqrt ( mu )
    d = 6.0E+00 * mu * mu
    l = int ( mu - 1.1484E+00 )
!
!  Normal sample.
!
    g = mu + s * snorm ( )

    if ( 0.0E+00 <= g ) then

      ignpoi = int ( g )
!
!  Immediate acceptance if large enough.
!
      if ( l <= ignpoi ) then
        return
      end if
!
!  Squeeze acceptance.
!
      fk = real ( ignpoi )
      difmuk = mu - fk
      u = r4_uni_01 ( )

      if ( difmuk * difmuk * difmuk <= d * u ) then
        return
      end if

    end if
!
!  Preparation for steps P and Q.
!
    omega = 0.3989423E+00 / s
    b1 = 0.04166667E+00 / mu
    b2 = 0.3E+00 * b1 * b1
    c3 = 0.1428571E+00 * b1 * b2
    c2 = b2 - 15.0E+00 * c3
    c1 = b1 - 6.0E+00 * b2 + 45.0E+00 * c3
    c0 = 1.0E+00 - b1 + 3.0E+00 * b2 - 15.0E+00 * c3
    c = 0.1069E+00 / mu

    if ( 0.0E+00 <= g ) then

      kflag = 0

      if ( ignpoi < 10 ) then

        px = - mu
        py = mu ** ignpoi / fact(ignpoi+1)

      else

        del = 0.8333333E-01 / fk
        del = del - 4.8E+00 * del * del * del
        v = difmuk / fk

        if ( 0.25E+00 < abs ( v ) ) then
          px = fk * log ( 1.0E+00 + v ) - difmuk - del
        else
          px = fk * v * v * ((((((( a7 &
            * v + a6 ) &
            * v + a5 ) &
            * v + a4 ) &
            * v + a3 ) &
            * v + a2 ) &
            * v + a1 ) &
            * v + a0 ) - del
        end if

        py = 0.3989423E+00 / sqrt ( fk )

      end if

      x = ( 0.5E+00 - difmuk ) / s
      xx = x * x
      fx = -0.5E+00 * xx
      fy = omega * ((( c3 * xx + c2 ) * xx + c1 ) * xx + c0 )

      if ( fy - u * fy <= py * exp ( px - fx ) ) then
        return
      end if

    end if
!
!  Exponential sample.
!
    do

      e = sexpo ( )
      u = 2.0E+00 * r4_uni_01 ( ) - 1.0E+00
      if ( u < 0.0E+00 ) then
        t = 1.8E+00 - abs ( e )
      else
        t = 1.8E+00 + abs ( e )
      end if

      if ( t <= -0.6744E+00 ) then
        cycle
      end if

      ignpoi = int ( mu + s * t )
      fk = real ( ignpoi )
      difmuk = mu - fk

      kflag = 1
!
!  Calculation of PX, PY, FX, FY.
!
      if ( ignpoi < 10 ) then

        px = -mu
        py = mu ** ignpoi / fact(ignpoi+1)
  
      else

        del = 0.8333333E-01 / fk
        del = del - 4.8E+00 * del * del * del
        v = difmuk / fk

        if ( 0.25E+00 < abs ( v ) ) then
          px = fk * log ( 1.0E+00 + v ) - difmuk - del
        else
          px = fk * v * v * ((((((( a7 &
            * v + a6 ) &
            * v + a5 ) &
            * v + a4 ) &
            * v + a3 ) &
            * v + a2 ) &
            * v + a1 ) &
            * v + a0 ) - del
        end if

        py = 0.3989423E+00 / sqrt ( fk )

      end if

      x = ( 0.5E+00 - difmuk ) / s
      xx = x * x
      fx = -0.5E+00 * xx
      fy = omega * ((( c3 * xx + c2 ) * xx + c1 ) * xx + c0 )

      if ( kflag <= 0 ) then

        if ( fy - u * fy <= py * exp ( px - fx ) ) then
          return
        end if

      else

        if ( c * abs ( u ) <= py * exp ( px + e ) - fy * exp ( fx + e ) ) then
          return
        end if

      end if

    end do

  end if

end
function ignuin ( low, high )

!*****************************************************************************80
!
!! IGNUIN generates a random integer in a given range.
!
!  Discussion:
!
!    Each deviate K satisfies LOW <= K <= HIGH.
!
!    If (HIGH-LOW) > 2,147,483,561, this procedure prints an error message
!    and stops the program.
!
!    IGNLGI generates integer ( kind = 4 )s between 1 and 2147483562.
!
!    MAXNUM is 1 less than the maximum generatable value.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) LOW, HIGH, the lower and upper bounds.
!
!    Output, integer ( kind = 4 ) IGNUIN, a random deviate from 
!    the distribution.
!
  implicit none

  integer ( kind = 4 ) high
  !integer ( kind = 4 ) i4_uni
  integer ( kind = 4 ) ign
  integer ( kind = 4 ) ignuin
  integer ( kind = 4 ) low
  integer ( kind = 4 ) maxnow
  integer ( kind = 4 ) maxnum
  parameter ( maxnum = 2147483561 )
  integer ( kind = 4 ) ranp1
  integer ( kind = 4 ) width

  if ( high < low ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNUIN - Fatal error!'
    write ( *, '(a)' ) '  HIGH < LOW.'
    stop 1
  end if

  width = high - low

  if ( maxnum < width ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'IGNUIN - Fatal error!'
    write ( *, '(a)' ) '  Range HIGH-LOW is too large.'
    stop 1
  end if

  if ( low == high ) then
    ignuin = low
    return
  end if

  ranp1 = width + 1
  maxnow = ( maxnum / ranp1 ) * ranp1

  do

    ign = i4_uni ( ) - 1

    if ( ign <= maxnow ) then
      exit
    end if

  end do

  ignuin = low + mod ( ign, ranp1 )

  return
end
function lennob ( s )

!*****************************************************************************80
!
!! LENNOB counts the length of a string, ignoring trailing blanks.
!
!  Discussion:
!
!    This procedure returns the length of a string up to and including
!    the last non-blank character.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, character * ( * ) S, the string.
!
!    Output, integer ( kind = 4 ) LENNOB, the length of the string to the last
!    nonblank.
!
  implicit none

  integer ( kind = 4 ) i
  integer ( kind = 4 ) lennob
  character * ( * ) s
  integer ( kind = 4 ) s_max

  s_max = len ( s )

  do i = s_max, 1, -1
    if ( s(i:i) /= ' ' ) then
      lennob = i
      return
    end if
  end do

  lennob = 0

  return
end
subroutine phrtsd ( phrase, seed1, seed2 )

!*****************************************************************************80
!
!! PHRTST converts a phrase to a pair of random number generator seeds.
!
!  Discussion:
!
!    This procedure uses a character string to generate two seeds for the RGN
!    random number generator.
!
!    Trailing blanks are eliminated before the seeds are generated.
!
!    Generated seed values will fall in the range 1 to 2^30 = 1,073,741,824.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, character * ( * ) PHRASE, a phrase to be used for the
!    random number generation.
!
!    Output, integer ( kind = 4 ) SEED1, SEED2, the two seeds for the
!    random number generator, based on PHRASE.
!
  implicit none

  integer ( kind = 4 ) i
  integer ( kind = 4 ) ichr
  integer ( kind = 4 ) j
  !integer ( kind = 4 ) lennob
  integer ( kind = 4 ) lphr
  character * ( * ) phrase
  integer ( kind = 4 ) seed1
  integer ( kind = 4 ) seed2
  integer ( kind = 4 ) shift(0:4)
  character * ( 86 ) table
  parameter ( table = &
    'abcdefghijklmnopqrstuvwxyz'// &
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'// &
    '0123456789'// &
    '!@#$%^&*()_+[];:''"<>?,./' )
  integer ( kind = 4 ) twop30
  parameter ( twop30 = 1073741824 )
  integer ( kind = 4 ) values(5)

  save shift

  data shift / 1, 64, 4096, 262144, 16777216 /

  seed1 = 1234567890
  seed2 = 123456789

  lphr = lennob ( phrase )

  do i = 1, lphr

    ichr = index ( table, phrase(i:i) )
!
!  If the character does not occur, ICHR is returned as 0.
!
    ichr = mod ( ichr, 64 )

    if ( ichr == 0 ) then
      ichr = 63
    end if

    do j = 1, 5
      values(j) = ichr - j
      if ( values(j) < 1 ) then
        values(j) = values(j) + 63
      end if
    end do

    do j = 1, 5
      seed1 = mod ( seed1 + shift(j-1) * values(j), twop30 )
      seed2 = mod ( seed2 + shift(j-1) * values(6-j), twop30 )
    end do

  end do

  return
end
subroutine prcomp ( maxobs, p, mean, xcovar, answer )

!*****************************************************************************80
!
!! PRCOMP prints covariance information.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    03 September 2018
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) MAXOBS, the number of observations.
!
!    Input, integer ( kind = 4 ) P, the number of variables.
!
!    Input, real ( kind = 4 ) MEAN(P), the mean for each column.
!
!    Input, real ( kind = 4 ) XCOVAR(P,P), the variance/covariance matrix.
!
!    Input, real ( kind = 4 ) ANSWER(MAXOBS,P), the observed values.
!
  implicit none

  integer ( kind = 4 ) p
  integer ( kind = 4 ) maxobs

  real ( kind = 4 ) answer(maxobs,p)
  real ( kind = 4 ) dum1
  real ( kind = 4 ) dum2
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  real ( kind = 4 ) mean(p)
  !real ( kind = 4 ) r4vec_covar
  real ( kind = 4 ) rcovar(p,p)
  real ( kind = 4 ) rmean(p)
  real ( kind = 4 ) rvar(p)
  real ( kind = 4 ) xcovar(p,p)

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) 'PRCOMP:'
  write ( *, '(a)' ) '  Print and compare covariance information'
  write ( *, '(a)' ) ' '

  do j = 1, p
    call stats ( answer(1,j), maxobs, rmean(j), rvar(j), &
      dum1, dum2 )
    write ( *, '(a,i4)' ) '  Variable Number ', j
    write ( *, '(a,g14.6,a,g14.6)' ) &
      '  Mean ', mean(j), ' Generated ', rmean(j)
    write ( *, '(a,g14.6,a,g14.6)' ) &
      '  Variance ', xcovar(j,j), ' Generated ', rvar(j)
  end do

  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '  Covariances:'
  write ( *, '(a)' ) ' '

  do i = 1, p
    do j = 1, i - 1
      write ( *, '(a,i4,a,i4)' ) '  I = ', i, ' J = ', j
      rcovar(i,j) = r4vec_covar ( maxobs, answer(1,i), answer(1,j) )
      write ( *, '(a,g14.6,a,g14.6)' ) &
        '  Covariance ', xcovar(i,j), ' Generated ', rcovar(i,j)
    end do
  end do

  return
end
function r4_exp ( x )

!*****************************************************************************80
!
!! R4_EXP computes the exponential of an R8, avoiding overflow and underflow.
!
!  Discussion:
!
!    For arguments of very large magnitude, the evaluation of the
!    exponential function can cause computational problems.  Some languages
!    and compilers may return an infinite value or a "Not-a-Number".  
!    An alternative, when dealing with a wide range of inputs, is simply
!    to truncate the calculation for arguments whose magnitude is too large.
!    Whether this is the right or convenient approach depends on the problem
!    you are dealing with, and whether or not you really need accurate
!    results for large magnitude inputs, or you just want your code to
!    stop crashing.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    19 September 2014
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 4 ) X, the argument of the exponential function.
!
!    Output, real ( kind = 4 ) R4_EXP, the value of exp ( X ).
!
  implicit none

  real ( kind = 4 ) r4_exp
  real ( kind = 4 ), parameter :: r4_huge = 1.0E+30
  real ( kind = 4 ), parameter :: r4_log_max = +69.0776E+00
  real ( kind = 4 ), parameter :: r4_log_min = -69.0776E+00
  real ( kind = 4 ) value
  real ( kind = 4 ) x

  if ( x <= r4_log_min ) then
    value = 0.0E+00
  else if ( x < r4_log_max ) then
    value = exp ( x )
  else
    value = r4_huge
  end if

  r4_exp = value

  return
end
function r4_exponential_sample ( lambda )

!*****************************************************************************80
!
!! R4_EXPONENTIAL_SAMPLE samples the exponential PDF.
!
!  Discussion:
!
!    Note that the parameter LAMBDA is a multiplier.  In some formulations,
!    it is used as a divisor instead.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    18 April 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 4 ) LAMBDA, the parameter of the PDF.
!
!    Output, real ( kind = 4 ) R4_EXPONENTIAL_SAMPLE, a sample of the PDF.
!
  implicit none

  real ( kind = 4 ) lambda
  real ( kind = 4 ) r
  real ( kind = 4 ) r4_exponential_sample
  !real ( kind = 4 ) r4_uni_01

  r = r4_uni_01 ( )

  r4_exponential_sample = - log ( r ) * lambda

  return
end
function r4vec_covar ( n, x, y )

!*****************************************************************************80
!
!! R4VEC_COVAR computes the covariance of two vectors.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 April 2013
!
!  Author:
!
!    John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) X(N), Y(N), the two vectors.
!
!    Input, integer ( kind = 4 ) N, the dimension of the two vectors.
!
!    Output, real ( kind = 4 ) R4VEC_COVAR, the covariance of the vectors.
!
  implicit none

  integer ( kind = 4 ) n

  integer ( kind = 4 ) i
  real ( kind = 4 ) r4vec_covar
  real ( kind = 4 ) value
  real ( kind = 4 ) x(n)
  real ( kind = 4 ) x_average
  real ( kind = 4 ) y(n)
  real ( kind = 4 ) y_average

  x_average = sum ( x(1:n) ) / real ( n, kind = 4 )
  y_average = sum ( y(1:n) ) / real ( n, kind = 4 )
 
  value = 0.0E+00
  do i = 1, n
    value = value + ( x(i) - x_average ) * ( y(i) - y_average )
  end do

  r4vec_covar = value / real ( n - 1, kind = 4 )

  return
end
function r8_exponential_sample ( lambda )

!*****************************************************************************80
!
!! R8_EXPONENTIAL_SAMPLE samples the exponential PDF.
!
!  Discussion:
!
!    Note that the parameter LAMBDA is a multiplier.  In some formulations,
!    it is used as a divisor instead.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 April 2013
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, real ( kind = 8 ) LAMBDA, the parameter of the PDF.
!
!    Output, real ( kind = 8 ) R8_EXPONENTIAL_SAMPLE, a sample of the PDF.
!
  implicit none

  real ( kind = 8 ) lambda
  real ( kind = 8 ) r
  real ( kind = 8 ) r8_exponential_sample
  !real ( kind = 8 ) r8_uni_01

  r = r8_uni_01 ( )

  r8_exponential_sample = - log ( r ) * lambda

  return
end
function r8vec_covar ( n, x, y )

!*****************************************************************************80
!
!! R8VEC_COVAR computes the covariance of two vectors.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 April 2013
!
!  Author:
!
!    John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) X(N), Y(N), the two vectors.
!
!    Input, integer ( kind = 4 ) N, the dimension of the two vectors.
!
!    Output, real ( kind = 8 ) R4VEC_COVAR, the covariance of the vectors.
!
  implicit none

  integer ( kind = 4 ) n

  integer ( kind = 4 ) i
  real ( kind = 8 ) r8vec_covar
  real ( kind = 8 ) value
  real ( kind = 8 ) x(n)
  real ( kind = 8 ) x_average
  real ( kind = 8 ) y(n)
  real ( kind = 8 ) y_average

  x_average = sum ( x(1:n) ) / real ( n, kind = 8 )
  y_average = sum ( y(1:n) ) / real ( n, kind = 8 )
 
  value = 0.0D+00
  do i = 1, n
    value = value + ( x(i) - x_average ) * ( y(i) - y_average )
  end do

  r8vec_covar = value / real ( n - 1, kind = 8 )

  return
end
function sdot ( n, sx, incx, sy, incy )

!*****************************************************************************80
!
!! SDOT forms the dot product of two vectors.
!
!  Discussion:
!
!    This routine uses single precision real ( kind = 4 ) arithmetic.
!
!    This routine uses unrolled loops for increments equal to one.
!
!  Modified:
!
!    07 July 2007
!
!  Author:
!
!    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh
!
!  Reference:
!
!    Jack Dongarra, Jim Bunch, Cleve Moler, Pete Stewart,
!    LINPACK User's Guide,
!    SIAM, 1979,
!    ISBN13: 978-0-898711-72-1,
!    LC: QA214.L56.
!
!    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
!    Basic Linear Algebra Subprograms for FORTRAN usage,
!    ACM Transactions on Mathematical Software,
!    Volume 5, Number 3, pages 308-323, 1979.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) N, the number of entries in the vectors.
!
!    Input, real ( kind = 4 ) X(*), one of the vectors to be multiplied.
!
!    Input, integer ( kind = 4 ) INCX, the increment between successive 
!    entries of X.
!
!    Input, real ( kind = 4 ) Y(*), one of the vectors to be multiplied.
!
!    Input, integer ( kind = 4 ) INCY, the increment between successive
!    elements of Y.
!
!    Output, real ( kind = 4 ) SDOT, the dot product of X and Y.
!
  implicit none

  integer ( kind = 4 ) i
  integer ( kind = 4 ) incx
  integer ( kind = 4 ) incy
  integer ( kind = 4 ) ix
  integer ( kind = 4 ) iy
  integer ( kind = 4 ) m
  integer ( kind = 4 ) n
  real ( kind = 4 ) sdot
  real ( kind = 4 ) stemp
  real ( kind = 4 ) sx(*)
  real ( kind = 4 ) sy(*)

  sdot = 0.0E+00

  if ( n <= 0 ) then
    return
  end if

  stemp = 0.0E+00
!
!  Code for unequal increments or equal increments not equal to 1.
!
  if ( incx /= 1 .or. incy /= 1 ) then

    if ( incx < 0 ) then
      ix = ( - n + 1 ) * incx + 1
    else
      ix = 1
    end if

    if ( incy < 0 ) then
      iy = ( - n + 1 ) * incy + 1
    else
      iy = 1
    end if

    do i = 1, n
      stemp = stemp + sx(ix) * sy(iy)
      ix = ix + incx
      iy = iy + incy
    end do
!
!  Code for both increments equal to 1.
!
  else

    m = mod ( n, 5 )

    do i = 1, m
      stemp = stemp + sx(i) * sy(i)
    end do

    do i = m + 1, n, 5
      stemp = stemp &
       + sx(i)     * sy(i) &
       + sx(i + 1) * sy(i + 1) &
       + sx(i + 2) * sy(i + 2) &
       + sx(i + 3) * sy(i + 3) &
       + sx(i + 4) * sy(i + 4)
    end do

  end if

  sdot = stemp

  return
end
subroutine setcov ( p, var, corr, covar )

!*****************************************************************************80
!
!! SETCOV sets a covariance matrix from variance and common correlation.
!
!  Discussion:
!
!    This procedure sets the covariance matrix from the variance and
!    common correlation.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) P, the number of variables.
!
!    Input, real ( kind = 4 ) VAR(P), the variances.
!
!    Input, real ( kind = 4 ) CORR, the common correlaton.
!
!    Output, real ( kind = 4 ) COVAR(P,P), the covariance matrix.
!
  implicit none

  integer ( kind = 4 ) p

  real ( kind = 4 ) corr
  real ( kind = 4 ) covar(p,p)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  real ( kind = 4 ) var(p)

  do i = 1, p
    do  j = 1, p
      if ( i == j ) then
        covar(i,j) = var(i)
      else
        covar(i,j) = corr * sqrt ( var(i) * var(j) )
      end if
    end do
  end do

  return
end
subroutine setgmn ( meanv, covm, p, parm )

!*****************************************************************************80
!
!! SETGMN sets data for the generation of multivariate normal deviates.
!
!  Discussion:
!
!    This procedure places P, MEANV, and the Cholesky factorization of
!    COVM in GENMN.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) MEANV(P), the means of the multivariate 
!    normal distribution.
!
!    Input/output, real ( kind = 4 ) COVM(P,P).  On input, the covariance
!    matrix of the multivariate distribution.  On output, the information 
!    in COVM has been overwritten.
!
!    Input, integer ( kind = 4 ) P, the number of dimensions.
!
!    Output, real ( kind = 4 ) PARM(P*(P+3)/2+1), parameters needed to generate
!    multivariate normal deviates.
!
  implicit none

  integer ( kind = 4 ) p

  real ( kind = 4 ) covm(p,p)
  integer ( kind = 4 ) i
  integer ( kind = 4 ) icount
  integer ( kind = 4 ) info
  integer ( kind = 4 ) j
  real ( kind = 4 ) meanv(p)
  real ( kind = 4 ) parm(p*(p+3)/2+1)

  if ( p <= 0 ) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SETGMN - Fatal error!'
    write ( *, '(a)' ) '  P was not positive.'
    stop 1
  end if 
!
!  Store P.
!
  parm(1) = p
!
!  Store MEANV.
!
  do i = 2, p + 1
    parm(i) = meanv(i-1)
  end do
!
!  Compute the Cholesky decomposition.
!
  call spofa ( covm, p, p, info )

  if ( info /= 0) then
    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'SETGMN - Fatal error!'
    write ( *, '(a)' ) '  SPOFA finds COVM not positive definite.'
    stop 1
  end if
!
!  Store the upper half of the Cholesky factor.
!
  icount = p + 1

  do i = 1, p
    do j = i, p
      icount = icount + 1
      parm(icount) = covm(i,j)
    end do
  end do

  return
end
function sexpo ( )

!*****************************************************************************80
!
!! SEXPO samples the standard exponential distribution.
!
!  Discussion:
!
!   This procedure corresponds to algorithm SA in the reference.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Computer Methods for Sampling From the
!    Exponential and Normal Distributions,
!    Communications of the ACM,
!    Volume 15, Number 10, October 1972, pages 873-882.
!
!  Parameters:
!
!    Output, real ( kind = 4 ) SEXPO, a random deviate from the standard
!    exponential distribution.
!
  implicit none

  real ( kind = 4 ) a
  integer ( kind = 4 ) i
  real ( kind = 4 ) q(8)
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) sexpo
  real ( kind = 4 ) u
  real ( kind = 4 ) umin
  real ( kind = 4 ) ustar

  save q

  data q / &
       0.6931472E+00, &
       0.9333737E+00, &
       0.9888778E+00, &
       0.9984959E+00, &
       0.9998293E+00, &
       0.9999833E+00, &
       0.9999986E+00, &
       0.9999999E+00 /

  a = 0.0E+00
  u = r4_uni_01 ( )

  do

    u = u + u

    if ( 1.0E+00 < u ) then
      exit
    end if

    a = a + q(1)

  end do

  u = u - 1.0E+00

  if ( u <= q(1) ) then
    sexpo = a + u
    return
  end if

  i = 1
  ustar = r4_uni_01 ( )
  umin = ustar

  do

    ustar = r4_uni_01 ( )
    umin = min ( umin, ustar )
    i = i + 1

    if ( u <= q(i) ) then
      exit
    end if

  end do

  sexpo = a + umin * q(1)

  return
end
function sgamma ( a )

!*****************************************************************************80
!
!! SGAMMA samples the standard Gamma distribution.
!
!  Discussion:
!
!    This procedure corresponds to algorithm GD in the reference.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    01 April 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Generating Gamma Variates by a Modified Rejection Technique,
!    Communications of the ACM,
!    Volume 25, Number 1, January 1982, pages 47-54.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) A, the parameter of the standard gamma
!    distribution.  0.0 < A < 1.0.
!
!    Output, real ( kind = 4 ) SGAMMA, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) a
  real ( kind = 4 ), parameter :: a1 =  0.3333333E+00
  real ( kind = 4 ), parameter :: a2 = -0.2500030E+00
  real ( kind = 4 ), parameter :: a3 =  0.2000062E+00
  real ( kind = 4 ), parameter :: a4 = -0.1662921E+00
  real ( kind = 4 ), parameter :: a5 =  0.1423657E+00
  real ( kind = 4 ), parameter :: a6 = -0.1367177E+00
  real ( kind = 4 ), parameter :: a7 =  0.1233795E+00
  real ( kind = 4 ) b
  real ( kind = 4 ) c
  real ( kind = 4 ) d
  real ( kind = 4 ) e
  real ( kind = 4 ), parameter :: e1 = 1.0E+00
  real ( kind = 4 ), parameter :: e2 = 0.4999897E+00
  real ( kind = 4 ), parameter :: e3 = 0.1668290E+00
  real ( kind = 4 ), parameter :: e4 = 0.0407753E+00
  real ( kind = 4 ), parameter :: e5 = 0.0102930E+00
  real ( kind = 4 ) p
  real ( kind = 4 ) q
  real ( kind = 4 ) q0
  real ( kind = 4 ), parameter :: q1 =  0.04166669E+00
  real ( kind = 4 ), parameter :: q2 =  0.02083148E+00
  real ( kind = 4 ), parameter :: q3 =  0.00801191E+00
  real ( kind = 4 ), parameter :: q4 =  0.00144121E+00
  real ( kind = 4 ), parameter :: q5 = -0.00007388E+00
  real ( kind = 4 ), parameter :: q6 =  0.00024511E+00
  real ( kind = 4 ), parameter :: q7 =  0.00024240E+00
  real ( kind = 4 ) r
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) s
  real ( kind = 4 ) s2
  !real ( kind = 4 ) sexpo
  real ( kind = 4 ) si
  real ( kind = 4 ) sgamma
  !real ( kind = 4 ) snorm
  real ( kind = 4 ), parameter :: sqrt32 = 5.656854E+00
  real ( kind = 4 ) t
  real ( kind = 4 ) u
  real ( kind = 4 ) v
  real ( kind = 4 ) w
  real ( kind = 4 ) x

  if ( 1.0E+00 <= a ) then

    s2 = a - 0.5E+00
    s = sqrt ( s2 )
    d = sqrt32 - 12.0E+00 * s
!
!  Immediate acceptance.
!
    t = snorm ( )
    x = s + 0.5E+00 * t
    sgamma = x * x

    if ( 0.0E+00 <= t ) then
      return
    end if
!
!  Squeeze acceptance.
!
    u = r4_uni_01 ( )
    if ( d * u <= t * t * t ) then
      return
    end if

    r = 1.0E+00 / a
    q0 = (((((( q7 &
      * r + q6 ) &
      * r + q5 ) &
      * r + q4 ) &
      * r + q3 ) &
      * r + q2 ) &
      * r + q1 ) &
      * r
!
!  Approximation depending on size of parameter A.
!
    if ( 13.022E+00 < a ) then
      b = 1.77E+00
      si = 0.75E+00
      c = 0.1515E+00 / s
    else if ( 3.686E+00 < a ) then
      b = 1.654E+00 + 0.0076E+00 * s2
      si = 1.68E+00 / s + 0.275E+00
      c = 0.062E+00 / s + 0.024E+00
    else
      b = 0.463E+00 + s + 0.178E+00 * s2
      si = 1.235E+00
      c = 0.195E+00 / s - 0.079E+00 + 0.16E+00 * s
    end if
!
!  Quotient test.
!
    if ( 0.0E+00 < x ) then

      v = 0.5E+00 * t / s

      if ( 0.25E+00 < abs ( v ) ) then
        q = q0 - s * t + 0.25E+00 * t * t + 2.0E+00 * s2 * log ( 1.0E+00 + v )
      else
        q = q0 + 0.5E+00 * t * t * (((((( a7 &
          * v + a6 ) &
          * v + a5 ) &
          * v + a4 ) &
          * v + a3 ) &
          * v + a2 ) &
          * v + a1 ) &
          * v
      end if

      if ( log ( 1.0E+00 - u ) <= q ) then
        return
      end if

    end if

    do

      e = sexpo ( )
      u = 2.0E+00 * r4_uni_01 ( ) - 1.0E+00
 
      if ( 0.0E+00 <= u ) then
        t = b + abs ( si * e )
      else
        t = b - abs ( si * e )
      end if
!
!  Possible rejection.
!
      if ( t < -0.7187449E+00 ) then
        cycle
      end if
!
!  Calculate V and quotient Q.
!
      v = 0.5E+00 * t / s

      if ( 0.25E+00 < abs ( v ) ) then
        q = q0 - s * t + 0.25E+00 * t * t + 2.0E+00 * s2 * log ( 1.0E+00 + v )
      else
        q = q0 + 0.5E+00 * t * t * (((((( a7 &
          * v + a6 ) &
          * v + a5 ) &
          * v + a4 ) &
          * v + a3 ) &
          * v + a2 ) &
          * v + a1 ) &
          *  v
      end if
!
!  Hat acceptance.
!
      if ( q <= 0.0E+00 ) then
        cycle
      end if

      if ( 0.5E+00 < q ) then
        w = exp ( q ) - 1.0E+00
      else
        w = (((( e5 * q + e4 ) * q + e3 ) * q + e2 ) * q + e1 ) * q
      end if
!
!  May have to sample again.
!
      if ( c * abs ( u ) <= w * exp ( e - 0.5E+00 * t * t ) ) then
        exit
      end if

    end do

    x = s + 0.5E+00 * t
    sgamma = x * x

    return
!
!  Method for A < 1.
!
  else

    b = 1.0E+00 + 0.3678794E+00 * a

    do

      p = b * r4_uni_01 ( )

      if ( p < 1.0E+00 ) then

        sgamma = exp ( log ( p ) / a )

        if ( sgamma <= sexpo ( ) ) then
          return
        end if

        cycle

      end if

      sgamma = - log ( ( b - p ) / a )

      if ( ( 1.0E+00 - a ) * log ( sgamma ) <= sexpo ( ) ) then
        exit
      end if

    end do

  end if

  return
end
function snorm ( )

!*****************************************************************************80
!
!! SNORM samples the standard normal distribution.
!
!  Discussion:
!
!    This procedure corresponds to algorithm FL, with M = 5, in the reference.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Reference:
!
!    Joachim Ahrens, Ulrich Dieter,
!    Extensions of Forsythe's Method for Random
!    Sampling from the Normal Distribution,
!    Mathematics of Computation,
!    Volume 27, Number 124, October 1973, page 927-937.
!
!  Parameters:
!
!    Output, real ( kind = 4 ) SNORM, a random deviate from the distribution.
!
  implicit none

  real ( kind = 4 ) a(32)
  real ( kind = 4 ) aa
  real ( kind = 4 ) d(31)
  real ( kind = 4 ) h(31)
  integer ( kind = 4 ) i
  !real ( kind = 4 ) r4_uni_01
  real ( kind = 4 ) s
  real ( kind = 4 ) snorm
  real ( kind = 4 ) t(31)
  real ( kind = 4 ) tt
  real ( kind = 4 ) u
  real ( kind = 4 ) ustar
  real ( kind = 4 ) w
  real ( kind = 4 ) y

  save a
  save d
  save h
  save t

  data a / &
        0.0000000E+00, 0.3917609E-01, 0.7841241E-01, 0.1177699E+00, &
        0.1573107E+00, 0.1970991E+00, 0.2372021E+00, 0.2776904E+00, &
        0.3186394E+00, 0.3601299E+00, 0.4022501E+00, 0.4450965E+00, &
        0.4887764E+00, 0.5334097E+00, 0.5791322E+00, 0.6260990E+00, &
        0.6744898E+00, 0.7245144E+00, 0.7764218E+00, 0.8305109E+00, &
        0.8871466E+00, 0.9467818E+00, 1.009990E+00,  1.077516E+00, &
        1.150349E+00,  1.229859E+00,  1.318011E+00,  1.417797E+00, &
        1.534121E+00,  1.675940E+00,  1.862732E+00,  2.153875E+00 /

  data d / &
        0.0000000E+00, 0.0000000E+00, 0.0000000E+00, 0.0000000E+00, &
        0.0000000E+00, 0.2636843E+00, 0.2425085E+00, 0.2255674E+00, &
        0.2116342E+00, 0.1999243E+00, 0.1899108E+00, 0.1812252E+00, &
        0.1736014E+00, 0.1668419E+00, 0.1607967E+00, 0.1553497E+00, &
        0.1504094E+00, 0.1459026E+00, 0.1417700E+00, 0.1379632E+00, &
        0.1344418E+00, 0.1311722E+00, 0.1281260E+00, 0.1252791E+00, &
        0.1226109E+00, 0.1201036E+00, 0.1177417E+00, 0.1155119E+00, &
        0.1134023E+00, 0.1114027E+00, 0.1095039E+00 /

  data h / &
        0.3920617E-01, 0.3932705E-01, 0.3950999E-01, 0.3975703E-01, &
        0.4007093E-01, 0.4045533E-01, 0.4091481E-01, 0.4145507E-01, &
        0.4208311E-01, 0.4280748E-01, 0.4363863E-01, 0.4458932E-01, &
        0.4567523E-01, 0.4691571E-01, 0.4833487E-01, 0.4996298E-01, &
        0.5183859E-01, 0.5401138E-01, 0.5654656E-01, 0.5953130E-01, &
        0.6308489E-01, 0.6737503E-01, 0.7264544E-01, 0.7926471E-01, &
        0.8781922E-01, 0.9930398E-01, 0.1155599E+00, 0.1404344E+00, &
        0.1836142E+00, 0.2790016E+00, 0.7010474E+00 /

  data t / &
        0.7673828E-03, 0.2306870E-02, 0.3860618E-02, 0.5438454E-02, &
        0.7050699E-02, 0.8708396E-02, 0.1042357E-01, 0.1220953E-01, &
        0.1408125E-01, 0.1605579E-01, 0.1815290E-01, 0.2039573E-01, &
        0.2281177E-01, 0.2543407E-01, 0.2830296E-01, 0.3146822E-01, &
        0.3499233E-01, 0.3895483E-01, 0.4345878E-01, 0.4864035E-01, &
        0.5468334E-01, 0.6184222E-01, 0.7047983E-01, 0.8113195E-01, &
        0.9462444E-01, 0.1123001E+00, 0.1364980E+00, 0.1716886E+00, &
        0.2276241E+00, 0.3304980E+00, 0.5847031E+00 /

  u = r4_uni_01 ( )
  if ( u <= 0.5E+00 ) then
    s = 0.0E+00
  else
    s = 1.0E+00
  end if
  u = 2.0E+00 * u - s
  u = 32.0E+00 * u
  i = int ( u )
  if ( i == 32 ) then
    i = 31
  end if
!
!  Center
!
  if ( i /= 0 ) then

    ustar = u - real ( i )
    aa = a(i)

    do

      if ( t(i) < ustar ) then

        w = ( ustar - t(i) ) * h(i)

        y = aa + w

        if ( s /= 1.0E+00 ) then
          snorm = y
        else
          snorm = -y
        end if

        return

      end if

      u = r4_uni_01 ( )
      w = u * ( a(i+1) - aa )
      tt = ( 0.5E+00 * w + aa ) * w

      do

        if ( tt < ustar ) then
          y = aa + w
          if ( s /= 1.0E+00 ) then
            snorm = y
          else
            snorm = -y
          end if
          return
        end if

        u = r4_uni_01 ( )

        if ( ustar < u ) then
          exit
        end if

        tt = u
        ustar = r4_uni_01 ( )

      end do

      ustar = r4_uni_01 ( )

    end do
!
!  Tail
!
  else

    i = 6
    aa = a(32)

    do

      u = u + u

      if ( 1.0E+00 <= u ) then
        exit
      end if

      aa = aa + d(i)
      i = i + 1

    end do

    u = u - 1.0E+00
    w = u * d(i)
    tt = ( 0.5E+00 * w + aa ) * w

    do

      ustar = r4_uni_01 ( )

      if ( tt < ustar ) then
        y = aa + w
        if ( s /= 1.0E+00 ) then
          snorm = y
        else
          snorm = -y
        end if
        return
      end if

      u = r4_uni_01 ( )

      if ( u <= ustar ) then
        tt = u
      else
        u = r4_uni_01 ( )
        w = u * d(i)
        tt = ( 0.5E+00 * w + aa ) * w
      end if

    end do

  end if

end
subroutine spofa ( a, lda, n, info )

!*****************************************************************************80
!
!! SPOFA factors a real symmetric positive definite matrix.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    20 March 2013
!
!  Author:
!
!    Cleve Moler
!
!  Parameters:
!
!    Input/output, real ( kind = 4 ) A(LDA,N).  On input, the symmetric matrix
!    to be factored.  Only the diagonal and upper triangle are accessed.  
!    On output, the strict lower triangle has not been changed.  The diagonal
!    and upper triangle contain an upper triangular matrix R such that 
!    A = R' * R.  If INFO is nonzero, the factorization was not completed.
!
!    Input, integer ( kind = 4 ) LDA, the leading dimension of the array A.
!    N <= LDA.
!
!    Input, integer ( kind = 4 ) N, the order of the matrix.
!
!    Output, integer ( kind = 4 ) INFO, error flag.
!    0, no error was detected.
!    K, the leading minor of order K is not positive definite.
!
  implicit none

  integer ( kind = 4 ) lda
  integer ( kind = 4 ) n

  real ( kind = 4 ) a(lda,n)
  integer ( kind = 4 ) info
  integer ( kind = 4 ) j
  integer ( kind = 4 ) jm1
  integer ( kind = 4 ) k
  real ( kind = 4 ) s
  !real ( kind = 4 ) sdot
  real ( kind = 4 ) t

  info = 0

  do j = 1, n
    info = j
    s = 0.0E+00
    jm1 = j - 1
    do k = 1, jm1
      t = a(k,j) - sdot ( k-1, a(1,k), 1, a(1,j), 1 )
      t = t / a(k,k)
      a(k,j) = t
      s = s + t * t
    end do
    s = a(j,j) - s
    if ( s <= 0.0E+00 ) then
      info = j
      return
    end if
    a(j,j) = sqrt ( s )
  end do

  return
end
subroutine stats ( x, n, av, var, xmin, xmax )

!*****************************************************************************80
!
!! STATS computes statistics for a given array.
!
!  Discussion:
!
!    This procedure computes the average and variance of an array.
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    31 March 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, real ( kind = 4 ) X(N), the array to be analyzed.
!
!    Input, integer ( kind = 4 ) N, the dimension of the array.
!
!    Output, real ( kind = 4 ) AV, the average value.
!
!    Output, real ( kind = 4 ) VAR, the variance.
!
!    Output, real ( kind = 4 ) XMIN, XMAX, the minimum and maximum entries.
!
  implicit none

  integer ( kind = 4 ) n

  real ( kind = 4 ) av
  integer ( kind = 4 ) i
  real ( kind = 4 ) total
  real ( kind = 4 ) var
  real ( kind = 4 ) x(n)
  real ( kind = 4 ) xmax
  real ( kind = 4 ) xmin

  xmin = x(1)
  xmax = x(1)
  total = 0.0E+00
  do i = 1, n
    total = total + x(i)
    xmin = min ( xmin, x(i) )
    xmax = max ( xmax, x(i) )
  end do

  av = total / real ( n )

  total = 0.0E+00
  do i = 1, n
    total = total + ( x(i) - av ) ** 2
  end do
  var = total / real ( n - 1 )

  return
end
subroutine trstat ( pdf, parin, av, var )

!*****************************************************************************80
!
!! TRSTAT returns the mean and variance for distributions.
!
!  Discussion:
!
!    This procedure returns the mean and variance for a number of statistical
!    distributions as a function of their parameters.
!
!    The input vector PARIN is used to pass in the parameters necessary
!    to specify the distribution.  The number of these parameters varies
!    per distribution, and it is necessary to specify an ordering for the
!    parameters used to a given distribution.  The ordering chosen here
!    is as follows:
!
!    bet
!      PARIN(1) is A
!      PARIN(2) is B
!    bin
!      PARIN(1) is Number of trials
!      PARIN(2) is Prob Event at Each Trial
!    chi
!      PARIN(1) = df
!    exp
!      PARIN(1) = mu
!    f
!      PARIN(1) is df numerator
!      PARIN(2) is df denominator
!    gam
!      PARIN(1) is A
!      PARIN(2) is R
!    nbn
!      PARIN(1) is N
!      PARIN(2) is P
!    nch
!      PARIN(1) is df
!      PARIN(2) is noncentrality parameter
!    nf
!      PARIN(1) is df numerator
!      PARIN(2) is df denominator
!      PARIN(3) is noncentrality parameter
!    nor
!      PARIN(1) is mean
!      PARIN(2) is standard deviation
!    poi
!      PARIN(1) is Mean
!    unf
!      PARIN(1) is LOW bound
!      PARIN(2) is HIGH bound
!
!  Licensing:
!
!    This code is distributed under the GNU LGPL license.
!
!  Modified:
!
!    01 April 2013
!
!  Author:
!
!    Original FORTRAN77 version by Barry Brown, James Lovato.
!    FORTRAN90 version by John Burkardt.
!
!  Parameters:
!
!    Input, character * ( 4 ) PDF, indicates the distribution:
!    'bet'  beta distribution
!    'bin'  binomial
!    'chi'  chisquare
!    'exp'  exponential
!    'f'    F (variance ratio)
!    'gam'  gamma
!    'nbn'  negative binomial
!    'nch'  noncentral chisquare
!    'nf'   noncentral f
!    'nor'  normal
!    'poi'  Poisson
!    'unf'  uniform
!
!    Input, real ( kind = 4 ) PARIN(*), the parameters of the distribution.
!
!    Output, real ( kind = 4 ) AV, the mean of the specified distribution.
!
!    Output, real ( kind = 4 ) VAR, the variance of the specified distribuion.
!
  implicit none

  real ( kind = 4 ) a
  real ( kind = 4 ) av
  real ( kind = 4 ) b
  integer ( kind = 4 ) n
  real ( kind = 4 ) p
  real ( kind = 4 ) parin(*)
  character * ( 4 ) pdf
  real ( kind = 4 ) r
  real ( kind = 4 ) var
  real ( kind = 4 ) width

  if ( pdf == 'bet' ) then

    av = parin(1) / ( parin(1) + parin(2) )
    var = ( av * parin(2) ) / ( ( parin(1) + parin(2) ) * &
      ( parin(1) + parin(2) + 1.0E+00 ) )

  else if ( pdf == 'bin' ) then

    n = int ( parin(1) )
    p = parin(2)
    av = real ( n ) * p
    var = real ( n ) * p * ( 1.0E+00 - p )

  else if ( pdf == 'chi' ) then

    av = parin(1)
    var = 2.0E+00 * parin(1)

  else if ( pdf == 'exp' ) then

    av = parin(1)
    var = av ** 2

  else if ( pdf == 'f' ) then

    if ( parin(2) <= 2.0001E+00 ) then
      av = -1.0E+00
    else
      av = parin(2) / ( parin(2) - 2.0E+00 )
    end if

    if ( parin(2) <= 4.0001E+00 ) then
      var = -1.0E+00
    else
      var = ( 2.0E+00 * parin(2) ** 2 * ( parin(1) + parin(2) - 2.0E+00 ) ) / &
        ( parin(1) * ( parin(2) - 2.0E+00 ) ** 2 * ( parin(2) - 4.0E+00 ) )
    end if

  else if ( pdf == 'gam' ) then

    a = parin(1)
    r = parin(2)
    av = r / a
    var = r / a ** 2

  else if ( pdf == 'nbn' ) then

    n = int ( parin(1) )
    p = parin(2)
    av = n * ( 1.0E+00 - p ) / p
    var = n * ( 1.0E+00 - p ) / p ** 2

  else if ( pdf == 'nch' ) then

    a = parin(1) + parin(2)
    b = parin(2) / a
    av = a
    var = 2.0E+00 * a * ( 1.0E+00 + b )

  else if ( pdf == 'nf' ) then

    if ( parin(2) <= 2.0001E+00 ) then
      av = -1.0E+00
    else
      av = ( parin(2) * ( parin(1) + parin(3) ) ) &
        / ( ( parin(2) - 2.0E+00 ) * parin(1) )
    end if

    if ( parin(2) <= 4.0001E+00 ) then
      var = -1.0E+00
    else
      a = ( parin(1) + parin(3) ) ** 2 &
        + ( parin(1) + 2.0E+00 * parin(3) ) * ( parin(2) - 2.0E+00 )
      b = ( parin(2) - 2.0E+00 ) ** 2 * ( parin(2) - 4.0E+00 )
      var = 2.0E+00 * ( parin(2) / parin(1) ) ** 2 * ( a / b )
    end if

  else if ( pdf == 'nor' ) then

    av = parin(1)
    var = parin(2) ** 2

  else if ( pdf == 'poi' ) then

    av = parin(1)
    var = parin(1)

  else if ( pdf == 'unf' ) then

    width = parin(2) - parin(1)
    av = parin(1) + width / 2.0E+00
    var = width ** 2 / 12.0E+00

  else

    write ( *, '(a)' ) ' '
    write ( *, '(a)' ) 'TRSTAT - Fatal error!'
    write ( *, '(a)' ) '  Illegal input value for PDF.'
    stop 1

  end if

  return
end

end module mass_flux_mod
