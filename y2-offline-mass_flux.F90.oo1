!--- version date: 20200610 ---

!==================
!  log - 
!    2020/07/10 -  add ice-liquid water potential temperature in mass_flux
!    2020/07/14 -  check compute_thv_qc. Looks okay. Need to check when compute_qs is allowed
!    2020/07/17 -  (NEED TO FIX) Potential issues in mass_flux_tendency
!                  How to avoid negative tracer concentration?
!                  If w'q'(k) >> w'q'(k+1), dq/dt is a large negative. Because q(t+dt) = q(t) + dq/dt*dt,
!                  when dq/dt is a large negative number, q(t+dt) can be negative, which is unphysical.
!                  If q is forced to be larger than zero, what is the limit of dq/dt? I thought the limited value is q(t)/dt
!                  but when q(t) is extremely small (like the DCBL case), dq/dt would be extremely small.
!                  The problem is that w'q' has nothing to do with the q values.
!==================

module edmf_test

implicit none

!-----------------------------------------------------------------------
!   module performs Eddy-Diffusivity/Mass-Flux scheme
!-----------------------------------------------------------------------

! module constants_mod, /ncrc/home2/Yi-hsuan.Chen/awg/xanadu/SCM_am4_xanadu_test222/src/FMS/constants/constants.F90
! module sat_vapor_pres_mod, /ncrc/home2/Yi-hsuan.Chen/awg/xanadu/SCM_am4_xanadu_test222/src/FMS/sat_vapor_pres/sat_vapor_pres.F90
!use sat_vapor_pres_mod,    only: compute_qs
!use      constants_mod, only: rdgas, rvgas, kappa, grav, d622, d378, d608
real, public, parameter :: kappa  = 2./7.
real, public, parameter :: rdgas  = 287.04
real, public, parameter :: rvgas = 461.50
real, public, parameter :: d622   = rdgas/rvgas
real, public, parameter :: d378   = 1.-d622
real, public, parameter :: d608   = d378/d622
real, public, parameter :: grav   = 9.80
real, public, parameter :: hlv      = 2.5e6     !< Latent heat of evaporation [J/kg]
real, public, parameter :: hlf      = 3.3358e5  !< Latent heat of fusion [J/kg]
real, public, parameter :: cp_air   = 1004.6      !< Specific heat capacity of dry air at constant pressure [J/kg/deg]
real, public, parameter :: dens_h2o = 1000. !< Density of liquid water [kg/m^3]


type time_type
  integer :: tt1, tt2
end type time_type

integer, public, parameter :: up_num = 10
logical, public :: do_mf_micro = .false.
logical, public :: printout_ncl = .true.
!logical, public :: do_printouts = .true.
logical, public :: do_printouts = .false.
!logical :: do_writeout_profile = .false.
logical :: do_writeout_profile = .true.
character*20, parameter :: option_solver = "explicit"
!character*20, parameter :: option_solver = "implicit"

! compute phi_bar at half levels to calculate flux (now only available for the explicit solver)
!   default: centered-difference, i.e. phi_bar(k-1/2) = 0.5( phi_bar(k-1)+phi_bar(k) )
!   upwind : upwind-difference  , i.e. phi_bar(k-1/2) = phi_bar(k)
!character*20, parameter :: option_env_half = "upwind"   
character*20, parameter :: option_env_half = "centered-diff"   

! compute updraft properties on full levels. The default is half levels
!character*20, parameter :: option_updraft_level = "full" ! put updrafts at full levels   
character*20, parameter :: option_updraft_level = "half" ! default put updrafts at half levels   

! tunable parameters
real, public, parameter :: &
    w_max = 2.,            & ! maximum of updraft velcovity (m/s)
    qt_excess_max = 1.e-3, & ! maximum of moisture excess at updraft base (kg/kg)
    thv_excess_max = 0.5,  & ! maximum of virtual potential temperature excess at updraft base (K)
    z_pbl_min = 100.,      & ! set minimum PBL height in order to avoid unrealistic lower BCs of updrafts
    w_star_min = 0.1,      & ! set minimum w* in order to avoid unrealistic lower BCs of updrafts
    ent0 = 0.2,            & ! epsilon_0, Eq (14), Suselj (2019b)
    ent_length = 100.,     & ! L_epsilon, Eq (30), Suselj (2019b). Set to a constant at this moment
    z0_over_z_pbl = 0.1,   & ! z_0/z_pbl, Eq (A19-21), Suselj (2019a)
    pwmin = 1.,            & ! pwmin*w_sigma is the smallest surface vertical velocity for updraft ensembles
    pwmax = 3.,            & ! pwmax*w_sigma is the largest  surface vertical velocity for updraft ensembles
    aw = 1.,               & ! a_w, Eq (12), Suselj (2019b)  
    bw = 1.5                 ! b_w, Eq (12), Suselj (2019b)

!real, public, parameter :: rh_flag111 = 0.   ! a test simulation that put some moisture at the atmospheric lowest level
real, public, parameter :: rh_flag111 = 0.8   ! a test simulation that put some moisture at the atmospheric lowest level
                                              ! and see how much cloud water is condensed in the updraft.
                                              ! The purpose of this test is to understand how frequent moist updrafts are.
!character*20, public, parameter :: rh_flag111_layer = "column"
character*20, public, parameter :: rh_flag111_layer = "lowest_atm"

character*40, parameter :: filter_massflux = ""
!character*40, parameter :: filter_massflux = "if_moist_allmf_off"       ! if moist updraft is present, set ALL mass flux effect to zero
!character*40, parameter :: filter_massflux = "if_moist_allmoist_off"   ! if moist updraft is present, exclude moist updraft contribution
character*10 :: choose_return = "u_v_t_q"


character*100, public :: data_source

contains

!###########################################
! subroutine mass_flux
!
! To-do (as of 06/21/2020)
!   1. Use ice-liquid water potential temperature, instead of virtual temperature
!
! Purpose:
!   (1) Compute updraft properties based on the grid-scale input variables, such as uu,vv,tt,qq, etc.
!   (2) Compute subgrid mixing from all updrafts, i.e. <w'phi'>
!   (3) Compute the tendencey terms by the subgrid mixing
!
! Numerical discretation. Note that when the vertical indexing is reversed when calculating updraft properties and tendencies from the implicit solver, in order to be consistent with Suselj et al. (2019b, JAS). 
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_*
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
! History:
!   2020/05/14  Add outputs of sum_up_a and avg_up_w
!               Add z_pbl_min and w_star1_min
!   2020/05/17  Make the vertical indexing of sum_up_* consistent with CM4 indexing
!   2020/06/04  Add sum_up_mass output argument
!   2020/06/07  Add check part
!   2020/06/21  Move mass_flux_tendencies program here, to simplify the calling structure
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
! References:
!   Suselj et al. (2014, WAF): 
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS): 
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1 
!###########################################

subroutine mass_flux ( is, js, dt, Time_next,                                &
                       p_half, p_full, z_half, z_full,                       & 
                       u_star, b_star, q_star, z_pbl,                        &
                       uu, vv, tt, qq,                                       &
                       is_mass_flux,                                         &
                       sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                       sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                       udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    dt       -  Time step               (sec)
!    Time_next- variable needed for netcdf diagnostics
!    p_half   -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!    p_full   -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!    z_half   -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!    z_full   -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!    uu       -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!    vv       -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!    tt       -  temperature             (K)     , dimension (nlon, nlat, nlay)
!    qq       -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)
!    z_pbl    -  boundary layer depth    (m)     , dimension (nlon, nlat)        ,see note below
!    u_star   -  friction velocity       (m/s)   , dimension (nlon, nlat)        ,see note below
!    b_star   -  buoyancy scale          (m/s^2) , dimension (nlon, nlat)        ,see note below
!    q_star   -  moisture scale          (kg/kg) , dimension (nlon, nlat)        ,see note below
!
! Set in namelist -  
!    up_num        - number of updrafts    (an integer)
!    do_mf_micro   - enable/disable microphysics computation in updrafts. 
!                      True: do moist processes. False: no moist processes, i.e. all updrafts are assumed to be dry
!    option_solver - option for solving the tendency terms. Detail description is in subroutine mass_flux_tendencies
!                      "explicit" uses an explicit scheme.     
!                      "implicit" uses an semi-implicit scheme
!
! Note:
!    1. z_pbl is from a PBL scheme, e.g. my25, tke_turb, etc
!
!    2. u_star and b_star are from monin_obukhov program, src/atmos_param/monin_obukhov/monin_obukhov_kernel.F90
!       q_star            is  from surface flux  program, src/FMScoupler/surface_flux.F90    
!
!            The magnitude of the wind stress is 
!                 density*(u_star**2)
!            The buoyancy flux, (g/theta_v) * <w'theta_v'>|surface, is
!                 u_star*b_star
!            The evaporation rate), kg vapor/m^2/s, is
!                 density*u_star*q_star
!                 So, u_star*q_star is surface moisture flux, <w'q'>, unit: (m/s * kg vapor/kg air)
!---------------------------------------------------------------------

  integer, intent(in)                   :: is, js
  real,    intent(in)                   :: dt
  type(time_type), intent(in)           :: Time_next             
  real,    intent(in), dimension(:,:,:) :: p_full, z_full  
  real,    intent(in), dimension(:,:,:) :: p_half, z_half  
  real,    intent(in), dimension(:,:,:) :: uu, vv, tt, qq  
  real,    intent(in), dimension(:,:)   :: z_pbl, u_star, b_star, q_star

!---------------------------------------------------------------------
! Arguments (Intent out)
!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!                                                        dimension (nlon,nlat)
!    sum_up_a        - sum of the fractional area of individual updraft
!                        i.e. area   (unit: none),           dimension (nlon, nlat, nlay+1)
!    sum_up_aw       - sum of the product of fractional area and vertical velocity for individual updraft
!                        i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_awu      - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!                        i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awv      - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!                        i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!    sum_up_awthv    - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!    sum_up_awthli   - sum of the product of fractional area, vertical velocity, and ice-liquid water potential temp for individual updraft
!                        i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!    sum_up_awqt     - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!                        i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!    avg_up_w        - averaged vertical velocity of updrafts, sum_up_aw/sum_up_a
!                        i.e. w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!    sum_up_massflux - sum of the updraft mass flux, i.e. rho * sum_up_aw
!                        i.e. a*w   (unit: kg/m2/s),           dimension (nlon, nlat, nlay+1)
!
!    udt_mf    -  zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!    vdt_mf    -  meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!    tdt_mf    -  temperature tendency                                (K/s)    , i.e. dt/dt
!    qdt_mf    -  specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!    thvdt_mf  -  virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!    thlidt_mf -  ice-liquid water potential temperature tendency     (K/s)    , i.e. dtheta_v/dt
!    qtdt_mf   -  total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!
! Note:
!   1. All updraft variables , sum_up_*, are at half level, i.e. the number of levels is nlay+1
!   2. All tendency variables, *dt_mf  , are at full level, i.e. the number of levels is nlay 
!---------------------------------------------------------------------

  real, intent(out), dimension(:,:)      :: &  ! dimension (nlon, nlat)
        is_mass_flux

  real, intent(out), dimension(:,:,:)       :: &  ! dimension (nlon, nlat, nlay+1)
        sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,     &
        sum_up_awthv, sum_up_awthli, sum_up_awqt,                       &
        avg_up_w, sum_up_massflux

  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
      thvdt_mf, thlidt_mf, qtdt_mf

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- variable for each updraft
  real, dimension(up_num, size(tt,1),size(tt,2),size(tt,3)+1)       :: &  ! dimension (up_num, nlon, nlat, nlay+1)
        each_up_a, each_up_aw,                                         &
        each_up_u, each_up_v, each_up_thv, each_up_thli, each_up_qt, each_up_qc,      &
        each_up_awu, each_up_awv, each_up_awthv,each_up_awthli, each_up_awqt,         &
        each_up_w, each_up_massflux

  !--- grid-mean variables for work
  real, dimension(size(tt,3)) ::      &  ! dimension (nlay)
        uu_rev, vv_rev, thv_rev,      &  ! reverse indexing so that these variables are counted from surface upward
        qt_rev, dz_rev,               &  !   i.e. k=1 is the lowermost level                       
        pfull_rev, thli_rev,          &
        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp

  real, dimension(size(tt,1),size(tt,2),size(tt,3)) :: &  ! dimension (nlon,nlat,nlay)
        qt,       & ! total water mixing ratio (kg/kg)
        th,       & ! potential temperature (K)
        thv,      & ! virtual potential temperature (K)
        thli,     & ! ice-liquid water potential temperature (K)
        tv,       & ! virtual temperature (K)
        rho_full, & ! air density at full levels (kg/m3)
        ape         ! (P/P0)^(-Rd/cp), factor to compute potential temperature
  
  real, dimension(size(tt,1),size(tt,2),size(tt,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
        rho_half,   &    ! air densivty at half levels
        w1_u1, w1_v1, w1_q1, w1_qt1, w1_thv1, w1_thli1, &
        up_z, up_rho, &
        sum_up_aqt, sum_up_awq, avg_up_qt, sum_up_aqc, avg_up_qc

  !--- updraft surface condition variables
  real ::       & 
        w_star1, qt_star1, thv_star1, &
        w_sigma, qt_sigma, thv_sigma, &
        w1_thv1_surf, w1_qt1_surf,    &
        wmin, wmax, wlower, wupper

  logical, dimension(up_num, size(tt,1),size(tt,2)) :: &             ! dimension (up_num, nlon,nlat)
        is_moist_updraft

  real, dimension(size(tt,1),size(tt,2)) :: &             ! dimension (nlon,nlat)
        is_moist_massflux                                 ! 0: dry mass flux (no condensed cloud water)
                                                          ! 1: moist mass flux with condensed cloud water

  !      The vertical indexing of up_* is NOT as the same as the input variables and sum_up_*.
  !      The indexing of up_* is counted from the surface, i.e. k=1 is the lowermost model level, 
  !      while the indexing of input variables (ex: uu,vv) is counted from the top, i.e. k=1 is the uppermost level 
   
  real, dimension(up_num,size(tt,3)+1) ::  &  ! dimension (up_num, nlay+1)
        up_u, up_v, up_w, up_w2,           &  ! updraft zonal, meridional, vertical velocity (m/s), and vertical kinetic energy (m^2/s^2)
        up_a, up_thv, up_thli,             &  ! updraft fractional area (0-1, unitless) and virtual potential temperature (K)
        up_qt, up_qq,                      &  ! updraft total specific humidity, i.e. water vapor + condensended water (kg/kg)
        up_qc, up_ql, up_qi                   ! updraft cloud water(qc), cloud liquid(ql), and cloud ice(qi) specific humidity (kg/kg)  

  real, dimension(up_num,size(tt,3)) ::    &  ! dimension (up_num, nlay)
        ent                                   ! updraft entrainment rate (1/m)
  real ::  &
        qt_src, thli_src,                  &  ! source terms for qt and thv
        ent_bw, ent_bw_EXP, entExp, buoy           
 
  integer ent_stoch                           ! stochastic factor for entrainment

  real :: water_frac ! liquid water fraction in updraft condensed water (0-1)

  !--- parameters
  real, parameter :: &
      p00 = 1000.0E2,      & ! 1000 hPa
      p00inv = 1./p00,     & ! 1/1000hPa 
      g = grav               ! gravity acceleration, 9.8 m/s^2

  character*20 :: varname

  !--- index variables & dimension
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
  logical used

  !--- variables for check
  character*100 :: data_source
  real, dimension(size(tt,3)+1) ::    &  ! dimension (nlay+1)
        phi_half
  logical do_printout_ncl
  logical do_check_consrv
  character*30, dimension(10) :: do_check_printouts
  real tt1,tt2,tt3
  integer ii1,ii2,ii3

!--------------------------------------------

!--- set dimensions
  ix  = size( tt, 1 )
  jx  = size( tt, 2 )
  kx  = size( tt, 3 )
  nx  = up_num
  kxp = kx + 1
  kxm = kx - 1
  ism = is - 1
  jsm = js - 1

!--- compute potential temperature, th
!            virtual potential temperature, thv
!            ice-liquid water potential temperature, thli
  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)  ! ape = (P/P0)^(-Rd/cp)
  th(:,:,:)=tt(:,:,:)*ape(:,:,:)  

  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

  thli(:,:,:)=th(:,:,:)   ! no cloud liquid/ice water from input, so thli equals to th
  !full expression of thli, thli(:,:,:)=th(:,:,:) - (hlv*qc(:,:,:)+hlf*qi(:,:,:)) /cp_air * ape(:,:,:)

!--- set total water mixing ratio  
  qt(:,:,:) = qq(:,:,:)  

!  !flag111 - set specific humidity at the lowest level
!  if (rh_flag111.gt.0.) then
!    if (rh_flag111_layer.eq."lowest_atm") then
!      call compute_qs(tt(1,1,kx), p_full(1,1,kx), tt1)
!      qt(1,1,kx) = tt1 * rh_flag111
!    else if (rh_flag111_layer.eq."column") then
!      do k=1,kx
!        call compute_qs(tt(1,1,k), p_full(1,1,k), tt1)
!        qt(1,1,k) = tt1 * rh_flag111
!      enddo
!    end if
!  end if
!  tv (:,:,:)=tt(:,:,:)*(qt(:,:,:)*d608+1.0)  ! because qq is changed, recompute thv
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  

!--- compute air density at full and half levels
  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)

  do i=1,ix
  do j=1,jx
  do k=1,kx-1
    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
  enddo
  enddo
  enddo
  rho_half(:,:,1)    = rho_full(:,:,1)  
  !rho_half(:,:,kx+1) = 0.               ! no air at the surface level
  rho_half(:,:,kxp) = p_half(:,:,kxp)/(rdgas*tv(:,:,kx))  ! though rho_half(kx+1) should not be used,
                                                            ! set to a value to prevent something divided by rho_half

!--- set the z coordinate and conrresponding air density for 
!      for updraft levels
  if (option_updraft_level.eq."full") then
    up_z  (:,:,1:kx) = z_full(:,:,1:kx)
    up_z  (:,:,kxp ) = z_half(:,:,kxp)

    up_rho(:,:,1:kx) = rho_full(:,:,1:kx)
    up_rho(:,:,kxp ) = rho_half(:,:,kxp)

  else
    up_z  (:,:,:) = z_half(:,:,:)
    up_rho(:,:,:) = rho_half(:,:,:)
  end if

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho

!--- initialize return variables
  is_mass_flux      = 0. 
  is_moist_massflux = 0.

  sum_up_a        = 0.
  sum_up_aw       = 0.
  sum_up_awu      = 0.
  sum_up_awv      = 0.
  sum_up_awthv    = 0.
  sum_up_awthli   = 0.
  sum_up_awq      = 0.
  sum_up_awqt     = 0.
  sum_up_massflux = 0.

  avg_up_w        = 0.
  avg_up_qt       = 0.
  sum_up_aqt      = 0.
  avg_up_qc       = 0.
  sum_up_aqc      = 0.

  udt_mf          = 0.
  vdt_mf          = 0.
  tdt_mf          = 0.
  qdt_mf          = 0.
  thvdt_mf        = 0.
  thlidt_mf       = 0.
  qtdt_mf         = 0.

  !--- initialize work variables
  each_up_a        = 0.
  each_up_aw       = 0.
  each_up_awu      = 0.
  each_up_awv      = 0.
  each_up_awthv    = 0.
  each_up_awqt     = 0.
  each_up_massflux = 0.

  each_up_w        = 0.
  each_up_u        = 0.
  each_up_v        = 0.
  each_up_thv      = 0.
  each_up_qt       = 0.

  is_moist_updraft = .false.

!-------------------------------------
!   compute the updraft mass flux
!-------------------------------------

  !--- loop for each (i,j) point
  do i=1,ix
  do j=1,jx

    !--- initialize working variables
    uu_rev    = 0.
    vv_rev    = 0.
    qt_rev    = 0.
    thv_rev   = 0.
    dz_rev    = 0.
    pfull_rev = 0.
    up_u      = 0.
    up_v      = 0.
    up_w      = 0.
    up_w2     = 0.
    up_a      = 0.
    up_thv    = 0.
    up_thli   = 0.
    up_qq     = 0.
    up_qc     = 0.
    up_qt     = 0.
    ent       = 0.

    !--- reverse grid-mean variables so that the vertical index counting from the surface
    !      upward, i.e. k=1 is the lowermost model level
    do k=1,kx
      kk=kx-k+1
      uu_rev   (kk) = uu  (i,j,k)
      vv_rev   (kk) = vv  (i,j,k)
      qt_rev   (kk) = qt  (i,j,k)
      thv_rev  (kk) = thv (i,j,k)
      thli_rev (kk) = thli(i,j,k)
      pfull_rev(kk) = p_full(i,j,k)
      dz_rev   (kk) = up_z(i,j,k) - up_z(i,j,k+1)
    enddo 

!------------------------------------------
!   compute the mass flux of each updraft
!------------------------------------------
    !--- If the buoyancy flux (b_star*u_star) is positive,
    !      there are updrafts. Otherwise, there is no any updraft.
    if (b_star(i,j) .gt. 0.) then   ! use b_star here because u_star is always positive

     !------ set entrainment coefficients for each updraft ------
     !         ref: Eq (14), Suselj et al. (2019b)  
     do n=1,nx
        do k=1,kx
          call random_Poisson(dz_rev(k)/ent_length, .true., ent_stoch)
          ent(n,k)  = (ent0 / dz_rev(k)) * real(ent_stoch)
        end do 
      end do

!--------------------------------------
! set initial conditions for updrafts
!      Ref: Suselj et al. (2019a, JAS), Appendix A
!
! Although the vertical index of the updraft base is 1, which is at the surface, 
! this does not mean the updrafts start right at the surface.
! Conceptually, the updrafts start a bit above the surface, say, delta_z above the surface.
! Assuming delta_z is small, the distance between delta_z to the lowest half level is 
! approximately the distance between the surface to the lowest half level.
! That is why the vertical index of updraft base is set to 1.
!--------------------------------------

      !--- get surface buoyancy flux, <w'thv'>, and moisture flux <w'qt1>, < > means average.
      w1_thv1_surf = u_star(i,j) * b_star(i,j) * thv_rev(1)/g
      w1_qt1_surf  = u_star(i,j) * q_star(i,j)

      !--- compute scale variables of vertical velocity             (w_star1  , m/s  )
      !                               specific humidity             (qt_start , kg/kg)
      !                               virtual potential temperature (thv_star1, K    )
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_star1   = u_star(i,j)*b_star(i,j)*max(z_pbl_min,z_pbl(i,j))  ! note that u_star*b_star = (g/theta_v) * <w'theta_v'>|surface
                                                                     ! set z_pbl_min in order to avoid w_star1=0 
                                                                     ! that would cause unrealistically large thv at the bottom of the updrafts
      w_star1   = max(w_star_min, w_star1**(1./3.))                  ! get convetive velocity scale, w*
      qt_star1  = w1_qt1_surf /w_star1
      thv_star1 = w1_thv1_surf/w_star1

      !--- compute variances of vertical velocity (w_sigma)
      !                         specific humidity (qt_sigma)
      !                         virtual potential temperature (thv_sigma)
      !    Ref:  Eq (A19-A21),  Suselj et al. (2019a)
      w_sigma    = 1.34 * w_star1    * (z0_over_z_pbl)**(1./3.) * (1.-0.8*z0_over_z_pbl) 
      qt_sigma   = 1.34 * qt_star1   * (z0_over_z_pbl)**(-1./3.)
      thv_sigma  = 1.34 * thv_star1  * (z0_over_z_pbl)**(-1./3.)

      !--- set the upper and lower boundaries of surface vertical velocity for updraft ensemble
      wmin = w_sigma * pwmin
      wmax = w_sigma * pwmax

      !--- The surface vertical velocity is assumed to exhibit a normal distribution, bounding by wmin and wmax.
      !      The range of (wmax-wmin) is discretized into N bins and the mean of each bin is then assigned to each updraft. 
      do n=1,nx
        wlower = wmin + real(n-1)*(wmax-wmin)/real(nx)
        wupper = wmin + real(n)  *(wmax-wmin)/real(nx)
        
        up_u  (n,1) = uu_rev(1)
        up_v  (n,1) = vv_rev(1)
        up_w  (n,1) = min(w_max, 0.5*(wlower+wupper))
        up_w2 (n,1) = up_w(n,1)**2

        up_a   (n,1) = 0.5*erf(wupper/(sqrt(2.)*w_sigma))-0.5*erf(wlower/(sqrt(2.)*w_sigma)) ! ref: Eq (A15), Suselj et al. (2019a)
        up_thv (n,1) = thv_rev(1) + min(thv_excess_max, 0.58*up_w(n,1)*thv_sigma/w_sigma)    ! ref: Eq (A17), Suselj et al. (2019a)
        up_qt  (n,1) = qt_rev (1) + min(qt_excess_max , 0.58*up_w(n,1)*qt_sigma /w_sigma)    ! ref: Eq (A18), Suselj et al. (2019a)
        up_qc  (n,1) = 0.
        up_qq  (n,1) = up_qt(n,1) - up_qc(n,1)
        up_thli(n,1) = up_thv(n,1)/(up_qt(n,1)*d608+1.0)   ! no ice/liquid water so up_thli = up_theta

      enddo ! end loop of n

!-------------------------------------------
! compute the properties of each updraft
!-------------------------------------------

      !--- loop for each updraft
      do n=1,nx
        do k=1,kx

          !--- do microphysics processes (or not) in updrafts, 
          !      such as condensation, precipitation, etc
          if (do_mf_micro) then
            qt_src  = 0.         
            thli_src = 0. 
            !call compute_src_thli_qt        
          else
            qt_src  = 0.         
            thli_src = 0.         
          endif

          !--- set updraft area, updraft area does not change with height
          up_a (n,k+1) = up_a (n,k)

          !--- compute updraft thli,qt,u,v. Ref: Eq (A3), Suselj et al. (2014)
          entEXP = exp(-ent(n,k)*dz_rev(k))

          up_thli(n,k+1) = thli_rev(k)*(1.-entEXP) + up_thli(n,k)*entEXP + thli_src
          up_qt  (n,k+1) = qt_rev  (k)*(1.-entEXP) + up_qt  (n,k)*entEXP + qt_src
          up_u   (n,k+1) = uu_rev  (k)*(1.-entEXP) + up_u   (n,k)*entEXP
          up_v   (n,k+1) = vv_rev  (k)*(1.-entEXP) + up_v   (n,k)*entEXP

!if (n.eq.5) then
!print*,'----------------'
!print*,'updraft n',n
!print*,'----------------'
!  print*,'k,extEXP',k,entEXP
!  print*,'k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)'
!  print*,'  ',k,thli_rev(k),up_thli(n,k),up_thli(n,k+1)
!  print*,'k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)'
!  print*,'  ',k,qt_rev(k),up_qt(n,k),up_qt(n,k+1)
!endif

          !up_thv (n,k+1) = up_thli (n,k+1)  ! this will be replaced when moist processes are in

          !--- obtain updraft thv and qc
          !flag111 - set water_frac=1 at this moment
          water_frac = 1. 
          call compute_thv_qc( up_qt(n,k+1), up_thli(n,k+1), pfull_rev(k+1), water_frac, &
                               up_thv(n,k+1),up_qq(n,k+1), up_qc(n,k+1), up_ql(n,k+1), up_qi(n,k+1))

          !--- compute updraft vertical kinetic energy. Ref: Eq (B12), Suselj et al. (2019b)
          if (option_updraft_level.eq."full") then
            buoy = g * (up_thv(n,k+1)/thv_rev(k) - 1.)
            !print*,'k,up_thv(n,k+1)/thv_rev(k)',k,up_thv(n,k+1),thv_rev(k)
          else
            buoy = g * (0.5*(up_thv(n,k)+up_thv(n,k+1))/thv_rev(k) - 1.)
          end if
          ent_bw = bw*ent(n,k)
          ent_bw_EXP = exp(-2.*ent_bw*dz_rev(k))

          if (ent_bw.eq.0.) then
            up_w2(n,k+1) = up_w2(n,k) + 2.*aw*buoy*dz_rev(k)
          else
            up_w2(n,k+1) = up_w2(n,k)*ent_bw_EXP + aw*buoy/ent_bw * (1.-ent_bw_EXP)
          end if

          !--- compute vertical velocity
          if (up_w2(n,k+1) .gt. 0.) then
            up_w (n,k+1) = min(w_max, sqrt(up_w2(n,k+1)))
          else
            up_w (n,k+1) = 0.
          end if

          !--- if w^2 is less than zero then the updraft terminates
          if (up_w2(n,k+1) .le. 0.) then
            up_thv (n,k+1) = 0.
            up_thli(n,k+1) = 0.
            up_qq  (n,k+1) = 0.
            up_qt  (n,k+1) = 0.
            up_qc  (n,k+1) = 0.
            up_u   (n,k+1) = 0.
            up_v   (n,k+1) = 0.
            up_w2  (n,k+1) = 0.
            up_w   (n,k+1) = 0.
            up_a   (n,k+1) = 0.
            exit
          endif
        enddo  ! end loop of k
      enddo    ! end loop of n

!     !print out values
!     do n=1,nx
!     do k=1,kx
!       !print*,n,k,up_w2(n,k),up_w(n,k)
!       print*,n,k,'w,w2,u,thv',up_w(n,k),up_w2(n,k),up_u(n,k),up_thv(n,k)
!     enddo
!     print*,'------------'
!     enddo

!----------------------------------------------
!  filer moist mass flux if moist convection is handled by other schemes
!----------------------------------------------
     !--- search moist updraft
     do n=1,nx
       if (any(up_qc(n,:) .gt. 0.)) then
         is_moist_updraft(n,i,j) = .true.
       end if
     enddo

     !--- if any moist mass flux is present, mass_flux tendencies will be set to zero,
     !      i.e. no mass flux effects because these effects will be treated in other schemes.
     if (filter_massflux .eq. "if_moist_allmf_off") then
       if (any(up_qc(:,:) .gt. 0.)) then
         up_a(:,:) = 0.
       end if

     !--- if any moist mass flux is present, mass_flux tendencies only include the contribution from dry mass fluxes,
     !      i.e. mass flux program only handle dry mass flux, while moist mass flux are handled by other schemes.
     else if (filter_massflux .eq. "if_moist_allmoist_off") then
       do n=1,nx
         if (any(up_qc(n,:) .gt. 0.)) then
           up_a(n,:) = 0.
         end if
       enddo

     !--- do not set any filter
     else if (filter_massflux .eq. "none") then
       n=1

     else
       !call error_mesg(' mass_flux_mod',  &
       !                ' unsupported filter_massflux value. It must be [if_moist_allmf_off] or [if_moist_allmoist_off]', &
       !                FATAL )

     end if  ! end if of filter_massflux

!------------------------------
! summation of all updrafts
!   note that the vertical indexing is reversed in sum_up_*,
!   in order to be consistent with the CM4 vertical indexing
!------------------------------
      do k=1,kxp
        kk=kxp-k+1
        do n=1,nx
          sum_up_a     (i,j,kk) = sum_up_a     (i,j,kk) + up_a(n,k)
          sum_up_aw    (i,j,kk) = sum_up_aw    (i,j,kk) + up_a(n,k)*up_w(n,k)
          sum_up_awu   (i,j,kk) = sum_up_awu   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_u   (n,k)
          sum_up_awv   (i,j,kk) = sum_up_awv   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_v   (n,k)
          sum_up_awq   (i,j,kk) = sum_up_awq   (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qq  (n,k)
          sum_up_awthv (i,j,kk) = sum_up_awthv (i,j,kk) + up_a(n,k)*up_w(n,k)*up_thv (n,k)
          sum_up_awthli(i,j,kk) = sum_up_awthli(i,j,kk) + up_a(n,k)*up_w(n,k)*up_thli(n,k)
          sum_up_awqt  (i,j,kk) = sum_up_awqt  (i,j,kk) + up_a(n,k)*up_w(n,k)*up_qt  (n,k)
          sum_up_aqt   (i,j,kk) = sum_up_aqt   (i,j,kk) + up_a(n,k)          *up_qt(n,k)
          sum_up_aqc   (i,j,kk) = sum_up_aqc   (i,j,kk) + up_a(n,k)          *up_qc(n,k)

          each_up_a       (n,i,j,kk) = up_a   (n,k)
          each_up_w       (n,i,j,kk) = up_w   (n,k)
          each_up_aw      (n,i,j,kk) = up_a   (n,k)*up_w(n,k)
          each_up_u       (n,i,j,kk) = up_u   (n,k)
          each_up_v       (n,i,j,kk) = up_v   (n,k)
          each_up_thv     (n,i,j,kk) = up_thv (n,k)
          each_up_thli    (n,i,j,kk) = up_thli(n,k)
          each_up_qt      (n,i,j,kk) = up_qt  (n,k)
          each_up_qc      (n,i,j,kk) = up_qc  (n,k)
          each_up_massflux(n,i,j,kk) = up_rho (i,j,kk) * up_a(n,k)*up_w(n,k)
          each_up_awu     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_u   (n,k)
          each_up_awv     (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_v   (n,k)
          each_up_awthv   (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thv (n,k)
          each_up_awthli  (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_thli(n,k)
          each_up_awqt    (n,i,j,kk) = up_a(n,k)*up_w(n,k)*up_qt  (n,k)

        enddo  ! end loop of n
      enddo    ! end loop of k

      ! compute averaged vertical velocity of updradts
      do k=1,kxp
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aw (i,j,k) > 0.) then
          avg_up_w    (i,j,k) = sum_up_aw   (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_w    (i,j,k) = 0.
        endif
      enddo  

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqt (i,j,k) > 0.) then
          avg_up_qt    (i,j,k) = sum_up_aqt  (i,j,k) / sum_up_a (i,j,k)
        else
          avg_up_qt    (i,j,k) = 0.
        endif
      enddo

      ! compute in-cloud averaged cloud condensed water (liq+ice)
      do k=1,kx
        if (sum_up_a(i,j,k) > 0. .and. sum_up_aqc (i,j,k) > 0.) then
          avg_up_qc    (i,j,k) = sum_up_aqc  (i,j,k) / sum_up_a (i,j,k)
          is_moist_massflux(i,j)   = 1.
        else
          avg_up_qc    (i,j,k) = 0.
        endif
      enddo

      ! get updraft mass flux, air density * updraft area * vertical velocity
      do k=1,kxp
        sum_up_massflux(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k)
      enddo

      if (any(sum_up_massflux(i,j,:) .gt. 0.)) then
        is_mass_flux(i,j) = 1. 
      else
        is_mass_flux(i,j) = 0.
      end if

 
  !i=1
  !j=1
!  do n=1,nx
!    print*,'-------------------'
!  do k=25,kx
!    print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
!  enddo
!  enddo
     
!------------------------------
!  compute tendencies
!    change option_solver in namelist to decide which solver (currently "explicit" and "implicit")
!------------------------------

      if (is_mass_flux(i,j).eq.1.) then  ! there is mass flux

        !--- compute tendency of zonal wind, uu
        varname = "uu" 
        call mass_flux_tendencies (option_solver, dt, &
                                   rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   uu, sum_up_awu, udt_mf, w1_u1, varname)
  
        !--- compute tendency of meridional wind, vv
        varname = "vv" 
        call mass_flux_tendencies (option_solver, dt,  &
                                   rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   vv, sum_up_awv, vdt_mf, w1_v1, varname)
  
        !--- compute tendency of total water mixing ratio, qt 
        varname = "qt" 
        call mass_flux_tendencies (option_solver, dt, &
                                   rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qt, sum_up_awqt, qtdt_mf, w1_qt1, varname)
  
        !--- compute tendency of specific humidity, qq
        varname = "qq" 
        call mass_flux_tendencies (option_solver, dt, &
                                   rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   qq, sum_up_awq, qdt_mf, w1_q1, varname)
  
        !varname = "" 
        !call mass_flux_tendencies (option_solver, dt, &
        !                           up_z, rho_full, up_rho, sum_up_aw, &
        !                           thv, sum_up_awthv, thvdt_mf, w1_thv1, varname)
  
        !--- compute tendency of ice-liquid water potential temperature, thli
        varname = "thli" 
        call mass_flux_tendencies (option_solver, dt, &
                                   rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                   thli, sum_up_awthli, thlidt_mf, w1_thli1, varname)
  
        !--- compute temperature tendency tdt_mf. Because thli_env = theta_env. Convert tdt from theta_env
        tdt_mf(:,:,:) = thlidt_mf(:,:,:)/ape(:,:,:)

      end if ! end if of is_mass_flux

    end if ! end of b_star > 0.

  enddo    ! end loop of j
  enddo    ! end loop of i

!------------------------------
! write out to history files
!------------------------------

!!------- zonal wind (units: m/s) at full level -------
!  if ( id_uu > 0) then
!    used = send_data (id_uu, uu, Time_next, is, js, 1 )
!  endif
!
!!------- meridional wind (units: m/s) at full level -------
!  if ( id_vv > 0) then
!    used = send_data (id_vv, vv, Time_next, is, js, 1 )
!  endif
!
!!------- temperature (units: K) at full level -------
!  if ( id_tt > 0) then
!    used = send_data (id_tt, tt, Time_next, is, js, 1 )
!  endif
!
!!------- speficic humidity (units: kg/kg) at full level -------
!  if ( id_qq > 0) then
!    used = send_data (id_qq, qq, Time_next, is, js, 1 )
!  endif
!
!!------- averaged vertical velocity (units: m/s) at half level -------
!  if ( id_up_w > 0) then
!    used = send_data (id_up_w, avg_up_w, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area (units: none) at half level -------
!  if ( id_up_a > 0) then
!    used = send_data (id_up_a, sum_up_a, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area*w (units: m/s) at half level -------
!  if ( id_up_aw > 0) then
!    used = send_data (id_up_aw, sum_up_aw, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area*w*u (units: m2/s2) at half level -------
!  if ( id_up_awu > 0) then
!    used = send_data (id_up_awu, sum_up_awu, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area*w*v (units: m2/s2) at half level -------
!  if ( id_up_awv > 0) then
!    used = send_data (id_up_awv, sum_up_awv, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area*w*theta_v (units: K m/s) at half level -------
!  if ( id_up_awthv > 0) then
!    used = send_data (id_up_awthv, sum_up_awthv, Time_next, is, js, 1 )
!  endif
!
!!------- updraft area*w*qt (units: kg/kg m/s) at half level -------
!  if ( id_up_awqt > 0) then
!    used = send_data (id_up_awqt, sum_up_awqt, Time_next, is, js, 1 )
!  endif
!
!!------- updraft mass flux (units: kg/m2/s) at half level -------
!  if ( id_up_massflux > 0) then
!    used = send_data (id_up_massflux, sum_up_massflux, Time_next, is, js, 1 )
!  endif
!
!!------- u tendency from mass flux (units: m/s2) at full level -------
!  if ( id_udt_mf > 0) then
!    used = send_data (id_udt_mf, udt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- v tendency from mass flux (units: m/s2) at full level -------
!  if ( id_vdt_mf > 0) then
!    used = send_data (id_vdt_mf, vdt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- t tendency from mass flux (units: K/s) at full level -------
!  if ( id_tdt_mf > 0) then
!    used = send_data (id_tdt_mf, tdt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- q tendency from mass flux (units: kg/kg/s) at full level -------
!  if ( id_qdt_mf > 0) then
!    used = send_data (id_qdt_mf, qdt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- thv tendency from mass flux (units: K/s) at full level -------
!  if ( id_thvdt_mf > 0) then
!    used = send_data (id_thvdt_mf, thvdt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- thli tendency from mass flux (units: K/s) at full level -------
!  if ( id_thlidt_mf > 0) then
!    used = send_data (id_thlidt_mf, thlidt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
!  if ( id_qtdt_mf > 0) then
!    used = send_data (id_qtdt_mf, qtdt_mf, Time_next, is, js, 1 )
!  endif
!
!!------- w'thli' from mass flux (units: kg/kg/s) at half level -------
!  if ( id_w1_thli1_mf > 0) then
!    used = send_data (id_w1_thli1_mf, w1_thli1, Time_next, is, js, 1 )
!  endif
!
!!------- updraft averaged in-cloud total water (units: kg/kg) at half level -------
!  if ( id_up_qt > 0) then
!    used = send_data (id_up_qt, avg_up_qt, Time_next, is, js, 1 )
!  endif
!
!!------- updraft averaged in-cloud cloud water (units: kg/kg) at half level -------
!  if ( id_up_qc > 0) then
!    used = send_data (id_up_qc, avg_up_qc, Time_next, is, js, 1 )
!  endif
!
!!------- whether moist mass flux is present --- 
!  if ( id_moist_massflux > 0) then
!    used = send_data (id_moist_massflux, is_moist_massflux, Time_next, is, js)
!  endif
!
!!------- whether moist mass flux is present --- 
!  if ( id_is_massflux > 0) then
!    used = send_data (id_is_massflux, is_mass_flux, Time_next, is, js)
!  endif

!------------------------------
! write out profiles into the log file, fms.out
!------------------------------
  !--- write out profiles that have issues
  if (do_writeout_profile) then
    do i=1,ix
    do j=1,jx
      tt1 = maxval(abs(tdt_mf(i,j,:)))*86400.
      !if (tt1.gt.2000.) then   ! if tdt_mf > 2000 K/day
      if (tt1.gt.0.) then   ! if tdt_mf > 2000 K/day
        write(6,*)    '-----------------------------'
        write(6,*)    '  Fortran format' 
        write(6,*)    '-----------------------------'
        write(6,*)    '' 
        !write(6,*)    'Time_next,days,seconds'
        !write(6,*)    Time_next%days, Time_next%seconds   ! compiler error when I want to write Time_next
        write(6,*)    'i,j,',i,j
        write(6,*)    'tdt_mf,',tdt_mf(i,j,:)*86400.
        write(6,*)    'is_mass_flux',is_mass_flux(i,j)
        write(6,*)    'is_moist_updraft',is_moist_updraft(:,i,j)
        write(6,*)    'sum_up_massflux,',sum_up_massflux(i,j,:)
        write(6,*)    'w1_thli1', w1_thli1(i,j,:)
        write(6,*)    ''
        write(6,3001) 'data p_half/',p_half(i,j,:)
        write(6,3001) 'data z_half/',z_half(i,j,:)
        write(6,3001) 'data p_full/',p_full(i,j,:)
        write(6,3001) 'data z_full/',z_full(i,j,:)
        write(6,3000) 'data u_star/',u_star(i,j)
        write(6,3003) 'data b_star/',b_star(i,j)
        write(6,3003) 'data q_star/',q_star(i,j)
        write(6,3000) 'data z_pbl/' ,z_pbl(i,j)
        write(6,3001) 'data uu/'    ,uu(i,j,:)
        write(6,3001) 'data vv/'    ,vv(i,j,:)
        write(6,3001) 'data tt/'    ,tt(i,j,:)
        write(6,3002) 'data qq/'    ,qq(i,j,:)
        write(6,*)    ''
        write(6,*)    '-----------------------------'
        write(6,*)    '  NCL format' 
        write(6,*)    '-----------------------------'
        write(6,3001) 'p_half = (/',p_half(i,j,:)
        write(6,3001) 'z_half = (/',z_half(i,j,:)
        write(6,3001) 'p_full = (/',p_full(i,j,:)
        write(6,3001) 'z_full = (/',z_full(i,j,:)
        write(6,3000) 'z_pbl  = (/',z_pbl(i,j)
        write(6,3001) 'uu = (/'    ,uu(i,j,:)
        write(6,3001) 'vv = (/'    ,vv(i,j,:)
        write(6,3001) 'tt = (/'    ,tt(i,j,:)
        write(6,3002) 'qq = (/'    ,qq(i,j,:)
        write(6,3001) 'sum_up_massflux = (/'    ,sum_up_massflux(i,j,:)
        write(6,3001) 'avg_up_w = (/'    ,avg_up_w(i,j,:)
        write(6,3002) 'w1_thli1 = (/'    ,w1_thli1(i,j,:)
        write(6,3002) 'tdt_mf = (/'    ,tdt_mf(i,j,:)
        write(6,*)    ''
        write(6,*)    '-----------------------------'
        write(6,*)    '  Some vi commands' 
        write(6,*)    '-----------------------------'
        write(6,*)    'remove the space at the beginning        : [1,$s/^ */  /g]'
        write(6,*)    'add "/)" at the end                      : [1,$s/$/\/)/g]'
        write(6,*)    ''
        !write(6,3001) ' = (/'    ,(i,j,:)

        !call error_mesg(' mass_flux_mod',' end do_writeout_profile: stop', FATAL )
      endif  ! end if of tt1
    enddo
    enddo
  end if  ! end if of do_writeout_profile

!**********************************************************
!**********************************************************
!****   check part   **************************************
!**********************************************************
!**********************************************************

  if ( do_printouts ) then

      !  write out to the log file, fms.out
       write(6,*) 'Tend_mf tendencies'
       write(6,*) ''
      !i=is
      !j=js
      i=11
      j=5
      write(6,*) 'i,j,tt',tt(i,j,:)
      write(6,*) 'i,j,qq',qq(i,j,:)

       write(6,*) '------------------------------------'
       write(6,*) 'i,j,u*,b*,q*,z_pbl',i,j,u_star(i,j),b_star(i,j),q_star(i,j),z_pbl(i,j)
       write(6,*) 'i,j,u*',i,j,u_star(i,j)
       write(6,*) 'i,j,b*',i,j,b_star(i,j)
       write(6,*) 'i,j,q*',i,j,q_star(i,j)
       write(6,*) 'i,j,z_pbl',i,j,z_pbl(i,j)
       write(6,*) '------------------------------------'
      do kk=1,kxp
         write(6,*) 'kk,z',kk,z_half(i,j,kk)
         write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
         write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,kk)
         write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,kk)
         write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,kk)
         write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,kk)
         write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,kk)
         write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

      do kk=1,kx
         write(6,*) 'kk,z',kk,z_full(i,j,kk)
         write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,kk)
         write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,kk)
         write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,kk)
         write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,kk)
         write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,kk)
         write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,kk)
         write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,kk)
         write(6,*) '------------------------------------'
      enddo

    !call error_mesg(' mass_flux_mod',' end do_mass_flux: stop', FATAL )

  endif  ! end if of do_printouts

!------------------
! printout 
!------------------
do_check_printouts = ""
!do_check_printouts(1) = "up_qt_qc"
!do_check_printouts(2) = "qtdt_mf"
!do_check_printouts(1) = "sum_up"
!do_check_printouts(6) = "each_up"
!do_check_printouts(2) = "sum_up"
!do_check_printouts(3) = "dt_mf"
!do_check_printouts(4) = "w1_phi1"
!do_check_printouts(5) = "is_mass_flux"
!do_check_printouts = ""

kk=22  ! smallest k index
i=is  ! i index
j=js  ! j index

do ii1=1,10
  !-----------
  if (do_check_printouts(ii1).eq."is_mass_flux") then
    print*,''
    print*,'================================'
    print*,'is_mass_flux',is_mass_flux(i,j)
    print*,'is_moist_updraft',is_moist_updraft(:,i,j)
  endif

  !-----------
  if (do_check_printouts(ii1).eq."up_qt_qc") then
    print*,''
    print*,'================================'
    ! print out qt,qc
    do n=1,nx
      print*,'----- updraft ',n,' -----'
      do k=kk,kx
        print*,'n,k,qt,qc',n,k,each_up_qt(n,1,1,k), each_up_qc(n,1,1,k)
      enddo
    enddo
  
    !print*,'**********************'
    !print*,'base RH',rh_flag111
    !print*,'is_moist_massflux',is_moist_massflux
    !print*,'avg_up_qc',avg_up_qc
  endif 

  !-----------
  if (do_check_printouts(ii1).eq."qtdt_mf") then
    print*,''
    print*,'================================'
    print*,'qtdt_mf',qtdt_mf
  endif

  !-----------
  if (do_check_printouts(ii1).eq."sum_up") then
    print*,''
    print*,'================================'
    do k=kk,kxp
       write(6,*) 'k,z',k,z_half(i,j,k)
       write(6,*) '   is_mass_flux ,   ', is_mass_flux(i,j)
       write(6,*) '   sum_up_a,        ', sum_up_a    (i,j,k)
       write(6,*) '   sum_up_aw,       ', sum_up_aw   (i,j,k)
       write(6,*) '   sum_up_awu,      ', sum_up_awu  (i,j,k)
       write(6,*) '   sum_up_awq,      ', sum_up_awq  (i,j,k)
       write(6,*) '   sum_up_awqt,     ', sum_up_awqt (i,j,k)
       write(6,*) '   sum_up_awthv,    ', sum_up_awthv(i,j,k)
       write(6,*) '   sum_up_awthli,   ', sum_up_awthli(i,j,k)
       write(6,*) '   sum_up_massflux, ', sum_up_massflux(i,j,k)
       write(6,*) '   w1_thli1,        ', w1_thli1(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."dt_mf") then
    print*,''
    print*,'================================'
    do k=kk,kx
       write(6,*) 'k,z',k,z_full(i,j,k)
       write(6,*) '   udt_mf , Tend_mf%utnd   ',  udt_mf(i,j,k)
       write(6,*) '   vdt_mf , Tend_mf%vtnd   ',  vdt_mf(i,j,k)
       write(6,*) '   tdt_mf , Tend_mf%ttnd   ',  tdt_mf(i,j,k)
      ! write(6,*) ' thvdt_mf , Tend_mf%thvtnd ',thvdt_mf(i,j,k)
       write(6,*) ' thlidt_mf, Tend_mf%thlitnd ',thlidt_mf(i,j,k)
       write(6,*) '   qdt_mf , Tend_mf%qtnd   ',  qdt_mf(i,j,k)
       write(6,*) '  qtdt_mf , Tend_mf%qttnd  ', qtdt_mf(i,j,k)
       write(6,*) '------------------------------------'
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."each_up") then
    print*,''
    print*,'================================'
    do n=1,nx
      print*,''
      !print*,'----- updraft ',n,' -----'
      print*,'***************************'
      print*,'*****   updraft ',n,' *****'
      print*,'***************************'
      !do k=1,kxp
      do k=kk,kxp
         write(6,*) 'n,k,z',n,k,z_half(i,j,k)
         write(6,*) '   ent              ', ent(n,k)
         write(6,*) '   each_up_thli     ', each_up_thli(n,i,j,k)
         write(6,*) '   each_up_qt       ', each_up_qt  (n,i,j,k)
         write(6,*) '   each_up_qc       ', each_up_qc  (n,i,j,k)
         write(6,*) '------------------------------------'
      enddo
    enddo
  endif

  !-----------
  if (do_check_printouts(ii1).eq."w1_phi1") then
    print*,''
    print*,'================================'
      do k=kk,kxp
         write(6,*) 'k,z',k,z_half(i,j,k)
         write(6,*) '   w1_qt1           ', w1_qt1  (i,j,k)
         write(6,*) '   w1_q1            ', w1_q1  (i,j,k)
         write(6,*) '   w1_thli1            ', w1_thli1  (i,j,k)
         write(6,*) '------------------------------------'
      enddo
  endif
enddo  ! end do of ii1


!print*,'filter_massflux,',filter_massflux
!print*,'is_moist_updraft',is_moist_updraft
!print*,'is_moist_massflux',is_moist_massflux

!    print*,''
!    print*,'**********************'
!    print*,'base RH',rh_flag111
!    print*,'is_moist_massflux',is_moist_massflux
!    print*,'**********************'
!    print*,''

!------------------
!check mass/energy conservation
!------------------
!do_check_consrv = .true.
do_check_consrv = .false.

if (do_check_consrv) then
  !*** check qt ***
  tt1 = 0.
  tt2 = 0.

  i=1
  j=1 
  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + qt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (qtdt_mf(i,j,k)*dt+qt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_qt, new_qt, rho, dz',qt(i,j,k),(qtdt_mf(i,j,k)*dt+qt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  qtdt_mf',qtdt_mf(i,j,k)
  enddo

  print*,''
  print*,'option_solver: ',option_solver
  print*,'old qt (kg/m2), ',tt1
  print*,'new qt (kg/m2), ',tt2
  print*,'-----------------------------------------'

!*** check dry static energy ***
  tt1 = 0.
  tt2 = 0.

  do k=1,kx
    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
    print*,'i,j,k,',i,j,k
    print*,'  old_tt, new_tt, rho, dz',tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
    print*,'  tdt_mf',tdt_mf(i,j,k)
  enddo

  print*,''
  print*,'option_solver: ',option_solver
  print*,'column old energy, integral(rho*T*dz), ',tt1,', (times Cp to convert to J)'
  print*,'column new energy, integral(rho*T*dz), ',tt2,', (times Cp to convert to J)'
end if ! end if of do_check_consrv

!-----------------------------------------------------------
!  write out values of each updraft for NCL plotting use
!-----------------------------------------------------------

do_printout_ncl = .false.
!do_printout_ncl = .true.

if (do_printout_ncl) then
  print*,''
  print*,';---------------------------'
  print*,'; data source: '
  print*,';   ',data_source
  print*,';   dt=',dt
  print*,''
  print*,';    remove the space at the beginning	: [1,$s/^ */  /g]'
  print*,';    add "/)" at the end              	: [1,$s/$/\/)/g]'
  print*,';    add comma            		: [1,$s/   /,  /g]'
  print*,';    replace (/, with (/  		: [1,$s/\/,/\//g]'
  print*,';    replace ", ," to "," 		: [1,$s/, *,/,/g]'
  print*,';    replan then/) to then		: [1,$s/then\/)/then/g]'
  print*,';    replan end if/) to end if	: [1,$s/end if\/)/end if/g]'
  print*,';---------------------------'
  print*,''
  print*,';  wks_name = ""'
  print*,';  data_source = ""'
  print*,''
  
  write(*,2001) 'p_half = (/',p_half/100.
  write(*,2001) 'z_half = (/',z_half
  write(*,2001) 'p_full = (/',p_full/100.
  write(*,2001) 'z_full = (/',z_full
  write(*,1001) 'tt = (/',tt
  write(*,1001) 'thli = (/',thli
  write(*,1001) 'uu = (/',uu
  write(*,1001) 'vv = (/',vv
  write(*,1000) 'qq = (/',qq
  
  i=1
  j=1
  phi_half(1) = thli(i,j,1)
  do k=2,kx
    phi_half(k) = 0.5* (thli(i,j,k) + thli(i,j,k-1))
  enddo
  !write(*,1001) 'thli_env_half = (/',phi_half
  
!  do n=1,nx
!    write(*,1002) 'each_up_thv (',n-1,',:) = (/',each_up_thv(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1002) 'each_up_w (',n-1,',:) = (/',each_up_w(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_a (',n-1,',:) = (/',each_up_a(n,i,j,:)
!  enddo
!  
!  do n=1,nx
!    write(*,1003) 'each_up_massflux (',n-1,',:) = (/',each_up_massflux(n,i,j,:)
!  enddo
  
  !write(*,1000) 'sum_up_aw = (/',sum_up_aw
  !write(*,1000) 'sum_up_awthv = (/',sum_up_awthv
  write(*,1001) 'avg_up_w = (/',avg_up_w
  write(*,1000) 'sum_up_massflux = (/',sum_up_massflux
  write(*,1000) 'w1_thli1 = (/',w1_thli1
  write(*,1000) 'tdt_mf = (/',tdt_mf*86400.  ! K/day
end if ! end if of do_printout_ncl
!
!*** check sum and each updraft ***
!  i=1
!  j=1
!  do k=1,kxp
!    !print*,'k=',k,', sum_up_a,',sum_up_a(i,j,k),', each_up_a,',each_up_a(:,i,j,k)
!    !print*,'k=',k,', avg_up_w,',avg_up_w(i,j,k),', each_up_w,',each_up_w(:,i,j,k)
!    !print*,'k=',k,', sum_up_massflux,',sum_up_massflux(i,j,k),', each_up_massflux,',each_up_massflux(:,i,j,k)
!    print*,'k=',k,', sum_up_awthv,',sum_up_awthv(i,j,k),', each_up_awthv,',each_up_awthv(:,i,j,k)
!  enddo
!
1000 format (A25,40(E12.4,2X))
1001 format (A25,40(F8.3,2X))
1002 format (A25,I2,A10,40(F8.3,2X))
1003 format (A25,I2,A10,40(E12.4,2X))
2001 format (A25,40(F12.3,2X))
3000 format (A15,2X,F8.2)
3001 format (A15,2X,34(F10.3,2X,','))
3002 format (A15,2X,34(E12.4,2X,','))
3003 format (A15,2X,E12.4)

end subroutine mass_flux

!#######################################################################
! subroutine mass_flux_tendencies
!
!*************
! Purpose:
!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, <w'phi'>.
!
!*************
! Numerical discretation:
!
!   --------- 1   (top of the atmospheric model)
!     * 1    
!   --------- 2
!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!   --------- k-1
!     * k-1
!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!     * k               as well as subgrid mixing terms <w'phi'>
!   --------- k+1
!     * k+1
!   --------- ...
!     ....
!   --------- kx
!     * kx
!   --------- kxp=kx+1
!
!    SURFACE
!
!*************
! Equation:
!
!   The tendency equation is Eq (1) in Suselj et al. (2019b)
!
!         mean_phi(t+dt,k) - mean_phi(t,k)       w'phi'(t+dt/t,k+1) - w'phi'(t+dt/t,k)
!      -------------------------------------- = ---------------------------------------
!                      dt                                  dz
!
!   The treatment of <w'phi'> is Eq (7) in Suselj et al. (2019b)
!
!       mean_phi = uu, vv, tt, or qt
!       mean_w   = 0.
!
!       w'phi'(t/t+dt,k) = sum [ up_area * (up_phi-mean_phi) * (up_w-0) ]
!                        = sum [ up_area(t,k) * ( up_phi(t,k) - 0.5(mean_phi(t+dt/t,k-1)+mean_phi(t+dt/t,k) ) * up_w(t,k) ]
!
!*************
! Solver for time-difference scheme:
!
!   The updraft properties are treated explicitly, i.e. evaluated at time=t.
!   The grid-scale phi can be treated explicitly or implicitly (evaluated at time=t+dt). If done implicitly, it can be called
!   semi-implicit scheme, 
!      "In this solver, the large-scale horizontal advection and source terms are
!      treated explicitly (i.e., they are taken at the time, t), whereas the
!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!      subgrid fluxes are treated semi-implicitly." (Appendix A, Suselj et al., 2019b)
!
!   There are two solver options in this subroutine: "explicit" and "implicit". 
!     "Explicit" option evaluates all terms on the right-hand side of Eq (1) at time t, which are known. The only unknown term is
!     mean_phi(t+dt,k), which can be then solved directly.
!
!     "Implicit" evaluates all terms on the right-hand side of Eq (1) at time t except the mean_phi terms, which are evaluated at
!     t+dt. As a result, a set of linear euqations of unknown variables, mean_phi(t+dt,k), will show up. 
!     These equations are solved by the Tridiagonal matrix algorithm. Wiki has a detailed explanation about this algorithm: 
!     https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm 
!
!      --- Tridiagonal matrix algorithm ---
!      a,b,c - are coefficients on the LHS
!      d     - is initially RHS on the output becomes a solution vector
!
!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!      [ a1,  0, an, bn   ]   [xn]    [dn]
!
!      a1=0 and cn=0
!
!*************
! History:
!   2020/06/21 Copy from the subroutine OUTDATED_massflux_tendencies and modify
!
! Author:
!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!
!*************
! References:
!   Suselj et al. (2014, WAF):
!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!     https://doi.org/10.1175/WAF-D-14-00043.1
!   Suselj et al. (2019a, JAS):
!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!     https://doi.org/10.1175/JAS-D-18-0121.1
!   Suselj et al. (2019b, JAS):
!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!     https://doi.org/10.1175/JAS-D-18-0239.1
!
!-------------------------------------------------------------------- 

subroutine mass_flux_tendencies (option_solver, dt, &
                                 rho_half, rho_full, up_z, up_rho, sum_up_aw, &
                                 phi, sum_up_awphi, phidt_mf, w1_phi1, varname)

!---------------------------------------------------------------------
! Arguments (Intent in)
!    option_solver -  solver to obtain the tendency. 'explicit' or 'implicit' only
!    varname       -  variable name for reference 
!    dt            -  Time step               (sec)
!    rho_half      -  Air density at half levels (kg/m3)             , dimension (nlon, nlat, nlay+1)
!    rho_full      -  Air density at full levels   (kg/m3)           , dimension (nlon, nlat, nlay)
!    up_z          -  Updraft height levels   (meter)                , dimension (nlon, nlat, nlay+1)
!    up_rho        -  Air density at updraft levels (kg/m3)          , dimension (nlon, nlat, nlay+1)
!    sum_up_aw     - sum of the product of fractional area and vertical velocity for individual updraft
!                      i.e. a*w   (unit: m/s),                       , dimension (nlon, nlat, nlay+1)
!    phi           - a grid-mean variable (units_phi), e.g. u,v,t,q, , dimension (nlon, nlat, nlay)
!    sum_up_awphi  - sum of the product of fractional area, vertical velocity, and the variable phi for individual updraft
!                      i.e. a*w*phi (unit: m/s * units_phi)          , dimension (nlon, nlat, nlay+1)
!---------------------------------------------------------------------

  character*20, intent(in)            :: option_solver, varname
  real,  intent(in)                   :: dt

  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
    rho_full, phi
  real,  intent(in), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay+1)
    rho_half, up_z, up_rho, sum_up_aw, sum_up_awphi

!---------------------------------------------------------------------
! Arguments (Intent out)
!
!    phidt_mf  -  the tendency term of phi, i.e. dphi/dt,   dimension (nlon, nlat, nlay)
!    w1_phi1   -  the subgrid-scale flux  , i.e. w'phi'_bar
!---------------------------------------------------------------------
  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay)
    phidt_mf

  real,  intent(out), dimension(:,:,:) :: &   ! dimension (nlon, nlat, nlay+1)
    w1_phi1

!---------------------------------------------------------------------
!  (Intent local)
!---------------------------------------------------------------------

  !--- working variables
  real, dimension(size(up_z,1),size(up_z,2),size(up_z,3)) :: &  ! dimension (nlon, nlat, nlay+1) 
    rho_w1_phi1   ,  &    ! air density (kg/m3) * w'phi'
    sum_up_raw    ,  &    ! air density (kg/m3) * sum_up_aw            , 'r' represents 'rho'
    sum_up_rawphi ,  &    ! air density (kg/m3) * sum_up_awphi         , 'r' represents 'rho'
    sum_env_rawphi        ! air density (kg/m3) * sum_up_aw * mean_phi , 'r' represents 'rho'

  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: &    ! dimension (nlon, nlat, nlay) 
    env_rho               ! the air density between two adjacent updraft levels (kg/m3)

  real :: phidt_negative_max

  !--- working variables that the vertical indexing are reversed, i.e. k=1 becomes the lowermost level
  real, dimension(size(phi,3)) ::    &      ! dimension (nlay)
        phi_rev, dz_rev, rho_rev, dt_rhodz  !   k=1 is the lowermost level

  real, dimension(size(phi,3)+1) ::    &    ! dimension (nlay)
        sum_up_raw_rev, sum_up_rawphi_rev

  !--- variables for the tridiag solver
  real, dimension(size(phi,3)) :: &  ! dimension (nlay)
        a, b, c, d                   ! arrays for the tridiag solver

  !--- index variables 
  integer i,j,k,kk,n
  integer ix,jx,kx,nx,kxp,kxm

  !--- variables for check
  logical do_check_lhs_rhs
  real, dimension(size(phi,1),size(phi,2),size(phi,3)) :: & 
    phi_new
  real lhs, rhs

!---------------------------

!--- set dimensions
  ix  = size( phi, 1 )
  jx  = size( phi, 2 )
  kx  = size( phi, 3 )
  kxp = kx + 1
  kxm = kx - 1

!--- initialize output variables
  phidt_mf = 0.
  w1_phi1  = 0.

!--- initialize work variables 
  sum_up_raw   (:,:,:) = up_rho(:,:,:) * sum_up_aw   (:,:,:)
  sum_up_rawphi(:,:,:) = up_rho(:,:,:) * sum_up_awphi(:,:,:)

  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring
  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
  sum_up_raw   (:,:,kxp) = 0.
  sum_up_rawphi(:,:,kxp) = 0.

!--- set env_rho
  if (option_updraft_level.eq."full") then
    env_rho(:,:,1:kx) = rho_half(:,:,2:kxp)
  else
    env_rho(:,:,1:kx) = rho_full(:,:,1:kx)
  endif

!print*,'option_updraft_level= ',option_updraft_level
!print*,'z_full',z_full
!print*,'z_half',z_half
!print*,'up_z',up_z
!print*,'rho_full',rho_full
!print*,'rho_half',rho_half
!print*,'up_rho',up_rho
!print*,'env_rho',env_rho
!stop

!-------------------
! Explicit solver
!-------------------
  if (option_solver .eq. "explicit") then

    !--- environmental flux, rho * a * w * mean_phi_at_half_levels
    sum_env_rawphi = 0.
    do i=1,ix
    do j=1,jx
    do k=2,kx
      if (option_env_half.eq."upwind") then
        sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
      else
        sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * 0.5*(phi(i,j,k-1)+phi(i,j,k))
      endif

      if (option_updraft_level.eq."full") then
        sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * phi(i,j,k)
      endif

    enddo
    enddo
    enddo

    !print*,'sum_up_rawphi',sum_up_rawphi
    !print*,'sum_env_rawphi',sum_env_rawphi

    !--- compute the subgrid mixing, updraft minus environment
    rho_w1_phi1 = 0.
    rho_w1_phi1(:,:,1:kx) = sum_up_rawphi(:,:,1:kx) - sum_env_rawphi(:,:,1:kx)  ! no w'phi' at the surface (k=kx+1)

    w1_phi1(:,:,1:kx) = rho_w1_phi1(:,:,1:kx) / up_rho(:,:,1:kx) 
!
    !--- compute dphi/dt
    do i=1,ix
    do j=1,jx
    do k=kx,1,-1
      phidt_mf(i,j,k) = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                                            / (up_z(i,j,k) - up_z(i,j,k+1))

      !***************
      !***************
      !***************
      !***************
      ! NEED TO FIX. Need to think about how to avoid negative tracer concentration
      !***************
      !***************
      !***************
      !***************
      !--- compute the most negative dphi/dt so that phi isn't less than zero (e.g. total water specific humidity must be positive)
!      if (varname.eq."qt" .or. varname.eq."thli") then
!        phidt_negative_max = -phi(i,j,k)/dt
!
!        !--- if phidt_mf < phidt_negative_max, modity phidt_mf & rho_w1_phi1 at the top 
!        if (phidt_mf(i,j,k) .le. phidt_negative_max) then
!          phidt_mf(i,j,k) = phidt_negative_max
!  
!          !print*,'-----  ',varname,'-----'
!          !print*,'k,rho_w1_phi1(i,j,k),old',k,rho_w1_phi1(i,j,k)
!          rho_w1_phi1(i,j,k) = -phidt_mf(i,j,k)*rho_env(i,j,k)*(up_z(i,j,k) - up_z(i,j,k+1)) & 
!                              + rho_w1_phi1(i,j,k+1)
!          !print*,'k,rho_w1_phi1(i,j,k),new',k,rho_w1_phi1(i,j,k)
!        end if  ! end if of phidt_mf
!      endif     ! end if of varaname
    enddo
    enddo
    enddo
    
  endif  ! end if of option_solver="explicit"

!-------------------
! Implicit solver
!-------------------
if (option_solver .eq. "implicit") then

  do i=1,ix
  do j=1,jx

    !--- reverse variables so that the vertical index counting from the surface
    !    upward, i.e. k=1 is the lowermost model level
    do k=1,kx
      kk=kx-k+1
      phi_rev (kk) = phi(i,j,k)
      dz_rev  (kk) = up_z(i,j,k) - up_z(i,j,k+1)
      rho_rev (kk) = env_rho(i,j,k)
      dt_rhodz(kk) = dt / rho_rev(kk) / dz_rev(kk)
    enddo

    do k=1,kxp
      kk=kxp-k+1
      sum_up_raw_rev   (kk) = sum_up_raw   (i,j,k)
      sum_up_rawphi_rev(kk) = sum_up_rawphi(i,j,k)
    enddo

    !-----------------------------------
    ! set tridiag matrix coefficients: a,b,c, 
    !   which are the same for the all variables such as uu,vv,tt,qq,etc.
    !-----------------------------------

    !--- the lowermost level of the model
    k=1
    a(1) = 0.
    b(1) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw_rev(k+1)-sum_up_raw_rev(k))
    c(1) =    - 0.5 * dt_rhodz(k) *  sum_up_raw_rev(k+1)

    !--- other levels 
    do k=2,kx-1
      a(k) = dt_rhodz(k)      * 0.5 *  sum_up_raw_rev(k)
      b(k) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw_rev(k+1)-sum_up_raw_rev(k))
      c(k) =    - dt_rhodz(k) * 0.5 *  sum_up_raw_rev(k+1)
    enddo

    !--- the uppermost level of the model
    a(kx) = 0.
    b(kx) = 1.
    c(kx) = 0.

    !-----------------------
    ! compute tendency
    !-----------------------
    d = 0. ! initialze working array

    k=1
    d(k) = phi_rev(k) - dt_rhodz(k)*( sum_up_rawphi_rev(k+1)-sum_up_rawphi_rev(k) )

    do k=2,kx-1
      d(k) = phi_rev(k) - dt_rhodz(k)*( sum_up_rawphi_rev(k+1)-sum_up_rawphi_rev(k) )  
    enddo

    d(kx) = phi_rev(kx)

    ! call tridiag solver, d becomes the solution array
    call tridiag(kx,a,b,c,d)

    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
    do k=1,kx
      kk=kx-k+1
      phidt_mf (i,j,kk) = (d(k) - phi_rev(k))/dt
    enddo

    enddo  ! end do of j
  enddo    ! end do of i

  !--- compute w'phi' term
  phi_new    (:,:,:) = phi   (:,:,:) + phidt_mf(:,:,:)*dt

  ! environment
  sum_env_rawphi = 0.
  do i=1,ix
  do j=1,jx
  do k=2,kx
    sum_env_rawphi(i,j,k) = up_rho(i,j,k) * sum_up_aw(i,j,k) * 0.5*(phi_new(i,j,k)+phi_new(i,j,k-1))
  enddo
  enddo
  enddo

  ! updraft minus environment
  rho_w1_phi1(:,:,1:kx) = sum_up_rawphi(:,:,1:kx) - sum_env_rawphi(:,:,1:kx)

  !--- compute w'phi'
  w1_phi1(:,:,1:kx) = rho_w1_phi1(:,:,1:kx) / up_rho(:,:,1:kx) 

end if  ! end if of option_solver = "implicit"

!**********************************************************
!**********************************************************
!****   check part   ******
!**********************************************************
!**********************************************************

do_check_lhs_rhs = .false.
!do_check_lhs_rhs = .true.

!-----------------------------------
! check part - flux divergence calculation
!   check whether the lhs, dphi/dt, equals to the rhs, -1/rho * d/dz(rho*w'phi')
!-----------------------------------
if (do_check_lhs_rhs) then

  if (varname.eq."qt") then
  ! compute left-hand side, dphi/dt, and right-hand side, 1/rho * d/dz (w'phi')
  do i=1,ix
  do j=1,jx
  do k=1,kx
    lhs = phidt_mf(i,j,k)
    rhs = -1./env_rho(i,j,k) * (rho_w1_phi1(i,j,k)-rho_w1_phi1(i,j,k+1))  &
                              / (up_z(i,j,k) - up_z(i,j,k+1))

    print*,'---------  solver = ',option_solver,'  ---------'
    print*,'i,j,k,',i,j,k
    print*,'lhs (dphi/dt), rhs (-1/rho * d/dz (w1phi1), lhs-rhs'
    print*,'  ',lhs,rhs,lhs-rhs
  enddo
  enddo
  enddo

  end if

  !print*,'up_z',up_z
  !print*,'w1_phi1',w1_phi1

  !write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/up_rho(:,:,:)
  !write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf

end if ! end if of do_check_lhs_rhs

end subroutine mass_flux_tendencies

!#######################################################################

!subroutine compute_src_thli_qt_prec (dt, p, rho, dz, &
!                                     up_a, up_w, up_qc, water_frac, tau0, &
!                                     qt_src, thli_src, qc_src, qi_src, rr, ri)
!  !---------------------------------------
!  ! Description:
!  !   compute the source terms for ice-liquid water potential temperature and total water mixing ratio  
!  !
!  !   copy from the subroutine cmassflux_precip in WRF, written by Dr, Kay Suselj, 
!  !   and then modified by Yi-Hsuan Chen
!  !---------------------------------------
!
!  !--- input argument
!  real, intent(in)  :: &
!      dt,              &  ! time step, 				units: sec
!      p,               &  ! pressure, 				units: Pa
!      rho,             &  ! air density, 			units: kg/m3
!      dz,              &  ! delta_z, 				units: m 
!      up_a,            &  ! updraft area, 			units: fraction
!      up_w,            &  ! updraft vertical velocity, 		units: m/s
!      up_qc,           &  ! updraft cloud water content,	units: kg/kg
!      water_frac,      &  ! 
!      tau0                !
!
!  !--- output argument
!  real, intent(out) :: &
!      qt_src,          &  ! source term for total water mixing ratio, 			units: kg/kg/s
!      thli_src,        &  ! source term for ice-liquid water potential temperature,	units: K/s
!      qc_src,          &  ! source term for cloud liquid water, 			units: kg/kg/s
!      qi_src,          &  ! source term for cloud ice    water,				units: kg/kg/s
!      rr,              &  ! liquid precipitation rate, 					units: m/s
!      ri                  ! ice    precipitation rate, 					units: m/s
!
!  !--- local varialbes 
!  real, parameter ::        &
!      p00 = 1000.0E2,       & ! 1000 hPa
!      p00inv = 1./p00,      & ! 1/1000hPa 
!      hlv_cp = hlv/cp_air,  & ! L_l/cp, L_l is the latent heat of evaporation 
!      hlf_cp = hlf/cp_air,  & ! L_f/cp, L_l is the latent heat of fusion
!      g = grav                ! gravity acceleration, 9.8 m/s^2    
!
!  real ::       &
!      exn,      &  ! Exner function, (P/P0)^(Rd/cp)
!      hlvf_cp,  &  ! 
!      q0,       &  ! qc threshold of autoconversion, units: kg/kg
!      q0_liq,   &  ! 
!      q0_ice       !
!
!!----------------------------------
!
!! initialize output variables
!  qt_src = 0. 
!  thli_src = 0. 
!  qc_src = 0.    
!  qi_src = 0.   
!  rr = 0.  
!  ri = 0.
!
!  ! compute the threshold for autoconversion, q0
!  q0=water_frac*q0_liq+(1.-water_frac)*q0_ice
!
!  if (up_qc .gt. q0) then
!
!    ! compute Exner function, (P/P0)^(Rd/cp)     
!    exn=(p*p00inv)**kappa
!
!    ! compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
!    hlvf_cp = hlv_cp*water_frac + hlf_cp*(1.-water_frac)
!
!    ! source term for qt
!    qt_src=-(up_qc-q0)*(1.-exp(-dz/(up_w*tau0)))      
!
!    ! source term for theta_li
!    thli_src=-qt_src*hlvf_cp/exn
!
!    ! source term for qc, qi
!    qc_src=(up_qc-q0)/dt*(exp(-dt/tau0)-1.)*up_a    
!    qi_src=qc_src*(1.-water_frac)
!    qc_src=qc_src*water_frac
!
!    ! compute precipitation flux, m/s
!    rr=-rho*qc_src*up_a*dz/dens_h2o
!    ri=-rho*qi_src*up_a*dz/dens_h2o
!
!  end if
!
!end subroutine compute_src_thli_qt_prec
!
!!#######################################################################
!
subroutine compute_thv_qc (qt, thli, p, water_frac, &
                           thv, qq, qc, ql, qi,         &
                           qsat)
  !---------------------------------------
  ! Description:
  !   compute virtual potential temperature and cloud water specific humidity 
  !   based on ice-liquid water potential temperature and total water specific humidity
  !
  !   copy from the subroutine condensation_edmf in WRF, written by Dr, Kay Suselj, 
  !   and then modified by Yi-Hsuan Chen
  !---------------------------------------

  !--- input argument
  real, intent(in)  :: &
      qt,              &   ! total water specific humidity (vapor + cloud liquid + cloud ice), units: kg/kg
      thli,            &   ! ice-liquid water potential temperature  	                     , units: K
      p,               &   ! pressure                                       	             , units: Pa
      water_frac           ! cloud liquid water fraction                         	     , units: fraction

  real, intent(in), optional :: & 
      qsat                 ! optional: the saturation specific humidity can be an input      , units: kg/kg
                           !   This helps to debug in an offline code

  !--- output argument
  real, intent(out) :: &
      thv,             &   ! virtual potential temperature 	    , units: K
      qq,              &   ! specific humidity, units: kg/kg
      qc,              &   ! cloud water (liq+ice) specific humidity, units: kg/kg
      ql,              &   ! cloud liquid water specific humidity   , units: kg/kg
      qi                   ! cloud ice    water specific humidity   , units: kg/kg
 
  !--- local varialbes 
  real, parameter ::        &
      p00 = 1000.0E2,       & ! 1000 hPa
      p00inv = 1./p00,      & ! 1/1000hPa 
      g = grav,             & ! gravity acceleration, 9.8 m/s^2    
      rv_rd = rvgas/rdgas,  & ! rv/rd = 1.6
      hlv_cp = hlv/cp_air,  & ! hlv/cp, hlv is the latent heat of evaporation 
      hlf_cp = hlf/cp_air,  & ! hlf/cp, hlf is the latent heat of fusion
      niter = 50,           & ! number of iterations
      diff  = 1.e-4           ! minimum difference for iteration

  real ::         &
      t,          &    ! temperature (K)
      tv,         &    ! temperature (K)
      qs,         &    ! saturation vapor specific humidity (kg/kg)
      exn,        &    ! Exner function, (P/P0)^(Rd/cp)
      hlvf_cp,    &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_hlvf_cp, &    ! "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
      qc_old           ! 
   
  real :: tt1

  integer i
!------------------------------------

  !--- initialize return variables
  thv = 0.
  qc  = 0.
  qc  = 0.
  ql  = 0.
  qi  = 0.
  
 !--- compute Exner function, (P/P0)^(Rd/cp) 
  exn=(p*p00inv)**kappa  

  !--- iterate to get qc
  do i=1,niter

    !--- compute "(L_l*q_l + L_i*q_i) / cp" term in the formula of ice-liquid water potential temperature
    hlvf_cp = (hlv_cp*water_frac + hlf_cp*(1.-water_frac))
    qc_hlvf_cp = qc * hlvf_cp

    !--- compute temperature
    t  = exn*(thli+qc_hlvf_cp)     

    !--- compute saturation specific humidity
    if (present(qsat)) then
      qs = qsat
    else
      qs = qs_edmf(t,p,water_frac)   
    endif

    !--- compute qc, and qc_old
    qc_old = qc
    qc    = max(0.5*qc+0.5*(qt-qs),0.)
    if (abs(qc-qc_old)<diff) exit   ! compare previous qc and current qc values
  end do

  !--- get the final value of t, qs, qc, and thv
  qc_hlvf_cp = qc * hlvf_cp
  t = exn*(thli+qc_hlvf_cp)

  qq  = max(qt-qc,0.)    ! note that qq is very close to qs(t), but not exactly the same due to numerics
  ql  = qc * water_frac
  qi  = qc * (1.-water_frac)

  thv = (thli+qc_hlvf_cp/exn)*(1.+qt*(rv_rd-1.)-rv_rd*qc)  ! Kay's formula, but I don't understand why
  !tt1 = t*(qq*d608+1.0)/exn                                ! standard virtual potential temperature formula
  !print*,'thv_Kay,thv_d608,diff',thv,tt1,thv-tt1  ! the difference is very small

  !print*,'aa, thv= ',thv
  !print*,'aa, qc=  ',qc
  !print*,'thli,qt,p,',thli,qt,p,', thv,qc',thv,qc
  !print*,'-----------------'
  !print*,'t,p',t,p
  !print*,'thli,thv,',thli,thv
  !print*,'qt,qq,qc',qt,qq,qc

!  if (qc.gt.0.) then
!    ! write(6,*) '--------------------------'
!    !! write(6,*),'ggg1, thli,thv,qt',thli,thv,qt
!    ! write(6,*),'ggg1, thli,thv',thli,thv
!    ! write(6,*),'ggg2, qt,qc',qt,qc
!    qs = qs_edmf(t,p,water_frac)
!    ! write(6,*),'ggg3, qq,rh',qq,qq/qs*100.
!  end if

end subroutine compute_thv_qc

!#######################################################################

function qs_edmf(t,p,water_frac)
  real, intent(in)  :: &
      t, &
      p, &
      water_frac
  real qsat, qs_edmf
!  real :: &
!      esl, esi, es
!--------------------------
  !esl = 
  !esi = 

  !es = 
  !es = esl*water_frac + esi*(1.-water_frac)

  call compute_qs(t, p, qsat)

  qs_edmf = qsat

end function

!!#######################################################################
!! subroutine OUTDATED_massflux_tendencies
!!   ****  This subroutine is no longer used after June 20, 2020. ****
!!
!! Purpose:
!!   Compute the tendency terms of the grid-scale, mean variables due to subgrid vertical mixing, i.e. <w'phi'>
!!
!!   According to Appendix A in Suselj et al. (2019b): 
!!     "In this solver, the large-scale horizontal advection and source terms are
!!      treated explicitly (i.e., they are taken at the time, t), whereas the
!!      vertical advection term is treated implicitly (taken at time t+dt ) and the
!!      subgrid fluxes are treated semi-implicitly."
!!
!! Numerical discretation:
!!
!!   --------- 1   (top of the atmospheric model)
!!     * 1    
!!   --------- 2
!!     * 2          -->  grid-scale variables are at full levels,    e.g. uu,vv,tt,qq
!!   --------- k-1
!!     * k-1
!!   --------- k    -->  updraft variables are at half levels, i.e. sum_up_**_input
!!     * k               as well as subgrid mixing terms <w'phi'>
!!   --------- k+1
!!     * k+1
!!   --------- ...
!!     ....
!!   --------- kx
!!     * kx
!!   --------- kxp=kx+1
!!
!!    SURFACE
!!
!!=== Equation: Eq (7) in Suselj et al. (2019b)
!!
!!   mean_PHI = uu, vv, tt, or qt
!!   mean_w   = 0.
!!
!!   w'PHI'(t,k) = sum [ up_area * (up_PHI-mean_PHI) * (up_w-0) ]
!!               = sum [ up_area(t,k) * ( up_PHI(t,k) - 0.5(mean_PHI(t,k-1)+mean_PHI(t,k) ) * up_w(t,k) ]
!!
!!=== Equation: Eq (1) in Suselj et al. (2019b)
!!
!!   mean_PHI(k,t+dt) - mean_PHI(k,t+dt)      w'PHI'(t+dt,k+1) - w'PHI'(t+dt,k)
!!  -------------------------------------- = ---------------------------------------
!!                  dt                                  dz
!!
!!  To compute <w'PHI'>, mean_PHI are taken at time (t+dt) and up_* are taken at time (t)
!!
!!  These will result in a set of linear euqations of unknown variables, mean_PHI(t+dt,k), 
!!  and these equations are solved by the Tridiagonal matrix algorithm.
!!
!!
!! History:
!!   2020/05/17  Make the input sum_up_**_input variables have the same vertical indexing with the CM4, i.e. k=1 at the uppermost.
!!   2020/06/04  Make updraft fluxes at the surface to zero, to avoid updraft bringing energy/tracer from
!!               the surface to the atmosphere that will cause  additional energy/tracer adding to the atmosphere
!!   2020/06/07  Add check part
!!   2020/06/20  Stop updating this subroutine because it is replaced by another subroutine, mass_flux_tendencies
!!
!! Author:
!!   Yi-Hsuan Chen (yi-hsuan.chen@noaa.gov OR yihsuan@umich.edu)
!!
!! Notes:
!!   1. Solver, subroutine tridiag
!!      This program uses the "Tridiagonal matrix algorithm" to compute the tendency terms.
!!      Wiki has a detailed explanation about this algorithm: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm
!!
!!      a,b,c - are coefficients on the LHS
!!      d     - is initially RHS on the output becomes a solution vector
!!
!!      [ b1, c1,  0, cn   ]   [x1]    [d1]
!!      [ a2, b2, c2, 0    ] * [x2]  = [d2]
!!      [  0, a3, b3, cn-1 ]   [x3]    [d3]
!!      [ a1,  0, an, bn   ]   [xn]    [dn]
!!
!!      a1=0 and cn=0
!!
!! References:
!!   Suselj et al. (2014, WAF):
!!     "Implementation of a Stochastic Eddy-Diffusivity/Mass-Flux Parameterization into the Navy Global Environmental Model"
!!     https://doi.org/10.1175/WAF-D-14-00043.1
!!   Suselj et al. (2019a, JAS):
!!     "On the Factors Controlling the Development of Shallow Convection in Eddy-Diffusivity/Mass-Flux Models"
!!     https://doi.org/10.1175/JAS-D-18-0121.1
!!   Suselj et al. (2019b, JAS):
!!     "A Unified Eddy-Diffusivity/Mass-Flux Approach for Modeling Atmospheric Convection"
!!     https://doi.org/10.1175/JAS-D-18-0239.1
!!-----------------------
!
!subroutine OUTDATED_massflux_tendencies ( is, js, dt, time,                   &
!                                 p_half, p_full, z_half, z_full,     &
!                                 uu, vv, tt, qq,                     &
!                                 is_mass_flux,                       & 
!                                 sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!                                 sum_up_awthv_input, sum_up_awqt_input,  &
!                                 udt_mf, vdt_mf, tdt_mf, qdt_mf,     & 
!                                 thvdt_mf, qtdt_mf)
!
!!---------------------------------------------------------------------
!! Arguments (Intent in)
!!    dt           -  Time step               (sec)
!!    time         -  variables needed for netcdf diagnostics
!!    p_half       -  Pressure at half levels (Pa)    , dimension (nlon, nlat, nlay+1)
!!    p_full       -  Pressure at full levels (Pa)    , dimension (nlon, nlat, nlay)
!!    z_half       -  Height at half levels   (meter) , dimension (nlon, nlat, nlay+1)
!!    z_full       -  Height at full levels   (meter) , dimension (nlon, nlat, nlay)
!!    uu           -  zonal wind              (m/s)   , dimension (nlon, nlat, nlay)
!!    vv           -  meridional wind         (m/s)   , dimension (nlon, nlat, nlay)
!!    tt           -  Potential temperature   (K)     , dimension (nlon, nlat, nlay)
!!    qq           -  specific humidity       (kg/kg) , dimension (nlon, nlat, nlay)
!!
!!    is_mass_flux  - a logical array that indicates whether the updradts are present (True) or not (False)
!!                                                        dimension (nlon,nlat)
!!
!!    sum_up_aw_input     - sum of the product of fractional area and vertical velocity for individual updraft
!!                      i.e. a*w   (unit: m/s),           dimension (nlon, nlat, nlay+1)
!!    sum_up_awu_input    - sum of the product of fractional area, vertical velocity, and zonal wind for individual updraft
!!                      i.e. a*w*u (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awv_input    - sum of the product of fractional area, vertical velocity, and meridional wind for individual updraft
!!                      i.e. a*w*v (unit: m/s * m/s),     dimension (nlon, nlat, nlay+1)
!!    sum_up_awthv_input  - sum of the product of fractional area, vertical velocity, and virtual potential temp for individual updraft
!!                      i.e. a*w*theta_v (unit: m/s * K), dimension (nlon, nlat, nlay+1)
!!    sum_up_awqt_input   - sum of the product of fractional area, vertical velocity, and total specific humidity for individual updraft
!!                      i.e. a*w*qt (unit: m/s * kg/kg),  dimension (nlon, nlat, nlay+1)
!!
!! Note:
!!   1. All updraft variables are at half level, i.e. the number of levels is nlay+1
!!---------------------------------
!
!  integer, intent(in)                 :: is, js
!  real,  intent(in)                   :: dt
!  type(time_type),      intent(in)    :: time
!  real,  intent(in), dimension(:,:,:) :: p_full, z_full   ! dimension (nlon, nlat, nlay)
!  real,  intent(in), dimension(:,:,:) :: p_half, z_half   ! dimension (nlon, nlat, nlay+1)
!  real,  intent(in), dimension(:,:,:) :: uu, vv, tt, qq   ! dimension (nlon, nlat, nlay)
!
!  real,  intent(in), dimension(:,:,:) ::             &    ! dimension (nlon, nlat, nlay+1)
!         sum_up_aw_input, sum_up_awu_input, sum_up_awv_input,          &
!         sum_up_awthv_input, sum_up_awqt_input
!
!  logical, intent(in), dimension(:,:) :: is_mass_flux     ! dimension (nlon, nlat)
!
!!---------------------------------------------------------------------
!! Arguments (Intent out)
!!   udt_mf   - zonal wind tendency                                 (m/s/s)  , i.e. du/dt
!!   vdt_mf   - meridional wind tendency                            (m/s/s)  , i.e. dv/dt
!!   tdt_mf   - temperature tendency                                (K/s)    , i.e. dt/dt
!!   qdt_mf   - specific humidity tendency                          (kg/kg/s), i.e. dq/dt
!!   thvdt_mf - virtual potential temperature tendency              (K/s)    , i.e. dtheta_v/dt
!!   qtdt_mf  - total (vapor+condensed) specific humidity tendency  (kg/kg/s), i.e. dqt/dt
!!
!! Note:
!!   1. The vertical indexing of d*_dt terms is the same as the input variables such as uu,vv,tt,etc.
!!        i.e. k=1 is the uppermost level
!!---------------------------------------------------------------------
!
!  real, intent(out), dimension(:,:,:) :: &  ! dimension (nlon, nlat, nlay)
!      udt_mf, vdt_mf, tdt_mf, qdt_mf,    &
!      thvdt_mf, qtdt_mf
!
!!---------------------------------------------------------------------
!!  (Intent local)
!!---------------------------------------------------------------------
!
!  !--- updraft variables for work
!  !      times the input sum_up_* by air density (rho, abbreviated as 'r')
!  !      note that the vertical indexing is reversed from sum_up_*_input. The new indexing is counted upward from the surface,
!  !      i.e. k=1 is the lowermost model level
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!         sum_up_raw, sum_up_rawu, sum_up_rawv,              &
!         sum_up_rawthv, sum_up_rawqt
!
!  !--- grid-mean variables for work
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        uu_rev, vv_rev, thv_rev,    &  ! reverse indexing so that they are counted from surface upward
!        qt_rev, dz_rev, rho_rev, dt_rhodz  !   i.e. k=1 is the lowermost level
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)) :: &  ! dimension (nlon,nlat,nlay)
!        qt,   & ! total specific humidity (vapor+condensed), (kg/kg)
!        tv,   & ! virtual temperature                        (K)
!        thv,  & ! virtual potential temperature              (K)
!        rho_full,  & ! air density at full levels                               (kg/m3)
!        ape     ! factor to compute potential temperature
!
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: &  ! dimension (nlon,nlat,nlay+1)
!        rho_half    ! air density at half levels (kg/m3)
!
!  real, dimension(size(uu,3)) ::    &  ! dimension (nlay)
!        thv_temp, tv_temp, qq_temp, ape_temp, tt_temp
!
!  !--- variables for the tridiag solver
!  real, dimension(size(uu,3)) :: &  ! dimension (nlay)
!        a, b, c, d                  ! arrays for the tridiag solver
!
!
!  !*** parameters ***
!  real, parameter :: &
!      p00 = 1000.0E2,     & ! 1000 hPa
!      p00inv = 1./p00,    & ! 1/1000hPa
!      g = grav              ! gravity acceleration
!
!  !*** index variables ***
!  integer i,j,k,kk,n
!  integer ix,jx,kx,nx,kxp,kxm,ism,jsm
!
!  !*** use for netCDF output ***
!  logical used
!
!  !*** variables for result checking ***
!  real tt1,tt2,tt3,tt4,tt5
!  real awphi_k, awphi_kp
!  real, dimension(size(uu,1),size(uu,2),size(uu,3)+1) :: sum_up_rawphi, sum_env_rawphi, w1phi1
!  real, dimension(size(uu,1),size(uu,2),size(uu,3))   :: phi, dphi_dt, phi_new
!  real, dimension(size(uu,3)) :: phi_rev, phi_d
!  character*5, phi_name
!  logical use_explicit_solver   ! use explicit solver to obtain tendency terms. For check use only
!
!!---------------------------------------------------------------
!
!!--- set dimensions
!  ix  = size( uu, 1 )
!  jx  = size( uu, 2 )
!  kx  = size( uu, 3 )
!  kxp = kx + 1
!  kxm = kx - 1
!  ism = is - 1
!  jsm = js - 1
!
!!--- compute virtual potential temperature, thv
!  ape(:,:,:)=(p_full(:,:,:)*p00inv)**(-kappa)
!  tv (:,:,:)=tt(:,:,:)*(qq(:,:,:)*d608+1.0)
!  thv(:,:,:)=tv(:,:,:)*ape(:,:,:)  
!  rho_full(:,:,:)=p_full(:,:,:)/rdgas/tv(:,:,:)
!
!!--- compute air density at full and half levels
!  do i=1,ix
!  do j=1,jx
!  do k=1,kx-1
!    rho_half(i,j,k+1) = 0.5 * (rho_full(i,j,k)+rho_full(i,j,k+1))
!  enddo
!  enddo
!  enddo
!  rho_half(:,:,1)    = rho_full(:,:,1)  
!  rho_half(:,:,kx+1) = rho_full(:,:,kx)
!
!!--- set updraft working variables, in which the vertical indexing is reversed 
!!      so that k=1 is at the lowermost model level
!  do i=1,ix
!  do j=1,jx
!  do k=1,kxp
!    kk=kxp-k+1
!    sum_up_raw   (i,j,kk) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,kk) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,kk) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,kk) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,kk) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo
!  enddo
!  enddo
!
!  !--- set the updraft flux at the surface to zero. Otherwise, updraft will bring 
!  !      energy/tracer from the surface to the atmosphere, making energy/mass not conserved.
!  !      (the updraft just redistribute energy/tracer in the atmosphere, not create)
!  sum_up_raw   (:,:,1) = 0.
!  sum_up_rawu  (:,:,1) = 0.
!  sum_up_rawv  (:,:,1) = 0.
!  sum_up_rawthv(:,:,1) = 0.
!  sum_up_rawqt (:,:,1) = 0.
!
!!--- initialize return and working variables 
!  udt_mf   = 0.
!  vdt_mf   = 0.
!  tdt_mf   = 0.
!  qdt_mf   = 0.
!  thvdt_mf = 0.
!  qtdt_mf  = 0.
!
!  qt(:,:,:) = qq(:,:,:)
!
!  a = 0.
!  b = 0.
!  c = 0.
!  d = 0.
!
!!----------------------
!! compute tendencies 
!!----------------------
!
!  !--- loop for each (i,j) point
!  do i=1,ix
!  do j=1,jx
!
!!------------------------
!! if there are updrafts
!!------------------------
!    if (is_mass_flux(i,j)) then
!
!    !--- reverse variables so that the vertical index counting from the surface
!    !    upward, i.e. k=1 is the lowermost model level
!    do k=1,kx
!      kk=kx-k+1
!      uu_rev  (kk) = uu (i,j,k)
!      vv_rev  (kk) = vv (i,j,k)
!      qt_rev  (kk) = qt (i,j,k)
!      thv_rev (kk) = thv(i,j,k)
!      dz_rev  (kk) = z_half(i,j,k) - z_half(i,j,k+1)
!      rho_rev (kk) = rho_full(i,j,k)
!      dt_rhodz(kk) = dt / rho_rev(kk) / dz_rev(kk)
!    enddo
!
!!-----------------------------------
!! set tridiag matrix coefficients: a,b,c, 
!!   which are the same for the all variables such as uu,vv,tt,qq,etc.
!!-----------------------------------
!
!    !--- the lowermost level of the model
!    k=1
!    a(1) = 0.
!    b(1) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!    c(1) =    - 0.5 * dt_rhodz(k) *  sum_up_raw(i,j,k+1)
!
!    !--- other levels 
!    do k=2,kx-1
!      a(k) = dt_rhodz(k)      * 0.5 *  sum_up_raw(i,j,k)
!      b(k) = 1. - 0.5 * dt_rhodz(k) * (sum_up_raw(i,j,k+1)-sum_up_raw(i,j,k))
!      c(k) =    - dt_rhodz(k) * 0.5 *  sum_up_raw(i,j,k+1)
!    enddo
!
!    !--- the uppermost level of the model
!    a(kx) = 0.
!    b(kx) = 1.
!    c(kx) = 0.
!
!!-----------------------
!! compute uu tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = uu_rev(k) - dt_rhodz(k)*( sum_up_rawu(i,j,k+1)-sum_up_rawu(i,j,k) )  
!    enddo
!
!    d(kx) = uu_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      udt_mf (i,j,kk) = (d(k) - uu_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute vv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = vv_rev(k) - dt_rhodz(k)*( sum_up_rawv(i,j,k+1)-sum_up_rawv(i,j,k) )
!    enddo
!
!    d(kx) = vv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      vdt_mf (i,j,kk) = (d(k) - vv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute thv tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = thv_rev(k) - dt_rhodz(k)*( sum_up_rawthv(i,j,k+1)-sum_up_rawthv(i,j,k) )
!    enddo
!
!    d(kx) = thv_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      thvdt_mf (i,j,kk) = (d(k) - thv_rev(k))/dt
!    enddo
!
!!-----------------------
!! compute qt tendency
!!-----------------------
!    d = 0. ! initialze working array
!
!    k=1
!    d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!
!    do k=2,kx-1
!      d(k) = qt_rev(k) - dt_rhodz(k)*( sum_up_rawqt(i,j,k+1)-sum_up_rawqt(i,j,k) )
!    enddo
!
!    d(kx) = qt_rev(kx)
!
!    ! call tridiag solver, d becomes the solution array
!    call tridiag(kx,a,b,c,d)
!
!    ! compute du/dt on the original vertical indexes, i.e. counting from the top so k=1 is the uppermost level
!    do k=1,kx
!      kk=kx-k+1
!      qtdt_mf (i,j,kk) = (d(k) - qt_rev(k))/dt
!    enddo
!
!!----------------------
!! compute qq tendency
!!----------------------
!
!    ! Set to qtdt at this moment
!    qdt_mf(i,j,:) = qtdt_mf(i,j,:)
!
!!------------------------------------
!! compute tt tendency 
!!  based on thv and qt tendencies
!!------------------------------------
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!
!!------------------------
!! end if of is_mass_flux
!!------------------------
!    endif 
!
!
!!*********************
!!*********************
!!  check part
!!*********************
!!*********************
!
!!-------------------------------
!! check part - flux divergence
!!   check whether dphi/dt = -1/rho * d/dz(rho*w'phi') for the implicit solver
!!-------------------------------
!  !phi_name = "uu"
!  !phi_name = "vv"
!  phi_name = "thv"
!  !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi    (:,:,:) = uu   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi    (:,:,:) = vv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi    (:,:,:) = thv   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi    (:,:,:) = qt   (:,:,:) + dphi_dt(:,:,:)*dt
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  print*,'sum_up_awthv,',sum_up_awthv_input
!  print*,'sum_up_rawphi',sum_up_rawphi 
!!  print*,'sum_env_rawphi',sum_env_rawphi 
!!  print*,'sum_env_awphi',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!!  print*,'rho*w1phi1',w1phi1
!!  print*,'phi_name,',phi_name
!!  print*,'dphi_dt',dphi_dt
!!  print*,'thvdt_mf',thvdt_mf
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_implicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_implicit = (/',thvdt_mf
! 
!!-----------------------------------------
!! check part - use explicit solver to compute tendency
!!-----------------------------------------
!
!use_explicit_solver = .true.
!!use_explicit_solver = .false.
!if (use_explicit_solver) then
!
!    !phi_name = "uu"
!    !phi_name = "vv"
!    phi_name = "thv"
!    !phi_name = "qt"
!
!  ! updraft
!  do k=1,kxp
!    sum_up_raw   (i,j,k) = rho_half(i,j,k) * sum_up_aw_input   (i,j,k)
!    sum_up_rawu  (i,j,k) = rho_half(i,j,k) * sum_up_awu_input  (i,j,k)
!    sum_up_rawv  (i,j,k) = rho_half(i,j,k) * sum_up_awv_input  (i,j,k)
!    sum_up_rawthv(i,j,k) = rho_half(i,j,k) * sum_up_awthv_input(i,j,k)
!    sum_up_rawqt (i,j,k) = rho_half(i,j,k) * sum_up_awqt_input (i,j,k)
!  enddo   
!
!  sum_up_raw   (:,:,kxp) = 0.
!  sum_up_rawu  (:,:,kxp) = 0.
!  sum_up_rawv  (:,:,kxp) = 0.
!  sum_up_rawthv(:,:,kxp) = 0.
!  sum_up_rawqt (:,:,kxp) = 0.
!   
!   !*** set phi ***
!    if (phi_name == "uu") then
!      phi    (:,:,:) = uu   (:,:,:)
!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!      phi_rev(:) = uu_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!
!    elseif (phi_name == "vv") then
!      phi    (:,:,:) = vv   (:,:,:)
!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!      phi_rev(:) = vv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!  
!    elseif (phi_name == "thv") then
!      phi    (:,:,:) = thv   (:,:,:)
!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!      phi_rev(:) = thv_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!  
!    elseif (phi_name == "qt") then
!      phi_name = "qt"
!      phi    (:,:,:) = qt   (:,:,:)
!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!      phi_rev(:) = qt_rev(:)
!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!    endif
!
!  ! environment
!  sum_env_rawphi = 0.
!  do k=2,kx
!    sum_env_rawphi(i,j,k) = rho_half(i,j,k) * sum_up_aw_input(i,j,k) * 0.5*(phi(i,j,k)+phi(i,j,k-1))
!  enddo
!
!  ! updraft minus environment
!  w1phi1(:,:,:) = sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:)
!  !w1phi1(:,:,:) = 1/rho_half(:,:,:) * (sum_up_rawphi(:,:,:) - sum_env_rawphi(:,:,:))
!
!  ! compute dphi/dt
!  do k=1,kx
!    dphi_dt(i,j,k) = -1./rho_full(i,j,k) * (w1phi1(i,j,k)-w1phi1(i,j,k+1))  &
!                         / (z_half(i,j,k) - z_half(i,j,k+1))
!  enddo
!
!  !print*,'sum_up_rawphi',sum_up_rawphi 
!  !print*,'sum_env_rawphi',sum_env_rawphi 
!  !print*,'rho*w1phi1',w1phi1
!  !print*,'phi_name,dphi_dt',phi_name,dphi_dt
!
!  ! printout for NCL plotting
!  write(*,1000) 'sum_env_awthv_explicit = (/',sum_env_rawphi(:,:,:)/rho_half(:,:,:)
!  write(*,1000) 'thvdt_mf_explicit = (/',dphi_dt
!
!  ! replace tendency terms
!    thvdt_mf(:,:,:) = dphi_dt(:,:,:)
!    qdt_mf(:,:,:)   = 0.
!
!    ! compute theta_v and qq at the next time step, thv_temp and qq_temp
!    thv_temp(:) = thv(i,j,:) + thvdt_mf(i,j,:)*dt
!    qq_temp (:) = qq (i,j,:) + qdt_mf  (i,j,:)*dt
!
!    ! compute virtual temp (tv_temp) at the next time step
!    ape_temp(:) = (p_full(i,j,:)*p00inv)**(-kappa)
!    tv_temp (:) = thv_temp(:) / ape_temp(:)
!
!    ! compute temperature (tt_temp) at the next time step
!    tt_temp (:) = tv_temp(:) / (qq_temp(:)*d608+1.0)
!
!    ! compute temperature tendency
!    tdt_mf (i,j,:) = (tt_temp(:) - tt(i,j,:)) / dt
!
!    ! make sure tdt=0 when both thvdt & qdt = 0
!    do k=1,kx
!      if (thvdt_mf(i,j,k).eq.0. .and. qdt_mf(i,j,k).eq.0.) then
!        tdt_mf (i,j,k) = 0.
!      endif
!    enddo
!end if ! end if of use_explicit_solver
!!
!!!------------------
!!!check part - mass/energy conservation
!!!------------------
!!
!!!*** check qq ***
!!  tt1 = 0.
!!  tt2 = 0.
!! 
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + qq(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (qdt_mf(i,j,k)*dt+qq(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_qq, new_qq, rho, dz',k,qq(i,j,k),(qdt_mf(i,j,k)*dt+qq(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   qdt_mf',qdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'old qq (kg/m2), ',tt1
!!  print*,'new qq (kg/m2), ',tt2
!!  print*,'-----------------------------------------'
!!
!!!*** check tt ***
!!  tt1 = 0.
!!  tt2 = 0.
!!
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tt1 + tt(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + (tdt_mf(i,j,k)*dt+tt(i,j,k)) *rho_full(i,j,k)*tt3
!!    print*,'k,old_tt, new_tt, rho, dz',k,tt(i,j,k),(tdt_mf(i,j,k)*dt+tt(i,j,k)), rho_full(i,j,k), tt3
!!    print*,'   tdt_mf',tdt_mf(i,j,k)
!!  enddo
!!
!!  print*,'column old energy (J), ',tt1,'*Cp'
!!  print*,'column new energy (J), ',tt2,'*Cp'
!!  print*,'-----------------------------------------'
!!   
!!  tt1=0.
!!  tt2=0.
!!  do k=1,kx
!!    tt3 = z_half(i,j,k) - z_half(i,j,k+1)
!!    tt1 = tdt_mf(i,j,k)*rho_full(i,j,k)*tt3
!!    tt2 = tt2 + tt1
!!    print*,'k,tdt_mf,  heat_mf(J/s),',k,tdt_mf(i,j,k), tt1,'*Cp'
!!  enddo
!!
!!  print*,'sum of heat_mf (J/s), should cloase to zero,',tt2,'*Cp'
!!
!!!------------------
!!!check part - tridiagnol solver 
!!!------------------
!!  if (is_mass_flux(i,j)) then
!!    !phi_name = "uu"
!!    !phi_name = "vv"
!!    phi_name = "thv"
!!    !phi_name = "qt"
!! 
!!    !*** set phi ***
!!    if (phi_name == "uu") then
!!      phi    (:,:,:) = uu   (:,:,:)
!!      dphi_dt(:,:,:) = udt_mf(:,:,:)
!!      phi_rev(:) = uu_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawu(:,:,:)
!!
!!    elseif (phi_name == "vv") then
!!      phi    (:,:,:) = vv   (:,:,:)
!!      dphi_dt(:,:,:) = vdt_mf(:,:,:)
!!      phi_rev(:) = vv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawv(:,:,:)
!!  
!!    elseif (phi_name == "thv") then
!!      phi    (:,:,:) = thv   (:,:,:)
!!      dphi_dt(:,:,:) = thvdt_mf(:,:,:)
!!      phi_rev(:) = thv_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawthv(:,:,:)
!!  
!!    elseif (phi_name == "qt") then
!!      phi_name = "qt"
!!      phi    (:,:,:) = qt   (:,:,:)
!!      dphi_dt(:,:,:) = qtdt_mf(:,:,:)
!!      phi_rev(:) = qt_rev(:)
!!      sum_up_rawphi(:,:,:) = sum_up_rawqt(:,:,:)
!!
!!    endif
!!
!!    !*** check program ***
!!    do k=1,kx
!!      kk=kx-k+1
!!      phi_d(kk) = phi (i,j,k) + dphi_dt(i,j,k)*dt  ! reverse 
!!    enddo
!!
!!    do k=1,kx
!!      print*,'i,j,k,phi(t),dphi,',i,j,k,phi(i,j,k),dphi_dt(i,j,k)*dt,' ',phi_name
!!    enddo
!!    print*,'-------------------------'
!!
!!    k=1
!!    !tt1 = phi_d(k) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!    tt2 = phi_d(k) * (1. - 0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!    tt4 = phi_rev(k) - dt_rhodz(k)*sum_up_rawphi(i,j,k+1)
!!    print*,'k,lhs,rhs,lhs-rhs',k,tt2+tt3,tt4,tt2+tt3-tt4
!!
!!    do k=2,kx
!!      tt1 = phi_d(k-1) * (0.5*sum_up_raw(i,j,k)*dt_rhodz(k))
!!      tt2 = phi_d(k) * (1. + 0.5*dt_rhodz(k)*(sum_up_raw(i,j,k)-sum_up_raw(i,j,k+1)))
!!      tt3 = phi_d(k+1) * (-0.5*dt_rhodz(k)*sum_up_raw(i,j,k+1))
!!      tt4 = phi_rev(k) + dt_rhodz(k)*(sum_up_rawphi(i,j,k)-sum_up_rawphi(i,j,k+1))
!!      print*,'k,lhs,rhs,lhs-rhs',k,tt1+tt2+tt3,tt4,tt1+tt2+tt3-tt4
!!    enddo
!!
!!    end if ! end if of is_mass_flux
!!!------------------
!!!check part end
!!!------------------
!
!  enddo  ! end loop of j
!  enddo  ! end loop of i
!
!!!------------------------------
!!! write out to history files
!!!------------------------------
!!
!!!------- u tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_udt_mf > 0) then
!!    used = send_data (id_udt_mf, udt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- v tendency from mass flux (units: m/s2) at full level -------
!!  if ( id_vdt_mf > 0) then
!!    used = send_data (id_vdt_mf, vdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- t tendency from mass flux (units: K/s) at full level -------
!!  if ( id_tdt_mf > 0) then
!!    used = send_data (id_tdt_mf, tdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- q tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qdt_mf > 0) then
!!    used = send_data (id_qdt_mf, qdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- thv tendency from mass flux (units: K/s) at full level -------
!!  if ( id_thvdt_mf > 0) then
!!    used = send_data (id_thvdt_mf, thvdt_mf, time, is, js, 1 )
!!  endif
!!
!!!------- qt tendency from mass flux (units: kg/kg/s) at full level -------
!!  if ( id_qtdt_mf > 0) then
!!    used = send_data (id_qtdt_mf, qtdt_mf, time, is, js, 1 )
!!  endif
!
!1000 format (A35,40(E12.4,2X))
!1001 format (A25,40(F8.3,2X))
!1002 format (A25,I2,A10,40(F8.3,2X))
!1003 format (A25,I2,A10,40(E12.4,2X))
!
!end subroutine OUTDATED_massflux_tendencies

!#######################################################################

subroutine random_Poisson(mu,first,ival) 
!**********************************************************************
!     Translated to Fortran 90 by Alan Miller from:
!                           RANLIB
!
!     Library of Fortran Routines for Random Number Generation
!
!                    Compiled and Written by:
!
!                         Barry W. Brown
!                          James Lovato
!
!             Department of Biomathematics, Box 237
!             The University of Texas, M.D. Anderson Cancer Center
!             1515 Holcombe Boulevard
!             Houston, TX      77030
!
! This work was supported by grant CA-16672 from the National Cancer Institute.

!                    GENerate POIsson random deviate
!                            Function
! Generates a single random deviate from a Poisson distribution with mean mu.
!                            Arguments
!     mu --> The mean of the Poisson distribution from which
!            a random deviate is to be generated.
!                              REAL mu
!                              Method
!     For details see:
!               Ahrens, J.H. and Dieter, U.
!               Computer Generation of Poisson Deviates
!               From Modified Normal Distributions.
!               ACM Trans. Math. Software, 8, 2
!               (June 1982),163-179
!     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT
!     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL
!     SEPARATION OF CASES A AND B

!     .. Scalar Arguments ..
	REAL, INTENT(IN)    :: mu
	LOGICAL, INTENT(IN) :: first
INTEGER             :: ival
!     ..
!     .. Local Scalars ..
	REAL          :: b1, b2, c, c0, c1, c2, c3, del, difmuk, e, fk, fx, fy, g,  &
                    omega, px, py, t, u, v, x, xx
	REAL, SAVE    :: s, d, p, q, p0
        INTEGER       :: j, k, kflag
	LOGICAL, SAVE :: full_init
        INTEGER, SAVE :: l, m
!     ..
!     .. Local Arrays ..
	REAL, SAVE    :: pp(35)
!     ..
!     .. Data statements ..
	REAL, PARAMETER :: a0 = -.5, a1 = .3333333, a2 = -.2500068, a3 = .2000118,  &
                a4 = -.1661269, a5 = .1421878, a6 = -.1384794,   &
                 a7 = .1250060

	REAL, PARAMETER :: fact(10) = (/ 1., 1., 2., 6., 24., 120., 720., 5040.,  &
            40320., 362880. /)

        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

!     ..
!     .. Executable Statements ..
   IF (mu > 10.0) THEN
!     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED)

  IF (first) THEN
s = SQRT(mu)
d = 6.0*mu*mu

!             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL
!             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484)
!             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 .

l = mu - 1.1484
full_init = .false.
  END IF


!     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE

	  g = mu + s*random_normal()
	  IF (g > 0.0) THEN
		ival = g

	!     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH

		IF (ival>=l) RETURN

	!     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U

		fk = ival
		difmuk = mu - fk
		CALL RANDOM_NUMBER(u)
		IF (d*u >= difmuk*difmuk*difmuk) RETURN
	  END IF

	!     STEP P. PREPARATIONS FOR STEPS Q AND H.
	!             (RECALCULATIONS OF PARAMETERS IF NECESSARY)
	!             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7.
	!             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE
	!             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK.
	!             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION.

	  IF (.NOT. full_init) THEN
		omega = .3989423/s
		b1 = .4166667E-1/mu
		b2 = .3*b1*b1
		c3 = .1428571*b1*b2
		c2 = b2 - 15.*c3
		c1 = b1 - 6.*b2 + 45.*c3
		c0 = 1. - b1 + 3.*b2 - 15.*c3
		c = .1069/mu
		full_init = .true.
	  END IF

	  IF (g < 0.0) GO TO 50

	!             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN)

	  kflag = 0
	  GO TO 70

	!     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE)

	  40 IF (fy-u*fy <= py*EXP(px-fx)) RETURN

	!     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL
	!             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT'
	!             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.)

	  50 e = random_exponential()
	  CALL RANDOM_NUMBER(u)
	  u = u + u - one
	  t = 1.8 + SIGN(e, u)
	  IF (t <= (-.6744)) GO TO 50
	  ival = mu + s*t
	  fk = ival
	  difmuk = mu - fk

	!             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN)

	  kflag = 1
	  GO TO 70

	!     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION)

	  60 IF (c*ABS(u) > py*EXP(px+e) - fy*EXP(fx+e)) GO TO 50
	  RETURN

	!     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY.
	!             CASE ival < 10 USES FACTORIALS FROM TABLE FACT

	  70 IF (ival>=10) GO TO 80
	  px = -mu
	  py = mu**ival/fact(ival+1)
	  GO TO 110

	!             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION
	!             A0-A7 FOR ACCURACY WHEN ADVISABLE
	!             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5)

	  80 del = .8333333E-1/fk
	  del = del - 4.8*del*del*del
	  v = difmuk/fk
	  IF (ABS(v)>0.25) THEN
		px = fk*LOG(one + v) - difmuk - del
	  ELSE
		px = fk*v*v* (((((((a7*v+a6)*v+a5)*v+a4)*v+a3)*v+a2)*v+a1)*v+a0) - del
	  END IF
	  py = .3989423/SQRT(fk)
	  110 x = (half - difmuk)/s
	  xx = x*x
	  fx = -half*xx
	  fy = omega* (((c3*xx + c2)*xx + c1)*xx + c0)
	  IF (kflag <= 0) GO TO 40
	  GO TO 60

	!---------------------------------------------------------------------------
	!     C A S E  B.    mu < 10
	!     START NEW TABLE AND CALCULATE P0 IF NECESSARY

	ELSE
	  IF (first) THEN
		m = MAX(1, INT(mu))
		l = 0
		p = EXP(-mu)
		q = p
		p0 = p
	  END IF

	!     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD

	  DO
		CALL RANDOM_NUMBER(u)
		ival = 0
		IF (u <= p0) RETURN

	!     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE
	!             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES
	!             (0.458=PP(9) FOR MU=10)

		IF (l == 0) GO TO 150
		j = 1
		IF (u > 0.458) j = MIN(l, m)
		DO k = j, l
		  IF (u <= pp(k)) GO TO 180
		END DO
		IF (l == 35) CYCLE

	!     STEP C. CREATION OF NEW POISSON PROBABILITIES P
	!             AND THEIR CUMULATIVES Q=PP(K)

		150 l = l + 1
		DO k = l, 35
		  p = p*mu / k
		  q = q + p
		  pp(k) = q
		  IF (u <= q) GO TO 170
		END DO
		l = 35
	  END DO

	  170 l = k
	  180 ival = k
	  RETURN
	END IF

	RETURN
	END subroutine random_Poisson

!#######################################################################
	FUNCTION random_normal() RESULT(fn_val)

	! Adapted from the following Fortran 77 code
	!      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM.
	!      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE,
	!      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435.

	!  The function random_normal() returns a normally distributed pseudo-random
	!  number with zero mean and unit variance.

	!  The algorithm uses the ratio of uniforms method of A.J. Kinderman
	!  and J.F. Monahan augmented with quadratic bounding curves.

	REAL :: fn_val

	!     Local variables
	REAL     :: s = 0.449871, t = -0.386595, a = 0.19600, b = 0.25472,           &
				r1 = 0.27597, r2 = 0.27846, u, v, x, y, q
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	!     Generate P = (u,v) uniform in rectangle enclosing acceptance region

	DO
	  CALL RANDOM_NUMBER(u)
	  CALL RANDOM_NUMBER(v)
	  v = 1.7156 * (v - half)

	!     Evaluate the quadratic form
	  x = u - s
	  y = ABS(v) - t
	  q = x**2 + y*(a*y - b*x)

	!     Accept P if inside inner ellipse
	  IF (q < r1) EXIT
	!     Reject P if outside outer ellipse
	  IF (q > r2) CYCLE
	!     Reject P if outside acceptance region
	  IF (v**2 < -4.0*LOG(u)*u**2) EXIT
	END DO

	!     Return ratio of P's coordinates as the normal deviate
	fn_val = v/u
	RETURN

	END FUNCTION random_normal

!#######################################################################
	FUNCTION random_exponential() RESULT(fn_val)

	! Adapted from Fortran 77 code from the book:
	!     Dagpunar, J. 'Principles of random variate generation'
	!     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9

	! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM
	! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL
	! TO EXP(-random_exponential), USING INVERSION.

	REAL  :: fn_val

	!     Local variable
	REAL  :: r
        REAL, PARAMETER  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0  ! yi-hsuan.chen added, 2020-04-03

	DO
	  CALL RANDOM_NUMBER(r)
	  IF (r > zero) EXIT
	END DO

	fn_val = -LOG(r)
	RETURN

	END FUNCTION random_exponential

!#######################################################################
  SUBROUTINE tridiag(n,a,b,c,d)

!! to solve system of linear eqs on tridiagonal matrix n times n
!! after Peaceman and Rachford, 1955
!! a,b,c,d - are vectors of order n 
!! a,b,c - are coefficients on the LHS
!! d - is initially RHS on the output becomes a solution vector
    
!-------------------------------------------------------------------

    INTEGER, INTENT(in):: n
    REAL, DIMENSION(n), INTENT(in) :: a,b
    REAL, DIMENSION(n), INTENT(inout) :: c,d
    
    INTEGER :: i
    REAL :: p
    REAL, DIMENSION(n) :: q
    
    c(n)=0.
    q(1)=-c(1)/b(1)
    d(1)=d(1)/b(1)
    
    DO i=2,n
       p=1./(b(i)+a(i)*q(i-1))
       q(i)=-c(i)*p
       d(i)=(d(i)-a(i)*d(i-1))*p
    ENDDO
    
    DO i=n-1,1,-1
       d(i)=d(i)+q(i)*d(i+1)
    ENDDO

  END SUBROUTINE tridiag

!#######################################################################
!#######################################################################
! DO NOT COPY this program
subroutine compute_qs(t, p, qs)
  real, intent(in) :: t, p    ! t in K; p in Pa
  real, intent(out) :: qs     ! kg/kg
  real esl_hpa, esi_hpa, esl_pa, esi_pa

  esl_hpa = exp (53.67957 - 6743.769  /t - 4.8451 *log(t))
  esi_hpa = exp (23.33086 - 6111.72784/t + 0.15215*log(t))

  esl_pa = esl_hpa*100.  ! change unit to Pa
  esi_pa = esi_hpa*100.  ! change unit to Pa

  qs = esl_pa / p * (18./28.8) ! change unit to kg/kg
  
end subroutine
 


end module edmf_test
!##########################################

program test111
  use edmf_test

  implicit none
  integer, parameter :: ni = 1
  integer, parameter :: nj = 1
  integer, parameter :: nfull = 33
  integer, parameter :: nhalf = nfull+1
  integer, parameter :: nfull2 = nfull+1
  integer, parameter :: nhalf2 = nfull2+1

  integer                   :: is, js
  real                      :: dt
  real,    dimension(ni,nj,nhalf) :: p_half, z_half
  real,    dimension(ni,nj,nfull) :: p_full, z_full, uu, vv, tt, qq, thv
  real,    dimension(ni,nj,nfull) :: udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, qtdt_mf, thlidt_mf
  !real,    dimension(ni,nj)   :: cov_w_thv, cov_w_qt
  real,    dimension(ni,nj)   :: z_pbl
  real,    dimension(ni,nj)   :: u_star, b_star, q_star
  !logical,    dimension(ni,nj)   :: is_mass_flux
  real,    dimension(ni,nj)   :: is_mass_flux

  real, dimension(ni,nj,nhalf) :: &  ! dimension (nlon,nlat, nlay)
        sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,               &
        sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux

  real,    dimension(ni,nj,nhalf2) :: p_half2, z_half2
  real,    dimension(ni,nj,nfull2) :: p_full2, z_full2, uu2, vv2, tt2, qq2, thv2
  real,    dimension(ni,nj,nfull2) :: udt_mf2, vdt_mf2, tdt_mf2, qdt_mf2, thvdt_mf2, qtdt_mf2, thlidt_mf2
  real, dimension(ni,nj,nhalf2) :: &  ! dimension (nlon,nlat, nlay)
        sum_up_a2, sum_up_aw2, sum_up_awu2, sum_up_awv2,               &
        sum_up_awthv2, sum_up_awthli2, sum_up_awqt2, avg_up_w2, sum_up_massflux2

  !real, parameter  :: zero = 0.0, half = 0.5, one = 1.0, two = 2.0

  ! play with subroutine tridiag
  integer, parameter :: nn = 3
  real, dimension(nn) :: aa, bb, cc, dd

  integer i,j,k
  real dzk

  real  :: &
      qsat, &
      qt,              &   ! total water mixing ratio (vapor + cloud liquid + cloud ice), units: kg/kg
      thli,            &   ! ice-liquid water potential temperature                     , units: K
      p,               &   ! pressure                                                   , units: Pa
      water_frac,      &    ! cloud liquid water fraction                                , units: fraction
      thv1,             &   ! virtual potential temperature     , units: K
      ql, qi, &
      qc                   ! cloud water (liq+ice) mixing ratio, units: kg/kg

  !data aa/5.,1.,1./
  !data bb/4.,7.,1./
  !data cc/1.,-1.,1./

  type(time_type) :: Time_next

  data aa/0.,1.,5./
  data bb/1.,1.,1./
  data cc/2.,1.,0./
  data dd/5.,6.,13./

  data dt /1800./
  !data dt /600./
  !data dt /300./
  !data dt /60./
  !data dt /30./

  !character*20 option_solver

!************************* 
!  source: ../data/SCM_am4_xanadu_test111.d11-DCBL_C1_my25_mf_diagnostic.*.nc
!  time stpe = 0
!************************* 
!  data_source  = "../data/SCM_am4_xanadu_test111.d11-DCBL_C1_my25_mf_diagnostic.*.nc &&& time_step = 0"
!  data u_star /   0.28/
!  data q_star /0.00e+00/
!  data b_star /7.03e-03/
!  data uu /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!  data vv /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!  data qq /5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16,  5.00e-16/
!  data p_half /   1.00,    4.00,    8.19,   13.79,   20.92,   29.84,   41.22,   55.79,   74.20,   97.05,  124.97,  158.55,  198.40,  245.03,  298.89,  360.04,  427.46,  498.24,  568.22,  633.84,  693.27,  745.99,  792.10,  831.92,  865.98,  894.87,  919.23,  939.57,  956.40,  970.15,  981.13,  989.68,  995.90, 1000.00/
!  data z_half /42694.25, 34573.39, 30378.31, 27323.78, 24882.49, 22802.21, 20909.25, 19135.68, 17465.25, 15892.89, 14411.75, 13017.43, 11704.06, 10423.95, 9156.39, 7911.59, 6712.83, 5599.96, 4612.53, 3767.70, 3058.42, 2467.16, 1975.85, 1568.85, 1232.52,  955.05,  726.48,  539.15,  386.43,  263.27,  165.83,   90.56,   36.11,    0.00/
!  data p_full /   2.16,    5.85,   10.75,   17.11,   25.11,   35.22,   48.14,   64.56,   85.11,  110.42,  141.09,  177.73,  220.89,  271.07,  328.52,  392.79,  461.95,  532.47,  600.43,  663.11,  719.31,  768.81,  811.85,  848.84,  880.35,  907.00,  929.36,  947.96,  963.26,  975.63,  985.40,  992.79,  997.95/
!  data z_full /38633.82, 32475.85, 28851.04, 26103.13, 23842.35, 21855.72, 20022.46, 18300.46, 16679.07, 15152.32, 13714.59, 12360.75, 11064.00, 9790.17, 8533.99, 7312.21, 6156.39, 5106.24, 4190.11, 3413.06, 2762.79, 2221.51, 1772.35, 1400.69, 1093.79,  840.76,  632.81,  462.79,  324.85,  214.55,  128.19,   63.33,   18.06/
!  data z_pbl /  35.61/
!  data tt / 200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  207.04,  217.80,  228.31,  238.45,  247.96,  256.52,  263.94,  270.19,  275.40,  279.71,  283.27,  286.21,  288.63,  290.62,  292.25,  293.58,  294.66,  295.53,  296.20,  296.71,  297.06/

!!************************* 
!!  source: ../data/SCM_am4_xanadu_test111.d11-DCBL_C1_my25_mf_diagnostic.*.nc
!!  time stpe = 1 (super-adiabatic)
!!************************* 
!  data_source  = "../data/SCM_am4_xanadu_test111.d11-DCBL_C1_my25_mf_diagnostic.*.nc &&& time_step = 1"
!  data u_star /   0.28/
!  data q_star /0.00e+00/
!  data b_star /7.03e-03/
!  data uu /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!  data vv /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!!  data qq /5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16,  5.00e-16/
!  data qq /5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 3.67e-04, 1.32e-03, 1.39e-03, 2.01e-03, 3.13e-03, 4.38e-03, 6.52e-03, 7.08e-03, 7.93e-03, 9.62e-03, 1.18e-02, 1.48e-02, 1.55e-02, 1.57e-02, 1.59e-02, 1.60e-02, 1.61e-02, 1.63e-02/
!  data p_half /   1.00,    4.00,    8.19,   13.79,   20.92,   29.84,   41.22,   55.79,   74.20,   97.05,  124.97,  158.55,  198.40,  245.03,  298.89,  360.04,  427.46,  498.24,  568.22,  633.84,  693.27,  745.99,  792.10,  831.92,  865.98,  894.87,  919.23,  939.57,  956.40,  970.15,  981.13,  989.68,  995.90, 1000.00/
!  data z_half /42694.61, 34573.75, 30378.67, 27324.14, 24882.86, 22802.57, 20909.61, 19136.04, 17465.61, 15893.25, 14412.11, 13017.80, 11704.43, 10424.31, 9156.75, 7911.95, 6713.19, 5600.32, 4612.89, 3768.06, 3058.78, 2467.52, 1976.22, 1569.22, 1232.89,  955.41,  726.84,  539.51,  386.79,  263.63,  166.19,   90.92,   36.05,    0.00/
!  data p_full /   2.16,    5.85,   10.75,   17.11,   25.11,   35.22,   48.14,   64.56,   85.11,  110.42,  141.09,  177.73,  220.89,  271.07,  328.52,  392.79,  461.95,  532.47,  600.43,  663.11,  719.31,  768.81,  811.85,  848.84,  880.35,  907.00,  929.36,  947.96,  963.26,  975.63,  985.40,  992.79,  997.95/
!  data z_full /38634.18, 32476.21, 28851.41, 26103.50, 23842.71, 21856.09, 20022.82, 18300.83, 16679.43, 15152.68, 13714.95, 12361.11, 11064.37, 9790.53, 8534.35, 7312.57, 6156.76, 5106.60, 4190.47, 3413.42, 2763.15, 2221.87, 1772.72, 1401.05, 1094.15,  841.13,  633.18,  463.15,  325.21,  214.91,  128.56,   63.48,   18.02/
!  data z_pbl /  35.98/
!  data tt / 200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  200.00,  207.04,  217.80,  228.31,  238.45,  247.96,  256.52,  263.94,  270.19,  275.40,  279.71,  283.27,  286.21,  288.63,  290.62,  292.25,  293.58,  294.66,  295.53,  296.20,  296.71,  300.08/

!****************
!****************
!   data p_half/     100.000  ,   400.000  ,   818.602  ,  1378.887  ,  2091.795  ,  2983.641  ,  4121.790  ,  5579.221  ,  7423.179  ,  9716.255  , 12521.705  , 15898.506  , 19906.726  , 24598.293  , 30018.153  , 36172.146  , 42957.126  , 50081.293  , 57124.246  , 63728.335  , 69709.951  , 75016.789  , 79657.319  , 83665.695  , 87093.457  , 90001.747  , 92453.153  , 94500.211  , 96194.799  , 97578.298  , 98683.693  , 99544.102  ,100169.987, 100582.462  /
!   data z_half/   44166.004  , 35255.869  , 30854.586  , 27712.967  , 25222.056  , 23087.926  , 21129.978  , 19272.287  , 17493.162  , 15796.262  , 14187.651  , 12666.728  , 11231.775  ,  9913.992  ,  8686.808  ,  7490.858  ,  6339.566  ,  5271.881  ,  4329.054  ,  3527.913  ,  2859.145  ,  2305.115  ,  1849.473  ,  1475.616  ,  1169.662  ,   919.525  ,   715.396  ,   549.218  ,   414.532  ,   306.533  ,   222.231  ,   158.972  ,   113.512, 83.675  /
!   data p_full/     216.404  ,   584.531  ,  1074.508  ,  1710.654  ,  2511.381  ,  3522.120  ,  4813.790  ,  6457.380  ,  8518.339  , 11059.740  , 14142.982  , 17827.581  , 22169.835  , 27218.346  , 32999.568  , 39467.481  , 46428.148  , 53525.565  , 60366.095  , 66674.430  , 72330.927  , 77313.844  , 81645.108  , 85368.107  , 88539.641  , 91221.960  , 93472.946  , 95344.995  , 96884.902  , 98129.958  , 99113.275  , 99856.717  ,100376.083  /
!   data z_full/   39710.936  , 33055.227  , 29283.777  , 26467.512  , 24154.991  , 22108.952  , 20201.133  , 18382.725  , 16644.712  , 14991.957  , 13427.190  , 11949.252  , 10572.884  ,  9300.400  ,  8088.833  ,  6915.212  ,  5805.723  ,  4800.467  ,  3928.484  ,  3193.529  ,  2582.130  ,  2077.294  ,  1662.545  ,  1322.639  ,  1044.594  ,   817.461  ,   632.307  ,   481.875  ,   360.533  ,   264.382  ,   190.601  ,   136.242  ,    98.593  /
!   data u_star/      2.01/
!   data b_star/    0.7089E-01/
!   data q_star/    0.1705E-03/
!    data z_pbl/     61.56/
!       data uu/      81.829  ,    59.517  ,    48.416  ,    39.259  ,    34.208  ,    30.344  ,    26.590  ,    22.672  ,    21.733  ,    22.493  ,    22.345  ,    21.254  ,    21.856  ,    24.742  ,    19.300  ,    14.953  ,    14.465  ,    11.381  ,    10.755  ,     7.093  ,     4.345  ,     2.598  ,     1.695  ,     0.853  ,    -0.201  ,    -1.282  ,    -1.431  ,    -1.860  ,    -2.923  ,    -7.252  ,   -12.995  ,   -13.790  ,   -12.867  /
!       data vv/       0.756  ,    -3.632  ,    -8.879  ,   -11.357  ,   -12.277  ,   -11.355  ,   -11.733  ,   -11.131  ,   -11.024  ,   -10.394  ,    -8.694  ,    -7.192  ,    -5.333  ,    -0.958  ,    -1.080  ,    -1.796  ,     0.587  ,     3.449  ,     5.549  ,     8.668  ,    10.642  ,    13.531  ,    15.655  ,    17.652  ,    19.254  ,    21.167  ,    22.494  ,    23.566  ,    25.504  ,    23.865  ,    16.723  ,     9.529  ,     5.484  /
!       data tt/     219.438  ,   209.830  ,   205.702  ,   204.066  ,   205.176  ,   206.866  ,   209.486  ,   212.713  ,   215.217  ,   216.509  ,   217.483  ,   217.902  ,   212.603  ,   210.408  ,   218.947  ,   228.629  ,   237.526  ,   244.569  ,   249.905  ,   254.338  ,   257.591  ,   258.935  ,   259.754  ,   259.937  ,   259.813  ,   259.169  ,   258.905  ,   258.568  ,   258.060  ,   255.386  ,   248.732  ,   247.567  ,   247.840  /
!       data qq/    0.1775E-05  ,  0.1754E-05  ,  0.1749E-05  ,  0.1745E-05  ,  0.1730E-05  ,  0.1706E-05  ,  0.1812E-05  ,  0.1901E-05  ,  0.1943E-05  ,  0.2146E-05  ,  0.2428E-05  ,  0.4205E-05  ,  0.9774E-05  ,  0.1631E-04  ,  0.3446E-04  ,  0.1061E-03  ,  0.2351E-03  ,  0.4560E-03  ,  0.7490E-03  ,  0.1093E-02  ,  0.1419E-02  ,  0.1535E-02  ,  0.1472E-02  ,  0.1352E-02  ,  0.1140E-02  ,  0.1095E-02  ,  0.1033E-02  ,  0.1008E-02  ,  0.9859E-03  ,  0.7872E-03  ,  0.4022E-03  ,  0.3795E-03  ,  0.3839E-03  /

!***************
! a very large surface heat flux case from AMIP simulation
!***************
!   data p_half/     100.000  ,   400.000  ,   818.602  ,  1378.887  ,  2091.795  ,  2983.641  ,  4121.790  ,  5579.221  ,  7423.179  ,  9716.255  , 12521.705  , 15898.506  , 19906.726  , 24598.293  , 30018.153  , 36172.146  , 42957.126  , 50081.293  , 57124.246  , 63728.335  , 69709.951  , 75016.789  , 79657.319  , 83665.695  , 87093.457  , 90001.747  , 92453.153  , 94500.211  , 96194.799  , 97578.298  , 98683.693  , 99544.102  ,100169.987  , 100582.462  /
!   data z_half/   44166.004  , 35255.869  , 30854.586  , 27712.967  , 25222.056  , 23087.926  , 21129.978  , 19272.287  , 17493.162  , 15796.262  , 14187.651  , 12666.728  , 11231.775  ,  9913.992  ,  8686.808  ,  7490.858  ,  6339.566  ,  5271.881  ,  4329.054  ,  3527.913  ,  2859.145  ,  2305.115  ,  1849.473  ,  1475.616  ,  1169.662  ,   919.525  ,   715.396  ,   549.218  ,   414.532  ,   306.533  ,   222.231  ,   158.972  ,   113.512  , 83.675  /
!   data p_full/     216.404  ,   584.531  ,  1074.508  ,  1710.654  ,  2511.381  ,  3522.120  ,  4813.790  ,  6457.380  ,  8518.339  , 11059.740  , 14142.982  , 17827.581  , 22169.835  , 27218.346  , 32999.568  , 39467.481  , 46428.148  , 53525.565  , 60366.095  , 66674.430  , 72330.927  , 77313.844  , 81645.108  , 85368.107  , 88539.641  , 91221.960  , 93472.946  , 95344.995  , 96884.902  , 98129.958  , 99113.275  , 99856.717  ,100376.083  /
!   data z_full/   39710.936  , 33055.227  , 29283.777  , 26467.512  , 24154.991  , 22108.952  , 20201.133  , 18382.725  , 16644.712  , 14991.957  , 13427.190  , 11949.252  , 10572.884  ,  9300.400  ,  8088.833  ,  6915.212  ,  5805.723  ,  4800.467  ,  3928.484  ,  3193.529  ,  2582.130  ,  2077.294  ,  1662.545  ,  1322.639  ,  1044.594  ,   817.461  ,   632.307  ,   481.875  ,   360.533  ,   264.382  ,   190.601  ,   136.242  ,    98.593  /
!   data u_star/      2.01/
!   data b_star/    0.7089E-01/
!   data q_star/    0.1705E-03/
!    data z_pbl/     61.56/
!       data uu/      81.829  ,    59.517  ,    48.416  ,    39.259  ,    34.208  ,    30.344  ,    26.590  ,    22.672  ,    21.733  ,    22.493  ,    22.345  ,    21.254  ,    21.856  ,    24.742  ,    19.300  ,    14.953  ,    14.465  ,    11.381  ,    10.755  ,     7.093  ,     4.345  ,     2.598  ,     1.695  ,     0.853  ,    -0.201  ,    -1.282  ,    -1.431  ,    -1.860  ,    -2.923  ,    -7.252  ,   -12.995  ,   -13.790  ,   -12.867  /
!       data vv/       0.756  ,    -3.632  ,    -8.879  ,   -11.357  ,   -12.277  ,   -11.355  ,   -11.733  ,   -11.131  ,   -11.024  ,   -10.394  ,    -8.694  ,    -7.192  ,    -5.333  ,    -0.958  ,    -1.080  ,    -1.796  ,     0.587  ,     3.449  ,     5.549  ,     8.668  ,    10.642  ,    13.531  ,    15.655  ,    17.652  ,    19.254  ,    21.167  ,    22.494  ,    23.566  ,    25.504  ,    23.865  ,    16.723  ,     9.529  ,     5.484  /
!       data tt/     219.438  ,   209.830  ,   205.702  ,   204.066  ,   205.176  ,   206.866  ,   209.486  ,   212.713  ,   215.217  ,   216.509  ,   217.483  ,   217.902  ,   212.603  ,   210.408  ,   218.947  ,   228.629  ,   237.526  ,   244.569  ,   249.905  ,   254.338  ,   257.591  ,   258.935  ,   259.754  ,   259.937  ,   259.813  ,   259.169  ,   258.905  ,   258.568  ,   258.060  ,   255.386  ,   248.732  ,   247.567  ,   247.840  /
!       data qq/    0.1775E-05  ,  0.1754E-05  ,  0.1749E-05  ,  0.1745E-05  ,  0.1730E-05  ,  0.1706E-05  ,  0.1812E-05  ,  0.1901E-05  ,  0.1943E-05  ,  0.2146E-05  ,  0.2428E-05  ,  0.4205E-05  ,  0.9774E-05  ,  0.1631E-04  ,  0.3446E-04  ,  0.1061E-03  ,  0.2351E-03  ,  0.4560E-03  ,  0.7490E-03  ,  0.1093E-02  ,  0.1419E-02  ,  0.1535E-02  ,  0.1472E-02  ,  0.1352E-02  ,  0.1140E-02  ,  0.1095E-02  ,  0.1033E-02  ,  0.1008E-02  ,  0.9859E-03  ,  0.7872E-03  ,  0.4022E-03  ,  0.3795E-03  ,  0.3839E-03  /

!
! There are 33 full levels and 34 half levels

! pressure at half level (Pa)
   data p_half/     100.000  ,   400.000  ,   818.602  ,  1378.887  ,  2091.795  ,  2983.641  ,  4121.790  ,  5579.221  ,  7360.241  ,  9474.686  , 11994.277  , 14981.182  , 18494.854  , 22585.258  , 27294.766  , 32630.810  , 38505.950  , 44669.362  , 50759.044  , 56467.156  , 61635.976  , 66220.929  , 70229.747  , 73692.171  , 76652.866  , 79164.757  , 81281.966  , 83049.791  , 84513.360  , 85708.414  , 86664.377  , 87409.461  , 87953.514  , 88313.848  /

! height at half level (m)
   data z_half/   42099.086  , 33837.576  , 29608.878  , 26560.705  , 24159.830  , 22128.511  , 20267.898  , 18504.841  , 16861.473  , 15340.514  , 13897.776  , 12521.269  , 11201.830  ,  9946.613  ,  8749.528  ,  7615.302  ,  6555.573  ,  5591.362  ,  4745.612  ,  4024.647  ,  3420.867  ,  2918.279  ,  2501.131  ,  2156.000  ,  1871.093  ,  1636.405  ,  1443.425  ,  1286.556  ,  1160.209  ,  1059.185  ,   979.345  ,   917.786  ,   873.261  , 845.221  /

! pressure at full level (Pa)
   data p_full/     216.404  ,   584.531  ,  1074.508  ,  1710.654  ,  2511.381  ,  3522.120  ,  4813.790  ,  6428.665  ,  8373.014  , 10685.016  , 13432.426  , 16676.370  , 20471.994  , 24865.726  , 29883.429  , 35487.362  , 41511.424  , 47649.364  , 53562.417  , 59013.844  , 63901.040  , 68205.704  , 71947.074  , 75162.800  , 77902.062  , 80218.705  , 82162.709  , 83779.445  , 85109.489  , 86185.512  , 87036.387  , 87681.206  , 88133.558  /

! height at full level (m)
   data z_full/   37968.331  , 31723.227  , 28084.791  , 25360.268  , 23144.171  , 21198.205  , 19386.369  , 17683.157  , 16100.993  , 14619.145  , 13209.523  , 11861.550  , 10574.222  ,  9348.070  ,  8182.415  ,  7085.438  ,  6073.468  ,  5168.487  ,  4385.129  ,  3722.757  ,  3169.573  ,  2709.705  ,  2328.566  ,  2013.547  ,  1753.749  ,  1539.915  ,  1364.991  ,  1223.382  ,  1109.697  ,  1019.265  ,   948.565  ,   895.523  ,   859.241  /

! buoyancy flux
  
! surface heat flux (K m/s)
!  data w1_thv1_surf  / 9.74E-02/

! surface moisture flux (kg/kg m/s)
!  data w1_qt1_surf   / 1.37E-06/

!output from CM4   data u_star/      0.33/
!output from CM4   data b_star/    0.1192E-01/
!output from CM4   data q_star/    0.4157E-05/
  data u_star/      0.33/
  data b_star/    0.1192E-01/
  data q_star/    0.4157E-05/

! PBL depth (m)
    data z_pbl/     14.15/

! zonal wind velocity at full levels (m/s)
       data uu/      22.522  ,    16.119  ,    13.937  ,    12.410  ,    10.556  ,    10.327  ,     9.891  ,     8.381  ,     7.165  ,     5.648  ,     4.432  ,     3.342  ,     2.119  ,     0.697  ,    -0.804  ,    -2.102  ,    -3.096  ,    -3.659  ,    -3.724  ,    -3.870  ,    -3.509  ,    -3.423  ,    -2.777  ,    -2.755  ,    -3.329  ,    -3.097  ,    -3.778  ,    -4.311  ,    -4.667  ,    -6.113  ,    -6.840  ,    -7.036  ,    -6.609  /

! meridional wind velocity at full levels (m/s)
       data vv/     -15.618  ,    -6.786  ,    -2.674  ,    -0.094  ,     0.648  ,     0.592  ,     0.506  ,     0.027  ,    -0.950  ,    -1.145  ,    -1.180  ,    -1.201  ,    -1.449  ,    -1.932  ,    -1.993  ,    -1.653  ,    -1.692  ,    -1.823  ,    -1.763  ,    -0.891  ,     0.509  ,     0.932  ,     1.449  ,     1.154  ,     0.953  ,     0.306  ,    -0.194  ,    -1.554  ,    -1.912  ,    -2.539  ,    -3.220  ,    -2.626  ,    -0.906  /

! temperatur at full levels (K). Note the the vertical gradient is very large at the lowest two levles (~ 290 K/km)
       data tt/     203.464  ,   201.602  ,   199.583  ,   196.689  ,   195.292  ,   196.582  ,   198.815  ,   202.521  ,   205.630  ,   208.889  ,   211.346  ,   213.802  ,   214.484  ,   215.791  ,   216.866  ,   218.540  ,   221.716  ,   225.932  ,   230.965  ,   235.340  ,   239.128  ,   242.288  ,   244.821  ,   246.910  ,   248.463  ,   249.602  ,   248.885  ,   246.897  ,   245.606  ,   245.714  ,   245.470  ,   244.956  ,   234.138  /

! specific humidity at full levels
       data qq/    0.1755E-05  ,  0.1745E-05  ,  0.1744E-05  ,  0.1745E-05  ,  0.1748E-05  ,  0.1745E-05  ,  0.1743E-05  ,  0.1760E-05  ,  0.1819E-05  ,  0.1971E-05  ,  0.2128E-05  ,  0.3019E-05  ,  0.4207E-05  ,  0.6811E-05  ,  0.1043E-04  ,  0.1540E-04  ,  0.2231E-04  ,  0.4271E-04  ,  0.6966E-04  ,  0.1081E-03  ,  0.1469E-03  ,  0.1712E-03  ,  0.1945E-03  ,  0.2210E-03  ,  0.2289E-03  ,  0.2230E-03  ,  0.2184E-03  ,  0.2152E-03  ,  0.2324E-03  ,  0.2488E-03  ,  0.2678E-03  ,  0.2467E-03  ,  0.9350E-04  /

!  data uu /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!  data vv /  -0.00,   -0.00,   -0.00,   -0.00,   -0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00,    0.00/
!  data qq /5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16, 5.00e-16,  5.00e-16/

!---------------------------------  
!  print*,'zfull_diff',z_full - 845.221

  !print*,'uu',uu
!  write(*,3001) 'data p_half/',p_half
!  write(*,3001) 'data z_half/',z_half
!  write(*,3001) 'data p_full/',p_full
!  write(*,3001) 'data z_full/',z_full
!  write(*,3000) 'data u_star/',u_star
!  write(*,3003) 'data b_star/',b_star
!  write(*,3003) 'data q_star/',q_star
!  write(*,3000) 'data z_pbl/',z_pbl
!  write(*,3001) 'data uu/',uu
!  write(*,3001) 'data vv/',vv
!  write(*,3001) 'data tt/',tt
!  write(*,3002) 'data qq/',qq
!  goto 9999


  !print*,'hello world'

!  p_half = p_half*100.  ! change units from hPa to Pa
!  p_full = p_full*100.  ! change units from hPa to Pa

  !option_solver = "explicit"
  !option_solver = "implicit"

  is = 1
  js = 1

! case shared
  water_frac = 1

! case 1, qc present, OK
!  qt = 0.00734462
!  thli = 279.94
!  qsat = 0.00634462

! case 2, qc present, should allow compute_qs to work to test this qc-present cases
!  p = 990. * 100.
!  qt = 0.00709856 
!  thli = 277.062
!  qsat = 0.00621676

! case 2, unsaturated, OK
!  p = 990. * 100.
!  qt = 0.00108214
!  thli = 282.45
!  qsat = 0.00634462

!! case 3, just saturated, OK
!  qt = 0.00634462
!  thli = 282.45
!  qsat = 0.00634462
    
  !call compute_thv_qc(qt, thli, p, water_frac, thv1, qc, qsat = qsat)
  !call compute_thv_qc(qt, thli, p, water_frac, thv1, qc, ql, qi, qsat = qsat)

  !thli = 298.15
  !p = 980. * 100.
  !call compute_qs(thli, p, qsat)
!print*,'qsat',qsat


!  !call compute_thv_qc(qt, thli, p, water_frac, thv1, qc)
!  print*,"p= ",p
!  print*,"thli= ",thli
!  print*,"qt= ",qt
!  print*,"qsat= ",qsat
!  print*,''
!  print*,'thv1=',thv1
!  print*,'qc=',qc
!
!  goto 9999

  !qq = qq * 1.e-20
  !qq = qq * 0.8
  print*,''
  print*,';======================'
  print*,';======================'
  print*,';  option_updraft_level, ',option_updraft_level
  print*,';  option_env_half=',option_env_half
  print*,';======================'
  print*,';======================'
  print*,''

  call mass_flux ( is, js, dt, Time_next,                                &
                       p_half, p_full, z_half, z_full,                       & 
                       u_star, b_star, q_star, z_pbl,                        &
                       uu, vv, tt, qq,                                       &
                       is_mass_flux,                                         &
                       sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,          &
                       sum_up_awthv, sum_up_awthli, sum_up_awqt, avg_up_w, sum_up_massflux, &
                       udt_mf, vdt_mf, tdt_mf, qdt_mf, thvdt_mf, thlidt_mf, qtdt_mf)


!  print*,''
!  print*,'======================'
!  print*,'======================'
!  print*,'    updraft_full, env_half=',option_env_half
!  print*,'======================'
!  print*,'======================'
!  print*,''
!
!  !tt2(:,:,1) = tt(:,:,1) 
!  !tt2(:,:,2:nfull2) = tt(:,:,1:nfull) 
!  z_half2(:,:,1)        = z_half(:,:,1)+100.
!  z_half2(:,:,2:nfull2) = z_full(:,:,1:nfull) 
!  z_half2(:,:,nhalf2)   = z_half(:,:,nhalf)
!
!  z_full2(:,:,1:nfull2-1) = z_half(:,:,1:nhalf-1)
!  z_full2(:,:,nfull2)     = 0.5*(z_half2(:,:,nhalf2)+z_half2(:,:,nhalf2-1))
!
!!print*,'z_half',z_half
!!print*,'z_full',z_full
!!print*,'----------------------'
!!print*,'z_half2',z_half2
!!print*,'z_full2',z_full2
!!print*,'----------------------'
!
!  p_half2(:,:,1)        = p_half(:,:,1)-1.
!  p_half2(:,:,2:nfull2) = p_full(:,:,1:nfull) 
!  p_half2(:,:,nhalf2)   = p_half(:,:,nhalf)
!
!  p_full2(:,:,1:nfull2-1) = p_half(:,:,1:nhalf-1)
!  p_full2(:,:,nfull2)     = 0.5*(p_half2(:,:,nhalf2)+p_half2(:,:,nhalf2-1))
!
!!print*,'p_half',p_half
!!print*,'p_full',p_full
!!print*,'----------------------'
!!print*,'p_half2',p_half2
!!print*,'p_full2',p_full2
!!print*,'----------------------'
!
!
!  tt2(:,:,1) = tt(:,:,1)
!  do k=2,nfull
!    tt2(:,:,k) = 0.5*(tt(:,:,k-1)+tt(:,:,k))
!  enddo
!  tt2(:,:,nfull2) = tt(:,:,nfull)
!!print*,'tt',tt
!!print*,'tt2',tt2
!!print*,'----------------------'
!
!  qq2(:,:,1) = qq(:,:,1)
!  do k=2,nfull
!    qq2(:,:,k) = 0.5*(qq(:,:,k-1)+qq(:,:,k))
!  enddo
!  qq2(:,:,nfull2) = qq(:,:,nfull)
!!print*,'qq',qq
!!print*,'qq2',qq2
!!print*,'----------------------'
!
!  uu2(:,:,1) = uu(:,:,1)
!  do k=2,nfull
!    uu2(:,:,k) = 0.5*(uu(:,:,k-1)+uu(:,:,k))
!  enddo
!  uu2(:,:,nfull2) = uu(:,:,nfull)
!!print*,'uu',uu
!!print*,'uu2',uu2
!!print*,'----------------------'
!
!  vv2(:,:,1) = vv(:,:,1)
!  do k=2,nfull
!    vv2(:,:,k) = 0.5*(vv(:,:,k-1)+vv(:,:,k))
!  enddo
!  vv2(:,:,nfull2) = vv(:,:,nfull)
!!print*,'vv',vv
!!print*,'vv2',vv2
!!print*,'----------------------'
!
!  call mass_flux ( is, js, dt, Time_next,                                &
!                       p_half2, p_full2, z_half2, z_full2,                       & 
!                       u_star, b_star, q_star, z_pbl,                        &
!                       uu2, vv2, tt2, qq2,                                       &
!                       is_mass_flux,                                         &
!                       sum_up_a2, sum_up_aw2, sum_up_awu2, sum_up_awv2,          &
!                       sum_up_awthv2, sum_up_awthli2, sum_up_awqt2, avg_up_w2, sum_up_massflux2, &
!                       udt_mf2, vdt_mf2, tdt_mf2, qdt_mf2, thvdt_mf2, thlidt_mf2, qtdt_mf2)



!  !--- compute updraft mass fluxes
!  call mass_flux ( is, js, dt, Time_next,                        &
!                   p_half, p_full, z_half, z_full,               &
!                   u_star, b_star, q_star, z_pbl,                &
!                   uu, vv, tt, qq,                               &
!                   is_mass_flux,                                 &
!                   sum_up_a, sum_up_aw, sum_up_awu, sum_up_awv,  &
!                   sum_up_awthv, sum_up_awqt, avg_up_w, sum_up_massflux )
!
!  !--- compute tendencies from mass fluxes
!  call OUTDATED_massflux_tendencies ( is, js, dt, Time_next,              &
!                             p_half, p_full, z_half, z_full,     &
!                             uu, vv, tt, qq,                     &
!                             is_mass_flux,                       &
!                             sum_up_aw, sum_up_awu, sum_up_awv,  &
!                             sum_up_awthv, sum_up_awqt,          &
!                             udt_mf, vdt_mf, tdt_mf, qdt_mf,     &
!                             thvdt_mf, qtdt_mf)
!!------------
!! printout
!!------------
!i=1
!j=1
!do k=1,nhalf
!  print*,'k,z_half,sum_up_a, sum_up_aw, avg_up_w', &
!     k, z_half(i,j,k), sum_up_a(i,j,k), sum_up_aw(i,j,k), avg_up_w(i,j,k)
!enddo
!
!print*,'-----------------------'
!
!  i=1
!  j=1
!  do k=1,nfull
!    print*, 'k,udt,vdt,tdt,thvdt,qdt,qtdt', &
!             k,udt_mf(i,j,k), vdt_mf(i,j,k), &
!             tdt_mf(i,j,k), thvdt_mf(i,j,k), &
!             qdt_mf(i,j,k), qtdt_mf(i,j,k) 
!  enddo

!---------------
! printout end
!---------------

!  call tridiag(nn,aa,bb,cc,dd)
!print*,'cc',cc
!print*,'dd',dd

9999 continue

101 format ("(40f5.2)")
2000 format (A25,40(E12.4,2X))
2001 format (A25,40(F8.3,2X))
2002 format (A25,I2,A10,40(F8.3,2X))
2003 format (A25,I2,A10,40(E12.4,2X))
3000 format (A15,2X,F8.2)
3001 format (A15,2X,33(F9.3,2X,','))
3002 format (A15,2X,33(E12.4,2X,','))
3003 format (A15,2X,E12.4)

end program test111

